require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff
var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  this.length = 0
  this.parent = undefined

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined' && object.buffer instanceof ArrayBuffer) {
    return fromTypedArray(that, object)
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = String(string)

  if (string.length === 0) return 0

  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      return string.length
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return string.length * 2
    case 'hex':
      return string.length >>> 1
    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(string).length
    case 'base64':
      return base64ToBytes(string).length
    default:
      return string.length
  }
}
Buffer.byteLength = byteLength

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function toString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z\-]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []
  var i = 0

  for (; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (leadSurrogate) {
        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          leadSurrogate = codePoint
          continue
        } else {
          // valid surrogate pair
          codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
          leadSurrogate = null
        }
      } else {
        // no lead yet

        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else {
          // valid lead
          leadSurrogate = codePoint
          continue
        }
      }
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
      leadSurrogate = null
    }

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x200000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":3,"ieee754":4,"is-array":5}],3:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],4:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],5:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],6:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],7:[function(require,module,exports){
var http = module.exports;
var EventEmitter = require('events').EventEmitter;
var Request = require('./lib/request');
var url = require('url')

http.request = function (params, cb) {
    if (typeof params === 'string') {
        params = url.parse(params)
    }
    if (!params) params = {};
    if (!params.host && !params.port) {
        params.port = parseInt(window.location.port, 10);
    }
    if (!params.host && params.hostname) {
        params.host = params.hostname;
    }

    if (!params.protocol) {
        if (params.scheme) {
            params.protocol = params.scheme + ':';
        } else {
            params.protocol = window.location.protocol;
        }
    }

    if (!params.host) {
        params.host = window.location.hostname || window.location.host;
    }
    if (/:/.test(params.host)) {
        if (!params.port) {
            params.port = params.host.split(':')[1];
        }
        params.host = params.host.split(':')[0];
    }
    if (!params.port) params.port = params.protocol == 'https:' ? 443 : 80;
    
    var req = new Request(new xhrHttp, params);
    if (cb) req.on('response', cb);
    return req;
};

http.get = function (params, cb) {
    params.method = 'GET';
    var req = http.request(params, cb);
    req.end();
    return req;
};

http.Agent = function () {};
http.Agent.defaultMaxSockets = 4;

var xhrHttp = (function () {
    if (typeof window === 'undefined') {
        throw new Error('no window object present');
    }
    else if (window.XMLHttpRequest) {
        return window.XMLHttpRequest;
    }
    else if (window.ActiveXObject) {
        var axs = [
            'Msxml2.XMLHTTP.6.0',
            'Msxml2.XMLHTTP.3.0',
            'Microsoft.XMLHTTP'
        ];
        for (var i = 0; i < axs.length; i++) {
            try {
                var ax = new(window.ActiveXObject)(axs[i]);
                return function () {
                    if (ax) {
                        var ax_ = ax;
                        ax = null;
                        return ax_;
                    }
                    else {
                        return new(window.ActiveXObject)(axs[i]);
                    }
                };
            }
            catch (e) {}
        }
        throw new Error('ajax not supported in this browser')
    }
    else {
        throw new Error('ajax not supported in this browser');
    }
})();

http.STATUS_CODES = {
    100 : 'Continue',
    101 : 'Switching Protocols',
    102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918
    200 : 'OK',
    201 : 'Created',
    202 : 'Accepted',
    203 : 'Non-Authoritative Information',
    204 : 'No Content',
    205 : 'Reset Content',
    206 : 'Partial Content',
    207 : 'Multi-Status',               // RFC 4918
    300 : 'Multiple Choices',
    301 : 'Moved Permanently',
    302 : 'Moved Temporarily',
    303 : 'See Other',
    304 : 'Not Modified',
    305 : 'Use Proxy',
    307 : 'Temporary Redirect',
    400 : 'Bad Request',
    401 : 'Unauthorized',
    402 : 'Payment Required',
    403 : 'Forbidden',
    404 : 'Not Found',
    405 : 'Method Not Allowed',
    406 : 'Not Acceptable',
    407 : 'Proxy Authentication Required',
    408 : 'Request Time-out',
    409 : 'Conflict',
    410 : 'Gone',
    411 : 'Length Required',
    412 : 'Precondition Failed',
    413 : 'Request Entity Too Large',
    414 : 'Request-URI Too Large',
    415 : 'Unsupported Media Type',
    416 : 'Requested Range Not Satisfiable',
    417 : 'Expectation Failed',
    418 : 'I\'m a teapot',              // RFC 2324
    422 : 'Unprocessable Entity',       // RFC 4918
    423 : 'Locked',                     // RFC 4918
    424 : 'Failed Dependency',          // RFC 4918
    425 : 'Unordered Collection',       // RFC 4918
    426 : 'Upgrade Required',           // RFC 2817
    428 : 'Precondition Required',      // RFC 6585
    429 : 'Too Many Requests',          // RFC 6585
    431 : 'Request Header Fields Too Large',// RFC 6585
    500 : 'Internal Server Error',
    501 : 'Not Implemented',
    502 : 'Bad Gateway',
    503 : 'Service Unavailable',
    504 : 'Gateway Time-out',
    505 : 'HTTP Version Not Supported',
    506 : 'Variant Also Negotiates',    // RFC 2295
    507 : 'Insufficient Storage',       // RFC 4918
    509 : 'Bandwidth Limit Exceeded',
    510 : 'Not Extended',               // RFC 2774
    511 : 'Network Authentication Required' // RFC 6585
};
},{"./lib/request":8,"events":6,"url":31}],8:[function(require,module,exports){
var Stream = require('stream');
var Response = require('./response');
var Base64 = require('Base64');
var inherits = require('inherits');

var Request = module.exports = function (xhr, params) {
    var self = this;
    self.writable = true;
    self.xhr = xhr;
    self.body = [];
    
    self.uri = (params.protocol || 'http:') + '//'
        + params.host
        + (params.port ? ':' + params.port : '')
        + (params.path || '/')
    ;
    
    if (typeof params.withCredentials === 'undefined') {
        params.withCredentials = true;
    }

    try { xhr.withCredentials = params.withCredentials }
    catch (e) {}
    
    if (params.responseType) try { xhr.responseType = params.responseType }
    catch (e) {}
    
    xhr.open(
        params.method || 'GET',
        self.uri,
        true
    );

    xhr.onerror = function(event) {
        self.emit('error', new Error('Network error'));
    };

    self._headers = {};
    
    if (params.headers) {
        var keys = objectKeys(params.headers);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (!self.isSafeRequestHeader(key)) continue;
            var value = params.headers[key];
            self.setHeader(key, value);
        }
    }
    
    if (params.auth) {
        //basic auth
        this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));
    }

    var res = new Response;
    res.on('close', function () {
        self.emit('close');
    });
    
    res.on('ready', function () {
        self.emit('response', res);
    });

    res.on('error', function (err) {
        self.emit('error', err);
    });
    
    xhr.onreadystatechange = function () {
        // Fix for IE9 bug
        // SCRIPT575: Could not complete the operation due to error c00c023f
        // It happens when a request is aborted, calling the success callback anyway with readyState === 4
        if (xhr.__aborted) return;
        res.handle(xhr);
    };
};

inherits(Request, Stream);

Request.prototype.setHeader = function (key, value) {
    this._headers[key.toLowerCase()] = value
};

Request.prototype.getHeader = function (key) {
    return this._headers[key.toLowerCase()]
};

Request.prototype.removeHeader = function (key) {
    delete this._headers[key.toLowerCase()]
};

Request.prototype.write = function (s) {
    this.body.push(s);
};

Request.prototype.destroy = function (s) {
    this.xhr.__aborted = true;
    this.xhr.abort();
    this.emit('close');
};

Request.prototype.end = function (s) {
    if (s !== undefined) this.body.push(s);

    var keys = objectKeys(this._headers);
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = this._headers[key];
        if (isArray(value)) {
            for (var j = 0; j < value.length; j++) {
                this.xhr.setRequestHeader(key, value[j]);
            }
        }
        else this.xhr.setRequestHeader(key, value)
    }

    if (this.body.length === 0) {
        this.xhr.send('');
    }
    else if (typeof this.body[0] === 'string') {
        this.xhr.send(this.body.join(''));
    }
    else if (isArray(this.body[0])) {
        var body = [];
        for (var i = 0; i < this.body.length; i++) {
            body.push.apply(body, this.body[i]);
        }
        this.xhr.send(body);
    }
    else if (/Array/.test(Object.prototype.toString.call(this.body[0]))) {
        var len = 0;
        for (var i = 0; i < this.body.length; i++) {
            len += this.body[i].length;
        }
        var body = new(this.body[0].constructor)(len);
        var k = 0;
        
        for (var i = 0; i < this.body.length; i++) {
            var b = this.body[i];
            for (var j = 0; j < b.length; j++) {
                body[k++] = b[j];
            }
        }
        this.xhr.send(body);
    }
    else if (isXHR2Compatible(this.body[0])) {
        this.xhr.send(this.body[0]);
    }
    else {
        var body = '';
        for (var i = 0; i < this.body.length; i++) {
            body += this.body[i].toString();
        }
        this.xhr.send(body);
    }
};

// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html
Request.unsafeHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "cookie",
    "cookie2",
    "content-transfer-encoding",
    "date",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "user-agent",
    "via"
];

Request.prototype.isSafeRequestHeader = function (headerName) {
    if (!headerName) return false;
    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;
};

var objectKeys = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var indexOf = function (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (xs[i] === x) return i;
    }
    return -1;
};

var isXHR2Compatible = function (obj) {
    if (typeof Blob !== 'undefined' && obj instanceof Blob) return true;
    if (typeof ArrayBuffer !== 'undefined' && obj instanceof ArrayBuffer) return true;
    if (typeof FormData !== 'undefined' && obj instanceof FormData) return true;
};

},{"./response":9,"Base64":10,"inherits":11,"stream":29}],9:[function(require,module,exports){
var Stream = require('stream');
var util = require('util');

var Response = module.exports = function (res) {
    this.offset = 0;
    this.readable = true;
};

util.inherits(Response, Stream);

var capable = {
    streaming : true,
    status2 : true
};

function parseHeaders (res) {
    var lines = res.getAllResponseHeaders().split(/\r?\n/);
    var headers = {};
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        if (line === '') continue;
        
        var m = line.match(/^([^:]+):\s*(.*)/);
        if (m) {
            var key = m[1].toLowerCase(), value = m[2];
            
            if (headers[key] !== undefined) {
            
                if (isArray(headers[key])) {
                    headers[key].push(value);
                }
                else {
                    headers[key] = [ headers[key], value ];
                }
            }
            else {
                headers[key] = value;
            }
        }
        else {
            headers[line] = true;
        }
    }
    return headers;
}

Response.prototype.getResponse = function (xhr) {
    var respType = String(xhr.responseType).toLowerCase();
    if (respType === 'blob') return xhr.responseBlob || xhr.response;
    if (respType === 'arraybuffer') return xhr.response;
    return xhr.responseText;
}

Response.prototype.getHeader = function (key) {
    return this.headers[key.toLowerCase()];
};

Response.prototype.handle = function (res) {
    if (res.readyState === 2 && capable.status2) {
        try {
            this.statusCode = res.status;
            this.headers = parseHeaders(res);
        }
        catch (err) {
            capable.status2 = false;
        }
        
        if (capable.status2) {
            this.emit('ready');
        }
    }
    else if (capable.streaming && res.readyState === 3) {
        try {
            if (!this.statusCode) {
                this.statusCode = res.status;
                this.headers = parseHeaders(res);
                this.emit('ready');
            }
        }
        catch (err) {}
        
        try {
            this._emitData(res);
        }
        catch (err) {
            capable.streaming = false;
        }
    }
    else if (res.readyState === 4) {
        if (!this.statusCode) {
            this.statusCode = res.status;
            this.emit('ready');
        }
        this._emitData(res);
        
        if (res.error) {
            this.emit('error', this.getResponse(res));
        }
        else this.emit('end');
        
        this.emit('close');
    }
};

Response.prototype._emitData = function (res) {
    var respBody = this.getResponse(res);
    if (respBody.toString().match(/ArrayBuffer/)) {
        this.emit('data', new Uint8Array(respBody, this.offset));
        this.offset = respBody.byteLength;
        return;
    }
    if (respBody.length > this.offset) {
        this.emit('data', respBody.slice(this.offset));
        this.offset = respBody.length;
    }
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

},{"stream":29,"util":33}],10:[function(require,module,exports){
;(function () {

  var object = typeof exports != 'undefined' ? exports : this; // #8: web workers
  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  function InvalidCharacterError(message) {
    this.message = message;
  }
  InvalidCharacterError.prototype = new Error;
  InvalidCharacterError.prototype.name = 'InvalidCharacterError';

  // encoder
  // [https://gist.github.com/999166] by [https://github.com/nignag]
  object.btoa || (
  object.btoa = function (input) {
    for (
      // initialize result and counter
      var block, charCode, idx = 0, map = chars, output = '';
      // if the next input index does not exist:
      //   change the mapping table to "="
      //   check if d has no fractional digits
      input.charAt(idx | 0) || (map = '=', idx % 1);
      // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
      output += map.charAt(63 & block >> 8 - idx % 1 * 8)
    ) {
      charCode = input.charCodeAt(idx += 3/4);
      if (charCode > 0xFF) {
        throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
      }
      block = block << 8 | charCode;
    }
    return output;
  });

  // decoder
  // [https://gist.github.com/1020396] by [https://github.com/atk]
  object.atob || (
  object.atob = function (input) {
    input = input.replace(/=+$/, '');
    if (input.length % 4 == 1) {
      throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
    }
    for (
      // initialize result and counters
      var bc = 0, bs, buffer, idx = 0, output = '';
      // get next character
      buffer = input.charAt(idx++);
      // character found in table? initialize bit storage and add its ascii value;
      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
        // and if not first of each 4 characters,
        // convert the first 8 bits to one ascii character
        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
    ) {
      // try to find character in table (0-63, not found => -1)
      buffer = chars.indexOf(buffer);
    }
    return output;
  });

}());

},{}],11:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],12:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],13:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],14:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],15:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],16:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],17:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":15,"./encode":16}],18:[function(require,module,exports){
module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":19}],19:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

forEach(objectKeys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

}).call(this,require('_process'))
},{"./_stream_readable":21,"./_stream_writable":23,"_process":13,"core-util-is":24,"inherits":11}],20:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":22,"core-util-is":24,"inherits":11}],21:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = require('stream');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var StringDecoder;


/*<replacement>*/
var debug = require('util');
if (debug && debug.debuglog) {
  debug = debug.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/


util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  var Duplex = require('./_stream_duplex');

  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (util.isString(chunk) && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (util.isNullOrUndefined(chunk)) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      if (!addToFront)
        state.reading = false;

      // if we want the data now, just emit it.
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit('data', chunk);
        stream.read(0);
      } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);

        if (state.needReadable)
          emitReadable(stream);
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (isNaN(n) || util.isNull(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (!util.isNumber(n) || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (util.isNull(ret)) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (!util.isNull(ret))
    this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      process.nextTick(function() {
        emitReadable_(stream);
      });
    else
      emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain &&
        (!dest._writableState || dest._writableState.needDrain))
      ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      debug('false write response, pause',
            src._readableState.awaitDrain);
      src._readableState.awaitDrain++;
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        var self = this;
        process.nextTick(function() {
          debug('readable nexttick read 0');
          self.read(0);
        });
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    if (!state.reading) {
      debug('resume read 0');
      this.read(0);
    }
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(function() {
      resume_(stream, state);
    });
  }
}

function resume_(stream, state) {
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}

Readable.prototype.pause = function() {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    debug('wrapped data');
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    if (!chunk || !state.objectMode && !chunk.length)
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require('_process'))
},{"./_stream_duplex":19,"_process":13,"buffer":2,"core-util-is":24,"events":6,"inherits":11,"isarray":12,"stream":29,"string_decoder/":30,"util":1}],22:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (!util.isNullOrUndefined(data))
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('prefinish', function() {
    if (util.isFunction(this._flush))
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":19,"core-util-is":24,"inherits":11}],23:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Stream = require('stream');

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (util.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (!util.isFunction(cb))
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function() {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function() {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing &&
        !state.corked &&
        !state.finished &&
        !state.bufferProcessing &&
        state.buffer.length)
      clearBuffer(this, state);
  }
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      util.isString(chunk)) {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (util.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing || state.corked)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, false, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      state.pendingcb--;
      cb(er);
    });
  else {
    state.pendingcb--;
    cb(er);
  }

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished &&
        !state.corked &&
        !state.bufferProcessing &&
        state.buffer.length) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  if (stream._writev && state.buffer.length > 1) {
    // Fast case, write everything using _writev()
    var cbs = [];
    for (var c = 0; c < state.buffer.length; c++)
      cbs.push(state.buffer[c].callback);

    // count the one we are adding, as well.
    // TODO(isaacs) clean this up
    state.pendingcb++;
    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
      for (var i = 0; i < cbs.length; i++) {
        state.pendingcb--;
        cbs[i](err);
      }
    });

    // Clear buffer
    state.buffer = [];
  } else {
    // Slow case, write chunks one-by-one
    for (var c = 0; c < state.buffer.length; c++) {
      var entry = state.buffer[c];
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);

      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        c++;
        break;
      }
    }

    if (c < state.buffer.length)
      state.buffer = state.buffer.slice(c);
    else
      state.buffer.length = 0;
  }

  state.bufferProcessing = false;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));

};

Writable.prototype._writev = null;

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (util.isFunction(chunk)) {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (!util.isNullOrUndefined(chunk))
    this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else
      prefinish(stream, state);
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

}).call(this,require('_process'))
},{"./_stream_duplex":19,"_process":13,"buffer":2,"core-util-is":24,"inherits":11,"stream":29}],24:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return Buffer.isBuffer(arg);
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
}).call(this,require("buffer").Buffer)
},{"buffer":2}],25:[function(require,module,exports){
module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":20}],26:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = require('stream');
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":19,"./lib/_stream_passthrough.js":20,"./lib/_stream_readable.js":21,"./lib/_stream_transform.js":22,"./lib/_stream_writable.js":23,"stream":29}],27:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":22}],28:[function(require,module,exports){
module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":23}],29:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":6,"inherits":11,"readable-stream/duplex.js":18,"readable-stream/passthrough.js":25,"readable-stream/readable.js":26,"readable-stream/transform.js":27,"readable-stream/writable.js":28}],30:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":2}],31:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

},{"punycode":14,"querystring":17}],32:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],33:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":32,"_process":13,"inherits":11}],"amigo2":[function(require,module,exports){
// If it looks like we're in an environment that supports CommonJS
// Modules 1.0, bbop-js might not be extant in this namespace. Try and
// get at it. Otherwise, if we're in browser-land, it should be
// included in the global and we can proceed.
if( typeof(exports) != 'undefined' ){
    var bbop = require('bbop').bbop;
}
/* 
 * Package: version.js
 * 
 * Namespace: amigo.version
 * 
 * This package was automatically generated during the build process
 * and contains its version information--this is the release of the
 * API that you have.
 */

if ( typeof amigo == "undefined" ){ var amigo = {}; }
if ( typeof amigo.version == "undefined" ){ amigo.version = {}; }

/*
 * Variable: revision
 *
 * Partial version for this library; revision (major/minor version numbers)
 * information.
 */
amigo.version.revision = "2.3.0";

/*
 * Variable: release
 *
 * Partial version for this library: release (date-like) information.
 */
amigo.version.release = "20150422";
/*
 * Package: api.js
 * 
 * Namespace: amigo.api
 * 
 * Core for AmiGO 2 remote functionality.
 * 
 * Provide methods for accessing AmiGO/GO-related web resources from
 * the host server. A loose analog to the perl AmiGO.pm top-level.
 * 
 * This module should contain nothing to do with the DOM, but rather
 * methods to access and make sense of resources provided by AmiGO and
 * its related services on the host.
 * 
 * WARNING: This changes very quickly as parts get spun-out into more
 * stable packages.
 */

// Module and namespace checking.
if( typeof amigo == "undefined" ){ var amigo = {}; }

/*
 * Constructor: api
 * 
 * Contructor for the AmiGO API object.
 * Hooks to useful things back on AmiGO.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  AmiGO object
 */
amigo.api = function(){

    ///
    /// General AmiGO (perl server) AJAX response checking (after
    /// parsing).
    ///

    this.response = {};

    // Check to see if the server thinks we were successful.
    this.response.success = function(robj){
	var retval = false;
	if( robj && robj.success && robj.success == 1 ){
	    retval = true;
	}
	return retval;
    };

    // Check to see what the server thinks about its own condition.
    this.response.type = function(robj){
	var retval = 'unknown';
	if( robj && robj.type ){
	    retval = robj.type;
	}
	return retval;
    };

    // Check to see if the server thinks the data was successful.
    this.response.errors = function(robj){
	var retval = new Array();
	if( robj && robj.errors ){
	    retval = robj.errors;
	}
	return retval;
    };

    // Check to see if the server thinks the data was correct.
    this.response.warnings = function(robj){
	var retval = new Array();
	if( robj && robj.warnings ){
	    retval = robj.warnings;
	}
	return retval;
    };

    // Get the results chunk.
    this.response.results = function(robj){
	var retval = {};
	if( robj && robj.results ){
	    retval = robj.results;
	}
	return retval;
    };

    // Get the arguments chunk.
    this.response.arguments = function(robj){
	var retval = {};
	if( robj && robj.arguments ){
	    retval = robj.arguments;
	}
	return retval;
    };

    ///
    /// Workspaces' linking.
    ///

    function _abstract_head_template(head){
	return head + '?';
    }

    // Convert a hash (with possible arrays as arguments) into a link
    // string.
    // NOTE: Non-recursive--there are some interesting ways to create
    // cyclic graph hashes in SpiderMonkey, and I'd rather not think
    // about it right now.
    function _abstract_segment_template(segments){
	
	var maxibuf = new Array();
	for( var segkey in segments ){

	    var segval = segments[segkey];

	    // If the value looks like an array, iterate over it and
	    // collect.
	    if( segval &&
		segval != null &&
		typeof segval == 'object' &&
		segval.length ){

		for( var i = 0; i < segval.length; i++ ){
		    var minibuffer = new Array();
		    minibuffer.push(segkey);
		    minibuffer.push('=');
		    minibuffer.push(segval[i]);
		    maxibuf.push(minibuffer.join(''));
		}

	    }else{
		var minibuf = new Array();
		minibuf.push(segkey);
		minibuf.push('=');
		minibuf.push(segval);
		maxibuf.push(minibuf.join(''));
	    }
	}
	return maxibuf.join('&');
    }

    // Similar to the above, but creating a solr filter set.
    function _abstract_solr_filter_template(filters){
	
	var allbuf = new Array();
	for( var filter_key in filters ){

	    var filter_val = filters[filter_key];

	    // If the value looks like an array, iterate over it and
	    // collect.
	    if( filter_val &&
		filter_val != null &&
		typeof filter_val == 'object' &&
		filter_val.length ){

		    for( var i = 0; i < filter_val.length; i++ ){
			var minibuffer = new Array();
			var try_val = filter_val[i];
			if( typeof(try_val) != 'undefined' &&
			try_val != '' ){
			    minibuffer.push('fq=');
			    minibuffer.push(filter_key);
			    minibuffer.push(':');
			    minibuffer.push('"');
			    minibuffer.push(filter_val[i]);
			    minibuffer.push('"');
			    allbuf.push(minibuffer.join(''));
			}
		    }		    
		}else{
		    var minibuf = new Array();
		    if( typeof(filter_val) != 'undefined' &&
			filter_val != '' ){
			    minibuf.push('fq=');
			    minibuf.push(filter_key);
			    minibuf.push(':');
			    minibuf.push('"');
			    minibuf.push(filter_val);
			    minibuf.push('"');
			    allbuf.push(minibuf.join(''));
			}
		}
	}
	return allbuf.join('&');
    }

    // Construct the templates using head and segments.
    function _abstract_link_template(head, segments){	
	return _abstract_head_template(head) +
	    _abstract_segment_template(segments);
    }

    // // Construct the templates using the segments.
    // function _navi_client_template(segments){
    // 	segments['mode'] = 'layers_graph';
    // 	return _abstract_link_template('amigo_exp', segments);
    // }

    // // Construct the templates using the segments.
    // function _navi_data_template(segments){
    // 	segments['mode'] = 'navi_js_data';
    // 	return _abstract_link_template('aserve_exp', segments);
    // }

    // Construct the templates using the segments.
    function _ws_template(segments){
	segments['mode'] = 'workspace';
	return _abstract_link_template('amigo_exp', segments);
    }

    // // Construct the templates using the segments.
    // function _ls_assoc_template(segments){
    // 	segments['mode'] = 'live_search_association';
    // 	return _abstract_link_template('aserve', segments);
    // }
    // function _ls_gp_template(segments){
    // 	segments['mode'] = 'live_search_gene_product';
    // 	return _abstract_link_template('aserve', segments);
    // }
    // function _ls_term_template(segments){
    // 	segments['mode'] = 'live_search_term';
    // 	return _abstract_link_template('aserve', segments);
    // }

    // Construct the templates using the segments.
    function _completion_template(segments){
    	return _abstract_link_template('completion', segments);
    }

    // // Construct the templates using the segments.
    // function _nmatrix_template(segments){
    // 	segments['mode'] = 'nmatrix';
    // 	return _abstract_link_template('amigo_exp', segments);
    // }

    this.api = {};
    this.link = {};
    this.html = {};

    //     // Some handling for a workspace object once we get one.
    //     this.util.workspace = {};
    //     this.util.workspace.get_terms = function(ws){
    // 	var all_terms = new Array();
    // 	for( var t = 0; t < ws.length; t++ ){
    // 	    var item = ws[t];
    // 	    if( item.type == 'term' ){
    // 		all_terms.push(item.key);
    // 	    }
    // 	}
    // 	return all_terms;
    //     };

    ///
    /// JSON? JS? API functions for workspaces.
    ///

    this.workspace = {};

    this.workspace.remove = function(ws_name){
	return _ws_template({
	    action: 'remove_workspace',
	    workspace: ws_name
	});
    };
    this.workspace.add = function(ws_name){
	return _ws_template({
	    action: 'add_workspace',
	    workspace: ws_name
	});
    };
    this.workspace.copy = function(ws_from_name, ws_to_name){
	return _ws_template({
	    action: 'copy_workspace',
	    workspace: ws_from_name,
	    copy_to_workspace: ws_to_name
	});
    };
    this.workspace.clear = function(ws_name){
	return _ws_template({
	    action: 'clear_workspace',
	    workspace: ws_name
	});
    };
    this.workspace.list = function(ws_name){
	return _ws_template({
	    action: 'list_workspaces',
	    workspace: ws_name
	});
    };

    // API functions for workspace items.
    //     this.workspace.add_item = function(ws_name, key, type, name){
    this.workspace.add_item = function(ws_name, key, name){
	return _ws_template({
	    action: 'add_item',
	    workspace: ws_name,
	    key: key,
            // _t_y_p_e_: _t_y_p_e_, // prevent naturaldocs from finding this
	    name: name
	});
    };
    this.workspace.remove_item = function(ws_name, key){
	return _ws_template({
	    action: 'remove_item',
	    workspace: ws_name,
	    key: key
	});
    };
    this.workspace.list_items = function(ws_name){
	return _ws_template({
	    action: 'list_items',
	    workspace: ws_name
	});
    };

    // Just the workspace and item status. Essentially do nothing and
    // link to the current session status.
    this.workspace.status = function(){
	return _ws_template({ action: '' });
    };

    ///
    /// API function for completion/search information.
    ///

    this.completion = function(args){

	var format = 'amigo';
	var type = 'general';
	var ontology = null;
	var narrow = 'false';
	var query = '';
	if( args ){
	    if( args['format'] ){ format = args['format']; }
	    if( args['type'] ){ type = args['type']; }
	    if( args['ontology'] ){ontology = args['ontology']; }
	    if( args['narrow'] ){narrow = args['narrow']; }
	    if( args['query'] ){query = args['query']; }
	}

	return _completion_template({format: format,
				     type: type,
				     ontology: ontology,
				     narrow: narrow,
				     query: encodeURIComponent(query)});
    };

    ///
    /// API functions for live search.
    ///
    this.live_search = {};

    // General search:
    // http://accordion.lbl.gov:8080/solr/select?indent=on&version=2.2&q=annotation_class_label%3Abinding&fq=&start=0&rows=10&fl=*%2Cscore&qt=standard&wt=json&explainOther=&hl.fl=
    // Facet on date:
    // http://accordion.lbl.gov:8080/solr/select?indent=on&version=2.2&q=annotation_class_label%3Abinding&fq=&start=0&rows=10&fl=*%2Cscore&qt=standard&wt=json&explainOther=&hl.fl=&facet=true&facet.field=date    
    this.live_search.golr = function(in_args){

	if( ! in_args ){ in_args = {}; }
	var default_query_args =
	    {
		// TODO/BUG? need jsonp things here?
		qt: 'standard',
		indent: 'on',
		wt: 'json',
		version: '2.2',
		rows: 10,
		//start: 1,
		start: 0, // Solr is offset indexing
		fl: '*%2Cscore',

		// Control of facets.
		facet: '',
		'facet.field': [],

		// Facet filtering.
		fq: [],

		// Query-type stuff.
		q: '',

		// Our bookkeeping.
		packet: 0
	    };
	var final_query_args = bbop.core.fold(default_query_args, in_args);
		
	var default_filter_args =
	    {
		// Filter stuff.
		document_category: [],
		type: [],
		source: [],
		taxon: [],
		evidence_type: [],
		evidence_closure: [],
		isa_partof_label_closure: [],
		annotation_extension_class_label: [],
		annotation_extension_class_label_closure: []
	    };
	var final_filter_args = bbop.core.fold(default_filter_args, in_args);

	// ...
	//return _abstract_link_template('select', segments);	
	var complete_query = _abstract_head_template('select') +
	    _abstract_segment_template(final_query_args);
	var addable_filters = _abstract_solr_filter_template(final_filter_args);
	if( addable_filters.length > 0 ){
	    complete_query = complete_query + '&' + addable_filters;
	}
	return complete_query;
    };

    ///
    /// API functions for the ontology.
    ///
    this.ontology = {};
    this.ontology.roots = function(){
	return _abstract_link_template('aserve_exp', {'mode': 'ontology'});
    };

    ///
    /// API functions for navi js data.
    ///

    this.navi_js_data = function(args){

	if( ! args ){ args = {}; }

	var final_args = {};

	// Transfer the name/value pairs in opt_args into final args
	// if extant.
	var opt_args = ['focus', 'zoom', 'lon', 'lat'];
	//var opt_args_str = '';
	for( var oa = 0; oa < opt_args.length; oa++ ){
	    var arg_name = opt_args[oa];
	    if( args[arg_name] ){
		// opt_args_str =
		// opt_args_str + '&' + arg_name + '=' + args[arg_name];
		final_args[arg_name] = args[arg_name];
	    }
	}

	//
	var terms_buf = new Array();
	if( args.terms &&
	    args.terms.length &&
	    args.terms.length > 0 ){

	    //
	    for( var at = 0; at < args.terms.length; at++ ){
		terms_buf.push(args.terms[at]);
	    } 
	}
	final_args['terms'] = terms_buf.join(' '); 

	return _navi_data_template(final_args);
    };

    ///
    /// Links for terms and gene products.
    ///

    function _term_link(in_args){

	if( ! in_args ){ in_args = {}; }
	var default_args =
	    {
		acc: ''
	    };
	var final_args = bbop.core.fold(default_args, in_args);
	
	var acc = final_args['acc'];
	//return 'term_details?term=' + acc;
	return 'amigo?mode=golr_term_details&term=' + acc;
    }
    this.link.term = _term_link;

    // BUG/TODO: should this actually be in widgets? How core is this
    // convenience?
    this.html.term_link = function(acc, label){
	if( ! label ){ label = acc; }
	return '<a title="Go to term details page for ' + label +
	    '." href="' + _term_link({acc: acc}) + '">' + label +'</a>';
    };

    function _gene_product_link(in_args){

	if( ! in_args ){ in_args = {}; }
	var default_args =
	    {
		acc: ''
	    };
	var final_args = bbop.core.fold(default_args, in_args);
	
	var acc = final_args['acc'];
	//return 'gp-details.cgi?gp=' + acc;
	return 'amigo?mode=golr_gene_product_details&gp=' + acc;
    }
    this.link.gene_product = _gene_product_link;

    // BUG/TODO: should this actually be in widgets? How core is this
    // convenience?
    this.html.gene_product_link = function(acc, label){
	if( ! label ){ label = acc; }
	return '<a title="Go to gene product details page for ' + label +
	    '." href="' + _gene_product_link({acc: acc}) + '">' + label +'</a>';
    };

    ///
    /// Links for term product associations.
    ///

    this.link.term_assoc = function(in_args){

	if( ! in_args ){ in_args = {}; }
	var default_args =
	    {
		acc: '',
		speciesdb: [],
		taxid: []
	    };
	var final_args = bbop.core.fold(default_args, in_args);
	var acc = final_args['acc'];
	var speciesdbs = final_args['speciesdb'];
	var taxids = final_args['taxid'];

	//
	var spc_fstr = speciesdbs.join('&speciesdb');
	var tax_fstr = taxids.join('&taxid=');
	//core.kvetch('LINK SRCS: ' + spc_fstr);
	//core.kvetch('LINK TIDS: ' + tax_fstr);

	return 'term-assoc.cgi?term=' + acc +
	    '&speciesdb=' + spc_fstr +
	    '&taxid=' + tax_fstr;
    };

    ///
    /// Link function for blast.
    ///

    this.link.single_blast = function(in_args){

	if( ! in_args ){ in_args = {}; }
	var default_args =
	    {
		acc: ''
	    };
	var final_args = bbop.core.fold(default_args, in_args);
	
	var acc = final_args['acc'];
	return 'blast.cgi?action=blast&seq_id=' + acc;
    };

    ///
    /// Link function for term enrichment.
    ///

    this.link.term_enrichment = function(in_args){

	if( ! in_args ){ in_args = {}; }
	var default_args =
	    {
		gp_list: [] 
	    };
	var final_args = bbop.core.fold(default_args, in_args);
	
	var acc = final_args['acc'];
	return 'term_enrichment?' +
	    'gp_list=' + final_args['gp_list'].join(' ');
    };

    ///
    /// Link function for slimmer.
    ///

    this.link.slimmer = function(in_args){

	if( ! in_args ){ in_args = {}; }
	var default_args =
	    {
		gp_list: [], 
		slim_list: []
	    };
	var final_args = bbop.core.fold(default_args, in_args);
	
	return 'slimmer?' +
	    'gp_list=' + final_args['gp_list'].join(' ') +
	    '&slim_list=' + final_args['slim_list'].join(' ');
    };

    ///
    /// Link function for N-Matrix.
    ///

    this.link.nmatrix = function(in_args){

	if( ! in_args ){ in_args = {}; }
	var default_args =
	    {
		term_set_1: '',
		term_set_2: ''
	    };
	var final_args = bbop.core.fold(default_args, in_args);

	//
	var terms_buf = new Array();
	if( in_args.terms &&
	    in_args.terms.length &&
	    in_args.terms.length > 0 ){

		//
	    for( var at = 0; at < in_args.terms.length; at++ ){
		terms_buf.push(in_args.terms[at]);
	    } 
	}
	final_args['term_set_1'] = terms_buf.join(' '); 
	final_args['term_set_2'] = terms_buf.join(' '); 

	return _nmatrix_template(final_args);
    };

    ///
    /// Link functions for navi client (bookmark).
    ///

    this.link.layers_graph = function(args){

	//
	var final_args = {};
	if( args['lon'] &&
	    args['lat'] &&
	    args['zoom'] &&
	    args['focus'] ){

	    //
	    final_args['lon'] = args['lon'];
	    final_args['lat'] = args['lat'];
	    final_args['zoom'] = args['zoom'];
	    final_args['focus'] = args['focus'];
	}

	if( args['terms'] &&
	    args['terms'].length &&
	    args['terms'].length > 0 ){

	    //
	    var aterms = args['terms'];
	    var terms_buf = new Array();
	    for( var at = 0; at < aterms.length; at++ ){
		terms_buf.push(aterms[at]);
	    }
	    final_args['terms'] = terms_buf.join(' '); 
	}
	
	return _navi_client_template(final_args);
    };

    // TODO:
};
/* 
 * Package: linker.js
 * 
 * Namespace: amigo.linker
 * 
 * Generic AmiGO link generator, fed by <amigo.data.server> for local
 * links and <amigo.data.xrefs> for non-local links.
 * 
 * NOTE: A lot of this is lifted from the (defunct) amigo2.js
 * package. However, the future should be here.
 */

// Module and namespace checking.
if( typeof amigo == "undefined" ){ var amigo = {}; }

/*
 * Constructor: linker
 * 
 * Create an object that can make URLs and/or anchors.
 * 
 * These functions have a well defined interface so that other
 * packages can use it.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  self
 */
amigo.linker = function (){
    this._is_a = 'amigo.linker';

    // With the new dispatcher, relative URLs no longer work, so we
    // have to bring in server data--first let's ensure it.
    if( ! amigo.data.server ){
	throw new Error('we are missing access to amigo.data.server!');
    }
    // Easy app base.
    var sd = new amigo.data.server();
    this.app_base = sd.app_base();
    // Internal term matcher.
    this.term_regexp = null;
    var internal_regexp_str = sd.term_regexp();    
    if( internal_regexp_str ){
	this.term_regexp = new RegExp(internal_regexp_str);
    }

    // Categories for different special cases (internal links).
    this.ont_category = {
	'term': true,
	'ontology_class': true,
	'annotation_class': true,
	'annotation_class_closure': true,
	'annotation_class_list': true
    };
    this.bio_category = {
        'gp': true,
	'gene_product': true,
	'bioentity': true
    };
    this.complex_annotation_category = {
        //'complex_annotation': true,
        'annotation_group': true
        //'annotation_unit': true
    };
    this.search_category = { // not including the trivial medial_search below
        'search': true,
	'live_search': true
    };
    this.search_modifier = {
	// Possibly "dynamic".
	'gene_product': '/bioentity',
	'bioentity': '/bioentity',
	'ontology': '/ontology',
	'annotation': '/annotation',
	'complex_annotation': '/complex_annotation',
	'family': '/family',
	'lego_unit': '/lego_unit',
	'general': '/general'
    };
    this.other_interlinks = {
	'medial_search': '/amigo/medial_search',
	'landing': '/amigo/landing',
	'tools': '/amigo/software_list',
	'schema_details': '/amigo/schema_details',
	'load_details': '/amigo/load_details',
	'browse': '/amigo/browse',
	'goose': '/goose',
	'grebe': '/grebe',
	'gannet': '/gannet',
	'repl': '/repl'	
    };
};

/*
 * Function: url
 * 
 * Return a url string.
 * 
 * Arguments:
 *  args - id
 *  xid - *[optional]* an internal transformation id
 *  modifier - *[optional]* modify xid; only used with xid
 * 
 * Returns:
 *  string (url); null if it couldn't create anything
 */
amigo.linker.prototype.url = function (id, xid, modifier){
    
    var retval = null;

    ///
    /// AmiGO hard-coded internal link types.
    ///

    // For us, having an xid means that we will be doing some more
    // complicated routing.
    if( xid && xid != '' ){

	// First let's do the ones that need an associated id to
	// function--either data urls or searches.
	if( id && id != '' ){
	    if( this.ont_category[xid] ){
		retval = this.app_base + '/amigo/term/' + id;
		//retval = _add_restmark_modifier(retval, modifier);
            }else if( this.bio_category[xid] ){
		retval = this.app_base + '/amigo/gene_product/' + id;
		//retval = _add_restmark_modifier(retval, modifier);
            }else if( this.complex_annotation_category[xid] ){
		retval = this.app_base + '/amigo/complex_annotation/'+ id;
            }else if( this.search_category[xid] ){

		// First, try and get the proper path out. Will
		// hardcode for now since some paths don't map
		// directly to the personality.
		var search_path = '';
		if( this.search_modifier[modifier] ){
		    search_path = this.search_modifier[modifier];
		}
		
		retval = this.app_base + '/amigo/search' + search_path;
		if( id ){
		    // Ugh...decide if the ID indicated a restmark or
		    // a full http action bookmark.
		    var http_re = new RegExp("^http");
		    if( http_re.test(id) ){
			// HTTP bookmark.
			retval = retval + '?bookmark='+ id;
		    }else{
			// minimalist RESTy restmark.
			retval = retval + '?' + id;
		    }
		}
	    }
	}

	// Things that do not need an id to function--like just
	// popping somebody over to Grebe or the medial search.
	if( ! retval ){
	    if( this.other_interlinks[xid] ){
		var extension = this.other_interlinks[xid];
		retval = this.app_base + extension;

		// Well, for medial search really, but it might be
		// general?
		if( xid == 'medial_search' ){
		    // The possibility of just tossing back an empty
		    // search for somebody downstream to fill in.
		    if( bbop.core.is_defined(id) && id != null ){
			retval = retval + '?q=' + id;
		    }
		}
	    }
	}
    }

    ///
    /// External resources. For us, if we haven't found something
    /// so far, try the data xrefs.
    ///
    
    // Since we couldn't find anything with our explicit local
    // transformation set, drop into the great abyss of the xref data.
    if( ! retval && id && id != '' ){ // not internal, but still has an id
	if( ! amigo.data.xrefs ){
	    throw new Error('amigo.data.xrefs is missing!');
	}
	
	// First, extract the probable source and break it into parts.
	var full_id_parts = bbop.core.first_split(':', id);
	if( full_id_parts && full_id_parts[0] && full_id_parts[1] ){
	    var src = full_id_parts[0];
	    var sid = full_id_parts[1];
	    
	    // Now, check to see if it is indeed in our store.
	    var lc_src = src.toLowerCase();
	    var xref = amigo.data.xrefs[lc_src];
	    if( xref && xref['url_syntax'] ){
		retval =
		    xref['url_syntax'].replace('[example_id]', sid, 'g');
	    }
	}
    }
    
    return retval;
};

/*
 * Function: anchor
 * 
 * Return a link as a chunk of HTML, all ready to consume in a
 * display.
 * 
 * Arguments:
 *  args - hash--'id' required; 'label' and 'hilite' are inferred if not extant
 *  xid - *[optional]* an internal transformation id
 *  rest - *[optional]* modify xid; only used with xid
 * 
 * Returns:
 *  string (link); null if it couldn't create anything
 */
amigo.linker.prototype.anchor = function(args, xid, modifier){
    
    var anchor = this;
    var retval = null;

    // Don't even start if there is nothing.
    if( args ){

	// Get what fundamental arguments we can.
	var id = args['id'];
	if( id ){
	
	    // Infer label from id if not present.
	    var label = args['label'];
	    if( ! label ){ label = id; }
	
	    // Infer hilite from label if not present.
	    var hilite = args['hilite'];
	    if( ! hilite ){ hilite = label; }
	
	    // See if the URL is legit. If it is, make something for it.
	    var url = this.url(id, xid, modifier);
	    if( url ){
		
		// First, see if it is one of the internal ones we know about
		// and make something special for it.
		if( xid ){
		    if( this.ont_category[xid] ){
		    
			// Possible internal/external detection here.
			// var class_str = ' class="amigo-ui-term-internal" ';
			var class_str = '';
			var title_str = 'title="' + // internal default
			id + ' (go to the term details page for ' +
			    label + ')"';
			if( this.term_regexp ){
			    if( this.term_regexp.test(id) ){
			    }else{
				class_str = ' class="amigo-ui-term-external" ';
				title_str = ' title="' +
				    id + ' (is an external term; click ' +
				    'to view our internal information for ' +
				    label + ')" ';
			    }
			}
			
			//retval = '<a title="Go to the term details page for '+
 			retval = '<a ' + class_str + title_str +
			    ' href="' + url + '">' + hilite + '</a>';
		    }else if( this.bio_category[xid] ){
 			retval = '<a title="' + id +
			    ' (go to the details page for ' + label +
			    ')" href="' + url + '">' + hilite + '</a>';
		    }else if( this.search_category[xid] ){
			retval = '<a title="Reinstate bookmark for ' + label +
			    '." href="' + url + '">' + hilite + '</a>';
		    }
		}
		
		// If it wasn't in the special transformations, just make
		// something generic.
		if( ! retval ){
		    retval = '<a title="' + id +
			' (go to the page for ' + label +
			')" href="' + url + '">' + hilite + '</a>';
		}
	    }
	}
    }

    return retval;
};
/* 
 * Package: handler.js
 * 
 * Namespace: amigo.handler
 * 
 * Generic AmiGO handler (conforming to what /should/ be described in
 * the BBOP JS documentation), fed by <amigo.data.dispatch>.
 */

// Module and namespace checking.
if( typeof amigo == "undefined" ){ var amigo = {}; }

/*
 * Constructor: handler
 * 
 * Create an object that will run functions in the namespace with a
 * specific profile.
 * 
 * These functions have a well defined interface so that other
 * packages can use them (for example, the results display in
 * LiveSearch.js).
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  self
 */
amigo.handler = function (){
    this._is_a = 'amigo.handler';

    var is_def = bbop.core.is_defined;

    // Let's ensure we're sane.
    if( ! is_def(amigo) ||
	! is_def(amigo.data) ||
	! is_def(amigo.data.dispatch) ){
	throw new Error('we are missing access to amigo.data.dispatch!');
    }

    // Okay, since trying functions into existance is slow, we'll
    // create a cache of strings to functions.
    this.mangle = bbop.core.uuid();
    this.string_to_function_map = {};
    this.entries = 0; // a little extra for debugging and testing
};

/*
 * Function: dispatch
 * 
 * Return a string.
 * 
 * The fallback function is called if no match could be found in the
 * amigo.data.dispatch. It is called with the name and context
 * arguments in the same order.
 * 
 * Arguments:
 *  data - the incoming thing to be handled
 *  name - the field name to be processed
 *  context - *[optional]* a string to add extra context to the call
 *  fallback - *[optional]* a fallback function to call in case nothing is found
 * 
 * Returns:
 *  string; null if it couldn't create anything
 */
amigo.handler.prototype.dispatch = function(data, name, context, fallback){
    
    // Aliases.
    var is_def = bbop.core.is_defined;

    // First, get the specific id for this combination.
    var did = name || '';
    did += '_' + this.mangle;
    if( context ){
	did += '_' + context;
    }

    // If the combination is not already in the map, fill it in as
    // best we can.
    if( ! is_def(this.string_to_function_map[did]) ){
	
	this.entries += 1;

	// First, try and get the most specific.
	if( is_def(amigo.data.dispatch[name]) ){

	    var field_hash = amigo.data.dispatch[name];
	    var function_string = null;

	    if( is_def(field_hash['context']) &&
		is_def(field_hash['context'][context]) ){
		// The most specific.
		function_string = field_hash['context'][context];
	    }else{
		// If the most specific cannot be found, try and get
		// the more general one.
		if( is_def(field_hash['default']) ){
		    function_string = field_hash['default'];
		}
	    }

	    // At the end of this section, if we don't have a string
	    // to resolve into a function, the data format we're
	    // working from is damaged.
	    if( function_string == null ){
		throw new Error('amigo.data.dispatch appears to be damaged!');
	    }
	    
	    // We have a string. Pop it into existance with eval.
	    var evalled_thing = eval(function_string);

	    // Final test, make sure it is a function.
	    if( ! is_def(evalled_thing) ||
		evalled_thing == null ||
		bbop.core.what_is(evalled_thing) != 'function' ){
		throw new Error('"' + function_string + '" did not resolve!');
	    }else{
		this.string_to_function_map[did] = evalled_thing;		
	    }

	}else if( is_def(fallback) ){
	    // Nothing could be found, so add the fallback if it is
	    // there.
	    this.string_to_function_map[did] = fallback;
	}else{
	    // Whelp, nothing there, so stick an indicator in.
	    this.string_to_function_map[did] = null;
	}
    }

    // We are now ensured that either we have a callable function or
    // null, so let's finish it--either the return value of the called
    // function or null.
    var retval = null;
    if( this.string_to_function_map[did] != null ){
	var cfunc = this.string_to_function_map[did];
	retval = cfunc(data, name, context);
    }
    return retval;
};
/* 
 * Package: echo.js
 * 
 * Namespace: amigo.handlers.echo
 * 
 * Static function handler for echoing inputs--really used for
 * teaching and testing.
 */

if ( typeof amigo == "undefined" ){ var amigo = {}; }
if ( typeof amigo.handlers == "undefined" ){ amigo.handlers = {}; }

/*
 * Function: echo
 * 
 * Applies bbop.core.dump to whatever comes in.
 * 
 * Parameters:
 *  thing
 * 
 * Returns:
 *  a string; it /will/ be a string
 * 
 * Also See: <bbop.handler>
 */
amigo.handlers.echo = function(thing, name, context){

    // Force a return string into existence.
    var retstr = null;
    try {
	retstr = bbop.core.dump(thing);
    } catch (x) {
	retstr = '';
    }

    // // Appaend any optional stuff.
    // var is_def = bbop.core.is_defined;
    // var what = bbop.core.what_is;
    // if( is_def(name) && what(name) == 'string' ){
    // 	retstr += ' (' + name + ')';
    // }
    // if( is_def(context) && what(context) == 'string' ){
    // 	retstr += ' (' + context + ')';
    // }

    return retstr;
};
/* 
 * Package: owl_class_expression.js
 * 
 * Namespace: amigo.handlers.owl_class_expression
 * 
 * Static function handler for displaying OWL class expression
 * results. To be used for GAF column 16 stuff.
 */

if ( typeof amigo == "undefined" ){ var amigo = {}; }
if ( typeof amigo.handlers == "undefined" ){ amigo.handlers = {}; }

/*
 * Function: owl_class_expression
 * 
 * Example incoming data (as a string or object):
 * 
 * : { relationship: {
 * :     relation: [{id: "RO:001234", label: "regulates"},
 * :                {id:"BFO:0003456", label: "hp"}], 
 * :     id: "MGI:MGI:185963",
 * :     label: "kidney"
 * :   }
 * : }
 * 
 * Parameters:
 *  JSON object as *[string or object]*; see above
 * 
 * Returns:
 *  HTML string
 * 
 * Also See: <bbop.handler>
 */
amigo.handlers.owl_class_expression = function(in_owlo){

    var retstr = "";

    // // Add logging.
    // var logger = new bbop.logger();
    // logger.DEBUG = true;
    // //logger.DEBUG = false;
    // function ll(str){ logger.kvetch(str); }

    // Aliases.
    var is_def = bbop.core.is_defined;
    var what_is = bbop.core.what_is;
    var loop = bbop.core.each;

    var owlo = in_owlo;
    if( what_is(owlo) == 'string' ){
	// This should be an unnecessary robustness check as
	// everything /should/ be a legit JSON string...but things
	// happen in testing. We'll check to make sure that it looks
	// like what it should be as well.
	if( in_owlo.charAt(0) == '{' &&
	    in_owlo.charAt(in_owlo.length-1) == '}' ){
	    owlo = bbop.json.parse(in_owlo) || {};
	}else{
	    // Looks like a normal string string.
	    // Do nothing for now, but catch in the next section.
	}
    }

    // Check to make sure that it looks right.
    if( what_is(owlo) == 'string' ){
	// Still a string means bad happened--we want to see that.
	retstr = owlo + '?';
    }else if( ! is_def(owlo) ||
	      ! is_def(owlo['relationship']) ||
	      ! what_is(owlo['relationship']) == 'object' ||
	      ! what_is(owlo['relationship']['relation']) == 'array' ||
	      ! is_def(owlo['relationship']['id']) ||
	      ! is_def(owlo['relationship']['label']) ){
	// 'Twas an error--ignore.
	//throw new Error('sproing!');
    }else{
	
	//throw new Error('sproing!');
	var link = new amigo.linker();

	// Okay, right structure--first assemble the relationships,
	// then tag onto end.
	var rel_buff = [];
	bbop.core.each(owlo['relationship']['relation'],
		       function(rel){
			   // Check to make sure that these are
			   // structured correctly as well.
			   var rel_id = rel['id'];
			   var rel_lbl = rel['label'];
			   if( is_def(rel_id) && is_def(rel_lbl) ){
			       var an =
				   link.anchor({id: rel_id, label: rel_lbl});
			       // Final check: if we didn't get
			       // anything reasonable, just a label.
			       if( ! an ){ an = rel_lbl; }
			       rel_buff.push(an);
			       // ll('in ' + rel_id + ' + ' + rel_lbl + ': ' + an);
			   }
		       });
	var ranc = link.anchor({id: owlo['relationship']['id'],
				label: owlo['relationship']['label']});
	// Again, a final check
	if( ! ranc ){ ranc = owlo['relationship']['label']; }
	retstr = rel_buff.join(' &rarr; ') + ' ' + ranc;
    }
    
    return retstr;
};
/* 
 * Package: qualifiers.js
 * 
 * Namespace: amigo.handlers.qualifiers
 * 
 * 
 */

if ( typeof amigo == "undefined" ){ var amigo = {}; }
if ( typeof amigo.handlers == "undefined" ){ amigo.handlers = {}; }

/*
 * Function: qualifiers
 * 
 * Essentially catch certain strings and hightlight them.
 * 
 * Example incoming data as string:
 * 
 * : "not"
 * 
 * Parameters:
 *  string or null
 * 
 * Returns:
 *  HTML string
 * 
 * Also See: <bbop.handler>
 */
amigo.handlers.qualifiers = function(in_qual){

    var retstr = in_qual;

    // Aliases.
    var is_def = bbop.core.is_defined;
    var what_is = bbop.core.what_is;

    if( is_def(in_qual) ){
	if( what_is(in_qual) == 'string' ){
	    if( in_qual == 'not' || in_qual == 'NOT' ){
		retstr = '<span class="qualifier-not">NOT</span>';
	    }
	}
    }

    return retstr;
};
/* 
 * Package: golr.js
 * 
 * Namespace: amigo.data.golr
 * 
 * This package was automatically created during an AmiGO 2 installation
 * from the YAML configuration files that AmiGO pulls in.
 *
 * Useful information about GOlr. See the package <golr_conf.js>
 * for the API to interact with this data file.
 *
 * NOTE: This file is generated dynamically at installation time.
 * Hard to work with unit tests--hope it's not too bad. You have to
 * occasionally copy back to keep the unit tests sane.
 *
 * NOTE: This file has a slightly different latout from the YAML
 * configurations files--in addition instead of the fields
 * being in lists (fields), they are in hashes keyed by the
 * field id (fields_hash).
 */

// All of the server/instance-specific meta-data.
if ( typeof amigo == "undefined" ){ var amigo = {}; }
if ( typeof amigo.data == "undefined" ){ amigo.data = {}; }

/*
 * Variable: golr
 * 
 * The configuration for the data.
 * Essentially a JSONification of the OWLTools YAML files.
 * This should be consumed directly by <bbop.golr.conf>.
 */
amigo.data.golr = {
   "bioentity" : {
      "display_name" : "Genes and gene products",
      "description" : "Genes and gene products associated with GO terms.",
      "_strict" : 0,
      "searchable_extension" : "_searchable",
      "_infile" : "/home/sjcarbon/local/src/git/amigo/metadata/bio-config.yaml",
      "result_weights" : "bioentity^8.0 bioentity_name^7.0 taxon^6.0 panther_family^5.0 type^4.0 source^3.0 annotation_class_list^2.0 synonym^1.0",
      "boost_weights" : "bioentity^2.0 bioentity_label^2.0 bioentity_name^1.0 bioentity_internal_id^1.0 synonym^1.0 isa_partof_closure_label^1.0 regulates_closure^1.0 regulates_closure_label^1.0 panther_family^1.0 panther_family_label^1.0 taxon_closure_label^1.0",
      "document_category" : "bioentity",
      "schema_generating" : "true",
      "fields" : [
         {
            "required" : "false",
            "cardinality" : "single",
            "description" : "Gene of gene product ID.",
            "display_name" : "Acc",
            "id" : "id",
            "indexed" : "true",
            "searchable" : "false",
            "transform" : [],
            "property" : [],
            "type" : "string"
         },
         {
            "id" : "bioentity",
            "indexed" : "true",
            "searchable" : "false",
            "property" : [],
            "transform" : [],
            "type" : "string",
            "description" : "Gene or gene product ID.",
            "display_name" : "Acc",
            "required" : "false",
            "cardinality" : "single"
         },
         {
            "required" : "false",
            "cardinality" : "single",
            "description" : "Symbol or name.",
            "display_name" : "Label",
            "id" : "bioentity_label",
            "indexed" : "true",
            "searchable" : "true",
            "transform" : [],
            "property" : [],
            "type" : "string"
         },
         {
            "required" : "false",
            "cardinality" : "single",
            "description" : "The full name of the gene product.",
            "display_name" : "Name",
            "id" : "bioentity_name",
            "indexed" : "true",
            "searchable" : "true",
            "transform" : [],
            "property" : [],
            "type" : "string"
         },
         {
            "id" : "bioentity_internal_id",
            "indexed" : "false",
            "transform" : [],
            "searchable" : "false",
            "property" : [],
            "type" : "string",
            "description" : "The bioentity ID used at the database of origin.",
            "display_name" : "This should not be displayed",
            "required" : "false",
            "cardinality" : "single"
         },
         {
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "false",
            "indexed" : "true",
            "id" : "type",
            "display_name" : "Type",
            "description" : "Type class.",
            "cardinality" : "single",
            "required" : "false"
         },
         {
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "Taxon",
            "description" : "Taxonomic group",
            "type" : "string",
            "property" : [],
            "searchable" : "false",
            "transform" : [],
            "indexed" : "true",
            "id" : "taxon"
         },
         {
            "indexed" : "true",
            "id" : "taxon_label",
            "type" : "string",
            "property" : [],
            "searchable" : "true",
            "transform" : [],
            "cardinality" : "single",
            "required" : "false",
            "description" : "Taxonomic group",
            "display_name" : "Taxon"
         },
         {
            "type" : "string",
            "searchable" : "false",
            "transform" : [],
            "property" : [],
            "indexed" : "true",
            "id" : "taxon_closure",
            "cardinality" : "multi",
            "required" : "false",
            "display_name" : "Taxon",
            "description" : "Taxonomic group and ancestral groups."
         },
         {
            "type" : "string",
            "property" : [],
            "searchable" : "true",
            "transform" : [],
            "indexed" : "true",
            "id" : "taxon_closure_label",
            "cardinality" : "multi",
            "required" : "false",
            "display_name" : "Taxon",
            "description" : "Taxonomic group and ancestral groups."
         },
         {
            "transform" : [],
            "searchable" : "false",
            "property" : [],
            "type" : "string",
            "id" : "isa_partof_closure",
            "indexed" : "true",
            "display_name" : "Involved in",
            "description" : "Closure of ids/accs over isa and partof.",
            "required" : "false",
            "cardinality" : "multi"
         },
         {
            "type" : "string",
            "property" : [],
            "transform" : [],
            "searchable" : "true",
            "indexed" : "true",
            "id" : "isa_partof_closure_label",
            "cardinality" : "multi",
            "required" : "false",
            "display_name" : "Involved in",
            "description" : "Closure of labels over isa and partof."
         },
         {
            "required" : "false",
            "cardinality" : "multi",
            "description" : "Bioentities associated with this term or its children (over regulates).",
            "display_name" : "Inferred annotation",
            "id" : "regulates_closure",
            "indexed" : "true",
            "searchable" : "false",
            "transform" : [],
            "property" : [],
            "type" : "string"
         },
         {
            "display_name" : "Inferred annotation",
            "description" : "Bioentities associated with this term or its children (over regulates).",
            "required" : "false",
            "cardinality" : "multi",
            "transform" : [],
            "searchable" : "true",
            "property" : [],
            "type" : "string",
            "id" : "regulates_closure_label",
            "indexed" : "true"
         },
         {
            "cardinality" : "single",
            "required" : "false",
            "description" : "Database source.",
            "display_name" : "Source",
            "indexed" : "true",
            "id" : "source",
            "type" : "string",
            "searchable" : "false",
            "transform" : [],
            "property" : []
         },
         {
            "indexed" : "true",
            "id" : "annotation_class_list",
            "type" : "string",
            "property" : [],
            "searchable" : "false",
            "transform" : [],
            "cardinality" : "multi",
            "required" : "false",
            "description" : "Direct annotations.",
            "display_name" : "Direct annotation"
         },
         {
            "indexed" : "true",
            "id" : "annotation_class_list_label",
            "type" : "string",
            "searchable" : "false",
            "property" : [],
            "transform" : [],
            "cardinality" : "multi",
            "required" : "false",
            "description" : "Direct annotations.",
            "display_name" : "Direct annotation"
         },
         {
            "required" : "false",
            "cardinality" : "multi",
            "display_name" : "Synonyms",
            "description" : "Gene product synonyms.",
            "transform" : [],
            "property" : [],
            "searchable" : "false",
            "type" : "string",
            "id" : "synonym",
            "indexed" : "true"
         },
         {
            "indexed" : "true",
            "id" : "panther_family",
            "type" : "string",
            "searchable" : "true",
            "property" : [],
            "transform" : [],
            "description" : "PANTHER families that are associated with this entity.",
            "display_name" : "PANTHER family",
            "cardinality" : "single",
            "required" : "false"
         },
         {
            "display_name" : "PANTHER family",
            "description" : "PANTHER families that are associated with this entity.",
            "required" : "false",
            "cardinality" : "single",
            "searchable" : "true",
            "property" : [],
            "transform" : [],
            "type" : "string",
            "id" : "panther_family_label",
            "indexed" : "true"
         },
         {
            "description" : "JSON blob form of the phylogenic tree.",
            "display_name" : "This should not be displayed",
            "cardinality" : "single",
            "required" : "false",
            "indexed" : "false",
            "id" : "phylo_graph_json",
            "type" : "string",
            "searchable" : "false",
            "property" : [],
            "transform" : []
         },
         {
            "type" : "string",
            "searchable" : "false",
            "transform" : [],
            "property" : [],
            "indexed" : "true",
            "id" : "database_xref",
            "display_name" : "DB xref",
            "description" : "Database cross-reference.",
            "cardinality" : "multi",
            "required" : "false"
         }
      ],
      "filter_weights" : "source^7.0 type^6.0 panther_family_label^5.0 annotation_class_list_label^3.5 taxon_closure_label^4.0 regulates_closure_label^2.0",
      "id" : "bioentity",
      "_outfile" : "/home/sjcarbon/local/src/git/amigo/metadata/bio-config.yaml",
      "weight" : "30",
      "fields_hash" : {
         "isa_partof_closure" : {
            "transform" : [],
            "searchable" : "false",
            "property" : [],
            "type" : "string",
            "id" : "isa_partof_closure",
            "indexed" : "true",
            "display_name" : "Involved in",
            "description" : "Closure of ids/accs over isa and partof.",
            "required" : "false",
            "cardinality" : "multi"
         },
         "taxon" : {
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "Taxon",
            "description" : "Taxonomic group",
            "type" : "string",
            "property" : [],
            "searchable" : "false",
            "transform" : [],
            "indexed" : "true",
            "id" : "taxon"
         },
         "bioentity_label" : {
            "required" : "false",
            "cardinality" : "single",
            "description" : "Symbol or name.",
            "display_name" : "Label",
            "id" : "bioentity_label",
            "indexed" : "true",
            "searchable" : "true",
            "transform" : [],
            "property" : [],
            "type" : "string"
         },
         "synonym" : {
            "required" : "false",
            "cardinality" : "multi",
            "display_name" : "Synonyms",
            "description" : "Gene product synonyms.",
            "transform" : [],
            "property" : [],
            "searchable" : "false",
            "type" : "string",
            "id" : "synonym",
            "indexed" : "true"
         },
         "bioentity" : {
            "id" : "bioentity",
            "indexed" : "true",
            "searchable" : "false",
            "property" : [],
            "transform" : [],
            "type" : "string",
            "description" : "Gene or gene product ID.",
            "display_name" : "Acc",
            "required" : "false",
            "cardinality" : "single"
         },
         "id" : {
            "required" : "false",
            "cardinality" : "single",
            "description" : "Gene of gene product ID.",
            "display_name" : "Acc",
            "id" : "id",
            "indexed" : "true",
            "searchable" : "false",
            "transform" : [],
            "property" : [],
            "type" : "string"
         },
         "taxon_closure" : {
            "type" : "string",
            "searchable" : "false",
            "transform" : [],
            "property" : [],
            "indexed" : "true",
            "id" : "taxon_closure",
            "cardinality" : "multi",
            "required" : "false",
            "display_name" : "Taxon",
            "description" : "Taxonomic group and ancestral groups."
         },
         "bioentity_internal_id" : {
            "id" : "bioentity_internal_id",
            "indexed" : "false",
            "transform" : [],
            "searchable" : "false",
            "property" : [],
            "type" : "string",
            "description" : "The bioentity ID used at the database of origin.",
            "display_name" : "This should not be displayed",
            "required" : "false",
            "cardinality" : "single"
         },
         "panther_family" : {
            "indexed" : "true",
            "id" : "panther_family",
            "type" : "string",
            "searchable" : "true",
            "property" : [],
            "transform" : [],
            "description" : "PANTHER families that are associated with this entity.",
            "display_name" : "PANTHER family",
            "cardinality" : "single",
            "required" : "false"
         },
         "taxon_closure_label" : {
            "type" : "string",
            "property" : [],
            "searchable" : "true",
            "transform" : [],
            "indexed" : "true",
            "id" : "taxon_closure_label",
            "cardinality" : "multi",
            "required" : "false",
            "display_name" : "Taxon",
            "description" : "Taxonomic group and ancestral groups."
         },
         "type" : {
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "false",
            "indexed" : "true",
            "id" : "type",
            "display_name" : "Type",
            "description" : "Type class.",
            "cardinality" : "single",
            "required" : "false"
         },
         "regulates_closure_label" : {
            "display_name" : "Inferred annotation",
            "description" : "Bioentities associated with this term or its children (over regulates).",
            "required" : "false",
            "cardinality" : "multi",
            "transform" : [],
            "searchable" : "true",
            "property" : [],
            "type" : "string",
            "id" : "regulates_closure_label",
            "indexed" : "true"
         },
         "database_xref" : {
            "type" : "string",
            "searchable" : "false",
            "transform" : [],
            "property" : [],
            "indexed" : "true",
            "id" : "database_xref",
            "display_name" : "DB xref",
            "description" : "Database cross-reference.",
            "cardinality" : "multi",
            "required" : "false"
         },
         "source" : {
            "cardinality" : "single",
            "required" : "false",
            "description" : "Database source.",
            "display_name" : "Source",
            "indexed" : "true",
            "id" : "source",
            "type" : "string",
            "searchable" : "false",
            "transform" : [],
            "property" : []
         },
         "taxon_label" : {
            "indexed" : "true",
            "id" : "taxon_label",
            "type" : "string",
            "property" : [],
            "searchable" : "true",
            "transform" : [],
            "cardinality" : "single",
            "required" : "false",
            "description" : "Taxonomic group",
            "display_name" : "Taxon"
         },
         "panther_family_label" : {
            "display_name" : "PANTHER family",
            "description" : "PANTHER families that are associated with this entity.",
            "required" : "false",
            "cardinality" : "single",
            "searchable" : "true",
            "property" : [],
            "transform" : [],
            "type" : "string",
            "id" : "panther_family_label",
            "indexed" : "true"
         },
         "bioentity_name" : {
            "required" : "false",
            "cardinality" : "single",
            "description" : "The full name of the gene product.",
            "display_name" : "Name",
            "id" : "bioentity_name",
            "indexed" : "true",
            "searchable" : "true",
            "transform" : [],
            "property" : [],
            "type" : "string"
         },
         "annotation_class_list_label" : {
            "indexed" : "true",
            "id" : "annotation_class_list_label",
            "type" : "string",
            "searchable" : "false",
            "property" : [],
            "transform" : [],
            "cardinality" : "multi",
            "required" : "false",
            "description" : "Direct annotations.",
            "display_name" : "Direct annotation"
         },
         "annotation_class_list" : {
            "indexed" : "true",
            "id" : "annotation_class_list",
            "type" : "string",
            "property" : [],
            "searchable" : "false",
            "transform" : [],
            "cardinality" : "multi",
            "required" : "false",
            "description" : "Direct annotations.",
            "display_name" : "Direct annotation"
         },
         "regulates_closure" : {
            "required" : "false",
            "cardinality" : "multi",
            "description" : "Bioentities associated with this term or its children (over regulates).",
            "display_name" : "Inferred annotation",
            "id" : "regulates_closure",
            "indexed" : "true",
            "searchable" : "false",
            "transform" : [],
            "property" : [],
            "type" : "string"
         },
         "phylo_graph_json" : {
            "description" : "JSON blob form of the phylogenic tree.",
            "display_name" : "This should not be displayed",
            "cardinality" : "single",
            "required" : "false",
            "indexed" : "false",
            "id" : "phylo_graph_json",
            "type" : "string",
            "searchable" : "false",
            "property" : [],
            "transform" : []
         },
         "isa_partof_closure_label" : {
            "type" : "string",
            "property" : [],
            "transform" : [],
            "searchable" : "true",
            "indexed" : "true",
            "id" : "isa_partof_closure_label",
            "cardinality" : "multi",
            "required" : "false",
            "display_name" : "Involved in",
            "description" : "Closure of labels over isa and partof."
         }
      }
   },
   "bbop_ann_ev_agg" : {
      "document_category" : "annotation_evidence_aggregate",
      "schema_generating" : "true",
      "fields" : [
         {
            "searchable" : "false",
            "transform" : [],
            "property" : [],
            "type" : "string",
            "id" : "id",
            "indexed" : "true",
            "display_name" : "Acc",
            "description" : "Gene/product ID.",
            "required" : "false",
            "cardinality" : "single"
         },
         {
            "id" : "bioentity",
            "indexed" : "true",
            "searchable" : "false",
            "property" : [],
            "transform" : [],
            "type" : "string",
            "required" : "false",
            "cardinality" : "single",
            "description" : "Column 1 + columns 2.",
            "display_name" : "Gene/product ID"
         },
         {
            "display_name" : "Gene/product label",
            "description" : "Column 3.",
            "required" : "false",
            "cardinality" : "single",
            "searchable" : "true",
            "transform" : [],
            "property" : [],
            "type" : "string",
            "id" : "bioentity_label",
            "indexed" : "true"
         },
         {
            "display_name" : "Annotation class",
            "description" : "Column 5.",
            "cardinality" : "single",
            "required" : "false",
            "type" : "string",
            "searchable" : "false",
            "property" : [],
            "transform" : [],
            "indexed" : "true",
            "id" : "annotation_class"
         },
         {
            "display_name" : "Annotation class label",
            "description" : "Column 5 + ontology.",
            "required" : "false",
            "cardinality" : "single",
            "property" : [],
            "searchable" : "true",
            "transform" : [],
            "type" : "string",
            "id" : "annotation_class_label",
            "indexed" : "true"
         },
         {
            "indexed" : "true",
            "id" : "evidence_type_closure",
            "type" : "string",
            "property" : [],
            "searchable" : "false",
            "transform" : [],
            "cardinality" : "multi",
            "required" : "false",
            "description" : "All evidence for this term/gene product pair",
            "display_name" : "Evidence type"
         },
         {
            "display_name" : "Evidence with",
            "description" : "All column 8s for this term/gene product pair",
            "cardinality" : "multi",
            "required" : "false",
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "false",
            "indexed" : "true",
            "id" : "evidence_with"
         },
         {
            "id" : "taxon",
            "indexed" : "true",
            "property" : [],
            "transform" : [],
            "searchable" : "false",
            "type" : "string",
            "required" : "false",
            "cardinality" : "single",
            "description" : "Column 13: taxon.",
            "display_name" : "Taxon"
         },
         {
            "transform" : [],
            "searchable" : "true",
            "property" : [],
            "type" : "string",
            "id" : "taxon_label",
            "indexed" : "true",
            "display_name" : "Taxon",
            "description" : "Derived from C13 + ncbi_taxonomy.obo.",
            "required" : "false",
            "cardinality" : "single"
         },
         {
            "indexed" : "true",
            "id" : "taxon_closure",
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "false",
            "description" : "IDs derived from C13 + ncbi_taxonomy.obo.",
            "display_name" : "Taxon (IDs)",
            "cardinality" : "multi",
            "required" : "false"
         },
         {
            "display_name" : "Taxon",
            "description" : "Labels derived from C13 + ncbi_taxonomy.obo.",
            "required" : "false",
            "cardinality" : "multi",
            "transform" : [],
            "property" : [],
            "searchable" : "true",
            "type" : "string",
            "id" : "taxon_closure_label",
            "indexed" : "true"
         },
         {
            "type" : "string",
            "searchable" : "true",
            "property" : [],
            "transform" : [],
            "indexed" : "true",
            "id" : "panther_family",
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "Protein family",
            "description" : "Family IDs that are associated with this entity."
         },
         {
            "type" : "string",
            "searchable" : "true",
            "transform" : [],
            "property" : [],
            "indexed" : "true",
            "id" : "panther_family_label",
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "Family",
            "description" : "Families that are associated with this entity."
         }
      ],
      "id" : "bbop_ann_ev_agg",
      "filter_weights" : "evidence_type_closure^4.0 evidence_with^3.0 taxon_closure_label^2.0",
      "weight" : "-10",
      "_outfile" : "/home/sjcarbon/local/src/git/amigo/metadata/ann_ev_agg-config.yaml",
      "fields_hash" : {
         "evidence_with" : {
            "display_name" : "Evidence with",
            "description" : "All column 8s for this term/gene product pair",
            "cardinality" : "multi",
            "required" : "false",
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "false",
            "indexed" : "true",
            "id" : "evidence_with"
         },
         "panther_family" : {
            "type" : "string",
            "searchable" : "true",
            "property" : [],
            "transform" : [],
            "indexed" : "true",
            "id" : "panther_family",
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "Protein family",
            "description" : "Family IDs that are associated with this entity."
         },
         "evidence_type_closure" : {
            "indexed" : "true",
            "id" : "evidence_type_closure",
            "type" : "string",
            "property" : [],
            "searchable" : "false",
            "transform" : [],
            "cardinality" : "multi",
            "required" : "false",
            "description" : "All evidence for this term/gene product pair",
            "display_name" : "Evidence type"
         },
         "taxon_closure" : {
            "indexed" : "true",
            "id" : "taxon_closure",
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "false",
            "description" : "IDs derived from C13 + ncbi_taxonomy.obo.",
            "display_name" : "Taxon (IDs)",
            "cardinality" : "multi",
            "required" : "false"
         },
         "id" : {
            "searchable" : "false",
            "transform" : [],
            "property" : [],
            "type" : "string",
            "id" : "id",
            "indexed" : "true",
            "display_name" : "Acc",
            "description" : "Gene/product ID.",
            "required" : "false",
            "cardinality" : "single"
         },
         "taxon_closure_label" : {
            "display_name" : "Taxon",
            "description" : "Labels derived from C13 + ncbi_taxonomy.obo.",
            "required" : "false",
            "cardinality" : "multi",
            "transform" : [],
            "property" : [],
            "searchable" : "true",
            "type" : "string",
            "id" : "taxon_closure_label",
            "indexed" : "true"
         },
         "annotation_class_label" : {
            "display_name" : "Annotation class label",
            "description" : "Column 5 + ontology.",
            "required" : "false",
            "cardinality" : "single",
            "property" : [],
            "searchable" : "true",
            "transform" : [],
            "type" : "string",
            "id" : "annotation_class_label",
            "indexed" : "true"
         },
         "bioentity" : {
            "id" : "bioentity",
            "indexed" : "true",
            "searchable" : "false",
            "property" : [],
            "transform" : [],
            "type" : "string",
            "required" : "false",
            "cardinality" : "single",
            "description" : "Column 1 + columns 2.",
            "display_name" : "Gene/product ID"
         },
         "bioentity_label" : {
            "display_name" : "Gene/product label",
            "description" : "Column 3.",
            "required" : "false",
            "cardinality" : "single",
            "searchable" : "true",
            "transform" : [],
            "property" : [],
            "type" : "string",
            "id" : "bioentity_label",
            "indexed" : "true"
         },
         "panther_family_label" : {
            "type" : "string",
            "searchable" : "true",
            "transform" : [],
            "property" : [],
            "indexed" : "true",
            "id" : "panther_family_label",
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "Family",
            "description" : "Families that are associated with this entity."
         },
         "taxon_label" : {
            "transform" : [],
            "searchable" : "true",
            "property" : [],
            "type" : "string",
            "id" : "taxon_label",
            "indexed" : "true",
            "display_name" : "Taxon",
            "description" : "Derived from C13 + ncbi_taxonomy.obo.",
            "required" : "false",
            "cardinality" : "single"
         },
         "taxon" : {
            "id" : "taxon",
            "indexed" : "true",
            "property" : [],
            "transform" : [],
            "searchable" : "false",
            "type" : "string",
            "required" : "false",
            "cardinality" : "single",
            "description" : "Column 13: taxon.",
            "display_name" : "Taxon"
         },
         "annotation_class" : {
            "display_name" : "Annotation class",
            "description" : "Column 5.",
            "cardinality" : "single",
            "required" : "false",
            "type" : "string",
            "searchable" : "false",
            "property" : [],
            "transform" : [],
            "indexed" : "true",
            "id" : "annotation_class"
         }
      },
      "display_name" : "Advanced",
      "description" : "A description of annotation evidence aggregate for GOlr and AmiGO.",
      "_strict" : 0,
      "searchable_extension" : "_searchable",
      "_infile" : "/home/sjcarbon/local/src/git/amigo/metadata/ann_ev_agg-config.yaml",
      "result_weights" : "bioentity^4.0 annotation_class^3.0 taxon^2.0",
      "boost_weights" : "annotation_class^2.0 annotation_class_label^1.0 bioentity^2.0 bioentity_label^1.0 panther_family^1.0 panther_family_label^1.0 taxon_closure_label^1.0"
   },
   "family" : {
      "description" : "Information about protein (PANTHER) families.",
      "_strict" : 0,
      "searchable_extension" : "_searchable",
      "_infile" : "/home/sjcarbon/local/src/git/amigo/metadata/protein-family-config.yaml",
      "display_name" : "Protein families",
      "result_weights" : "panther_family^5.0 bioentity_list^4.0",
      "boost_weights" : "panther_family^2.0 panther_family_label^2.0 bioentity_list^1.0 bioentity_list_label^1.0",
      "filter_weights" : "bioentity_list_label^1.0",
      "id" : "family",
      "fields" : [
         {
            "required" : "false",
            "cardinality" : "single",
            "description" : "Family ID.",
            "display_name" : "Acc",
            "id" : "id",
            "indexed" : "true",
            "property" : [],
            "searchable" : "false",
            "transform" : [],
            "type" : "string"
         },
         {
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "true",
            "indexed" : "true",
            "id" : "panther_family",
            "display_name" : "PANTHER family",
            "description" : "PANTHER family IDs that are associated with this entity.",
            "cardinality" : "single",
            "required" : "false"
         },
         {
            "searchable" : "true",
            "transform" : [],
            "property" : [],
            "type" : "string",
            "id" : "panther_family_label",
            "indexed" : "true",
            "display_name" : "PANTHER family",
            "description" : "PANTHER families that are associated with this entity.",
            "required" : "false",
            "cardinality" : "single"
         },
         {
            "type" : "string",
            "transform" : [],
            "searchable" : "false",
            "property" : [],
            "indexed" : "false",
            "id" : "phylo_graph_json",
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "This should not be displayed",
            "description" : "JSON blob form of the phylogenic tree."
         },
         {
            "cardinality" : "multi",
            "required" : "false",
            "display_name" : "Gene/products",
            "description" : "Gene/products annotated with this protein family.",
            "type" : "string",
            "transform" : [],
            "searchable" : "false",
            "property" : [],
            "indexed" : "true",
            "id" : "bioentity_list"
         },
         {
            "id" : "bioentity_list_label",
            "indexed" : "true",
            "property" : [],
            "transform" : [],
            "searchable" : "false",
            "type" : "string",
            "required" : "false",
            "cardinality" : "multi",
            "description" : "Gene/products annotated with this protein family.",
            "display_name" : "Gene/products"
         }
      ],
      "schema_generating" : "true",
      "document_category" : "family",
      "_outfile" : "/home/sjcarbon/local/src/git/amigo/metadata/protein-family-config.yaml",
      "weight" : "5",
      "fields_hash" : {
         "id" : {
            "required" : "false",
            "cardinality" : "single",
            "description" : "Family ID.",
            "display_name" : "Acc",
            "id" : "id",
            "indexed" : "true",
            "property" : [],
            "searchable" : "false",
            "transform" : [],
            "type" : "string"
         },
         "panther_family" : {
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "true",
            "indexed" : "true",
            "id" : "panther_family",
            "display_name" : "PANTHER family",
            "description" : "PANTHER family IDs that are associated with this entity.",
            "cardinality" : "single",
            "required" : "false"
         },
         "panther_family_label" : {
            "searchable" : "true",
            "transform" : [],
            "property" : [],
            "type" : "string",
            "id" : "panther_family_label",
            "indexed" : "true",
            "display_name" : "PANTHER family",
            "description" : "PANTHER families that are associated with this entity.",
            "required" : "false",
            "cardinality" : "single"
         },
         "bioentity_list" : {
            "cardinality" : "multi",
            "required" : "false",
            "display_name" : "Gene/products",
            "description" : "Gene/products annotated with this protein family.",
            "type" : "string",
            "transform" : [],
            "searchable" : "false",
            "property" : [],
            "indexed" : "true",
            "id" : "bioentity_list"
         },
         "bioentity_list_label" : {
            "id" : "bioentity_list_label",
            "indexed" : "true",
            "property" : [],
            "transform" : [],
            "searchable" : "false",
            "type" : "string",
            "required" : "false",
            "cardinality" : "multi",
            "description" : "Gene/products annotated with this protein family.",
            "display_name" : "Gene/products"
         },
         "phylo_graph_json" : {
            "type" : "string",
            "transform" : [],
            "searchable" : "false",
            "property" : [],
            "indexed" : "false",
            "id" : "phylo_graph_json",
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "This should not be displayed",
            "description" : "JSON blob form of the phylogenic tree."
         }
      }
   },
   "annotation" : {
      "_outfile" : "/home/sjcarbon/local/src/git/amigo/metadata/ann-config.yaml",
      "weight" : "20",
      "fields_hash" : {
         "annotation_class_label" : {
            "indexed" : "true",
            "id" : "annotation_class_label",
            "type" : "string",
            "searchable" : "true",
            "property" : [],
            "transform" : [],
            "description" : "Direct annotations.",
            "display_name" : "Direct annotation",
            "cardinality" : "single",
            "required" : "false"
         },
         "is_redundant_for" : {
            "searchable" : "false",
            "transform" : [],
            "property" : [],
            "type" : "string",
            "id" : "is_redundant_for",
            "indexed" : "true",
            "required" : "false",
            "cardinality" : "single",
            "display_name" : "Redundant for",
            "description" : "Rational for redundancy of annotation."
         },
         "synonym" : {
            "searchable" : "false",
            "property" : [],
            "transform" : [],
            "type" : "string",
            "id" : "synonym",
            "indexed" : "true",
            "required" : "false",
            "cardinality" : "multi",
            "display_name" : "Synonym",
            "description" : "Gene or gene product synonyms."
         },
         "reference" : {
            "id" : "reference",
            "indexed" : "true",
            "searchable" : "false",
            "property" : [],
            "transform" : [],
            "type" : "string",
            "required" : "false",
            "cardinality" : "multi",
            "description" : "Database reference.",
            "display_name" : "Reference"
         },
         "bioentity" : {
            "id" : "bioentity",
            "indexed" : "true",
            "transform" : [],
            "searchable" : "false",
            "property" : [],
            "type" : "string",
            "required" : "false",
            "cardinality" : "single",
            "description" : "Gene or gene product identifiers.",
            "display_name" : "Gene/product"
         },
         "annotation_extension_class_closure_label" : {
            "description" : "Extension class for the annotation.",
            "display_name" : "Annotation extension",
            "required" : "false",
            "cardinality" : "multi",
            "id" : "annotation_extension_class_closure_label",
            "indexed" : "true",
            "property" : [],
            "transform" : [],
            "searchable" : "true",
            "type" : "string"
         },
         "taxon_closure" : {
            "display_name" : "Taxon",
            "description" : "Taxonomic group and ancestral groups.",
            "cardinality" : "multi",
            "required" : "false",
            "type" : "string",
            "property" : [],
            "searchable" : "false",
            "transform" : [],
            "indexed" : "true",
            "id" : "taxon_closure"
         },
         "bioentity_internal_id" : {
            "display_name" : "This should not be displayed",
            "description" : "The bioentity ID used at the database of origin.",
            "required" : "false",
            "cardinality" : "single",
            "transform" : [],
            "searchable" : "false",
            "property" : [],
            "type" : "string",
            "id" : "bioentity_internal_id",
            "indexed" : "false"
         },
         "taxon_closure_label" : {
            "display_name" : "Taxon",
            "description" : "Taxonomic group and ancestral groups.",
            "cardinality" : "multi",
            "required" : "false",
            "type" : "string",
            "property" : [],
            "transform" : [],
            "searchable" : "true",
            "indexed" : "true",
            "id" : "taxon_closure_label"
         },
         "taxon" : {
            "display_name" : "Taxon",
            "description" : "Taxonomic group.",
            "required" : "false",
            "cardinality" : "single",
            "transform" : [],
            "property" : [],
            "searchable" : "false",
            "type" : "string",
            "id" : "taxon",
            "indexed" : "true"
         },
         "secondary_taxon_closure" : {
            "id" : "secondary_taxon_closure",
            "indexed" : "true",
            "searchable" : "false",
            "property" : [],
            "transform" : [],
            "type" : "string",
            "required" : "false",
            "cardinality" : "multi",
            "description" : "Secondary taxon closure.",
            "display_name" : "Secondary taxon"
         },
         "annotation_class" : {
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "false",
            "indexed" : "true",
            "id" : "annotation_class",
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "Direct annotation",
            "description" : "Direct annotations."
         },
         "bioentity_isoform" : {
            "indexed" : "true",
            "id" : "bioentity_isoform",
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "false",
            "description" : "Biological isoform.",
            "display_name" : "Isoform",
            "cardinality" : "single",
            "required" : "false"
         },
         "regulates_closure" : {
            "description" : "Annotations for this term or its children (over regulates).",
            "display_name" : "Inferred annotation",
            "cardinality" : "multi",
            "required" : "false",
            "indexed" : "true",
            "id" : "regulates_closure",
            "type" : "string",
            "property" : [],
            "searchable" : "false",
            "transform" : []
         },
         "annotation_extension_class" : {
            "id" : "annotation_extension_class",
            "indexed" : "true",
            "property" : [],
            "searchable" : "false",
            "transform" : [],
            "type" : "string",
            "description" : "Extension class for the annotation.",
            "display_name" : "Annotation extension",
            "required" : "false",
            "cardinality" : "multi"
         },
         "has_participant_closure" : {
            "description" : "Closure of ids/accs over has_participant.",
            "display_name" : "Has participant (IDs)",
            "required" : "false",
            "cardinality" : "multi",
            "id" : "has_participant_closure",
            "indexed" : "true",
            "property" : [],
            "transform" : [],
            "searchable" : "false",
            "type" : "string"
         },
         "has_participant_closure_label" : {
            "indexed" : "true",
            "id" : "has_participant_closure_label",
            "type" : "string",
            "property" : [],
            "searchable" : "true",
            "transform" : [],
            "description" : "Closure of labels over has_participant.",
            "display_name" : "Has participant",
            "cardinality" : "multi",
            "required" : "false"
         },
         "isa_partof_closure_label" : {
            "id" : "isa_partof_closure_label",
            "indexed" : "true",
            "property" : [],
            "searchable" : "true",
            "transform" : [],
            "type" : "string",
            "required" : "false",
            "cardinality" : "multi",
            "description" : "Annotations for this term or its children (over is_a/part_of).",
            "display_name" : "Involved in"
         },
         "qualifier" : {
            "type" : "string",
            "searchable" : "false",
            "transform" : [],
            "property" : [],
            "indexed" : "true",
            "id" : "qualifier",
            "cardinality" : "multi",
            "required" : "false",
            "display_name" : "Qualifier",
            "description" : "Annotation qualifier."
         },
         "annotation_extension_class_label" : {
            "cardinality" : "multi",
            "required" : "false",
            "display_name" : "Annotation extension",
            "description" : "Extension class for the annotation.",
            "type" : "string",
            "searchable" : "true",
            "property" : [],
            "transform" : [],
            "indexed" : "true",
            "id" : "annotation_extension_class_label"
         },
         "panther_family_label" : {
            "type" : "string",
            "property" : [],
            "searchable" : "true",
            "transform" : [],
            "indexed" : "true",
            "id" : "panther_family_label",
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "PANTHER family",
            "description" : "PANTHER families that are associated with this entity."
         },
         "taxon_label" : {
            "type" : "string",
            "transform" : [],
            "searchable" : "true",
            "property" : [],
            "indexed" : "true",
            "id" : "taxon_label",
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "Taxon",
            "description" : "Taxonomic group and ancestral groups."
         },
         "evidence_type" : {
            "required" : "false",
            "cardinality" : "single",
            "display_name" : "Evidence",
            "description" : "Evidence type.",
            "property" : [],
            "transform" : [],
            "searchable" : "false",
            "type" : "string",
            "id" : "evidence_type",
            "indexed" : "true"
         },
         "panther_family" : {
            "type" : "string",
            "transform" : [],
            "searchable" : "true",
            "property" : [],
            "indexed" : "true",
            "id" : "panther_family",
            "display_name" : "PANTHER family",
            "description" : "PANTHER families that are associated with this entity.",
            "cardinality" : "single",
            "required" : "false"
         },
         "evidence_with" : {
            "display_name" : "Evidence with",
            "description" : "Evidence with/from.",
            "required" : "false",
            "cardinality" : "multi",
            "transform" : [],
            "searchable" : "false",
            "property" : [],
            "type" : "string",
            "id" : "evidence_with",
            "indexed" : "true"
         },
         "evidence_type_closure" : {
            "display_name" : "Evidence type",
            "description" : "All evidence (evidence closure) for this annotation",
            "required" : "false",
            "cardinality" : "multi",
            "searchable" : "false",
            "property" : [],
            "transform" : [],
            "type" : "string",
            "id" : "evidence_type_closure",
            "indexed" : "true"
         },
         "id" : {
            "required" : "false",
            "cardinality" : "single",
            "display_name" : "Acc",
            "description" : "A unique (and internal) combination of bioentity and ontology class.",
            "property" : [],
            "searchable" : "false",
            "transform" : [],
            "type" : "string",
            "id" : "id",
            "indexed" : "true"
         },
         "type" : {
            "type" : "string",
            "property" : [],
            "searchable" : "false",
            "transform" : [],
            "indexed" : "true",
            "id" : "type",
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "Type class id",
            "description" : "Type class."
         },
         "isa_partof_closure" : {
            "id" : "isa_partof_closure",
            "indexed" : "true",
            "searchable" : "false",
            "property" : [],
            "transform" : [],
            "type" : "string",
            "description" : "Annotations for this term or its children (over is_a/part_of).",
            "display_name" : "Involved in",
            "required" : "false",
            "cardinality" : "multi"
         },
         "secondary_taxon" : {
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "Secondary taxon",
            "description" : "Secondary taxon.",
            "type" : "string",
            "transform" : [],
            "searchable" : "false",
            "property" : [],
            "indexed" : "true",
            "id" : "secondary_taxon"
         },
         "date" : {
            "transform" : [],
            "searchable" : "false",
            "property" : [],
            "type" : "string",
            "id" : "date",
            "indexed" : "true",
            "required" : "false",
            "cardinality" : "single",
            "display_name" : "Date",
            "description" : "Date of assignment."
         },
         "bioentity_label" : {
            "display_name" : "Gene/product",
            "description" : "Gene or gene product identifiers.",
            "cardinality" : "single",
            "required" : "false",
            "type" : "string",
            "property" : [],
            "transform" : [],
            "searchable" : "true",
            "indexed" : "true",
            "id" : "bioentity_label"
         },
         "annotation_extension_json" : {
            "cardinality" : "multi",
            "required" : "false",
            "description" : "Extension class for the annotation (JSON).",
            "display_name" : "Annotation extension",
            "indexed" : "true",
            "id" : "annotation_extension_json",
            "type" : "string",
            "transform" : [],
            "searchable" : "false",
            "property" : []
         },
         "assigned_by" : {
            "description" : "Annotations assigned by group.",
            "display_name" : "Assigned by",
            "required" : "false",
            "cardinality" : "single",
            "id" : "assigned_by",
            "indexed" : "true",
            "property" : [],
            "searchable" : "false",
            "transform" : [],
            "type" : "string"
         },
         "aspect" : {
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "Ontology (aspect)",
            "description" : "Ontology aspect.",
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "false",
            "indexed" : "true",
            "id" : "aspect"
         },
         "annotation_extension_class_closure" : {
            "display_name" : "Annotation extension",
            "description" : "Extension class for the annotation.",
            "cardinality" : "multi",
            "required" : "false",
            "type" : "string",
            "searchable" : "false",
            "transform" : [],
            "property" : [],
            "indexed" : "true",
            "id" : "annotation_extension_class_closure"
         },
         "regulates_closure_label" : {
            "required" : "false",
            "cardinality" : "multi",
            "display_name" : "Inferred annotation",
            "description" : "Annotations for this term or its children (over regulates).",
            "transform" : [],
            "searchable" : "true",
            "property" : [],
            "type" : "string",
            "id" : "regulates_closure_label",
            "indexed" : "true"
         },
         "secondary_taxon_closure_label" : {
            "required" : "false",
            "cardinality" : "multi",
            "display_name" : "Secondary taxon",
            "description" : "Secondary taxon closure.",
            "transform" : [],
            "searchable" : "true",
            "property" : [],
            "type" : "string",
            "id" : "secondary_taxon_closure_label",
            "indexed" : "true"
         },
         "source" : {
            "description" : "Database source.",
            "display_name" : "Source",
            "required" : "false",
            "cardinality" : "single",
            "id" : "source",
            "indexed" : "true",
            "transform" : [],
            "searchable" : "false",
            "property" : [],
            "type" : "string"
         },
         "secondary_taxon_label" : {
            "required" : "false",
            "cardinality" : "single",
            "description" : "Secondary taxon.",
            "display_name" : "Secondary taxon",
            "id" : "secondary_taxon_label",
            "indexed" : "true",
            "transform" : [],
            "property" : [],
            "searchable" : "true",
            "type" : "string"
         },
         "bioentity_name" : {
            "required" : "false",
            "cardinality" : "single",
            "description" : "The full name of the gene or gene product.",
            "display_name" : "Gene/product name",
            "id" : "bioentity_name",
            "indexed" : "true",
            "transform" : [],
            "searchable" : "true",
            "property" : [],
            "type" : "string"
         }
      },
      "filter_weights" : "source^7.0 assigned_by^6.5 aspect^6.25 evidence_type_closure^6.0 panther_family_label^5.5 qualifier^5.25 taxon_closure_label^5.0 annotation_class_label^4.5 regulates_closure_label^3.0 annotation_extension_class_closure_label^2.0",
      "id" : "annotation",
      "schema_generating" : "true",
      "fields" : [
         {
            "required" : "false",
            "cardinality" : "single",
            "display_name" : "Acc",
            "description" : "A unique (and internal) combination of bioentity and ontology class.",
            "property" : [],
            "searchable" : "false",
            "transform" : [],
            "type" : "string",
            "id" : "id",
            "indexed" : "true"
         },
         {
            "description" : "Database source.",
            "display_name" : "Source",
            "required" : "false",
            "cardinality" : "single",
            "id" : "source",
            "indexed" : "true",
            "transform" : [],
            "searchable" : "false",
            "property" : [],
            "type" : "string"
         },
         {
            "type" : "string",
            "property" : [],
            "searchable" : "false",
            "transform" : [],
            "indexed" : "true",
            "id" : "type",
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "Type class id",
            "description" : "Type class."
         },
         {
            "transform" : [],
            "searchable" : "false",
            "property" : [],
            "type" : "string",
            "id" : "date",
            "indexed" : "true",
            "required" : "false",
            "cardinality" : "single",
            "display_name" : "Date",
            "description" : "Date of assignment."
         },
         {
            "description" : "Annotations assigned by group.",
            "display_name" : "Assigned by",
            "required" : "false",
            "cardinality" : "single",
            "id" : "assigned_by",
            "indexed" : "true",
            "property" : [],
            "searchable" : "false",
            "transform" : [],
            "type" : "string"
         },
         {
            "searchable" : "false",
            "transform" : [],
            "property" : [],
            "type" : "string",
            "id" : "is_redundant_for",
            "indexed" : "true",
            "required" : "false",
            "cardinality" : "single",
            "display_name" : "Redundant for",
            "description" : "Rational for redundancy of annotation."
         },
         {
            "display_name" : "Taxon",
            "description" : "Taxonomic group.",
            "required" : "false",
            "cardinality" : "single",
            "transform" : [],
            "property" : [],
            "searchable" : "false",
            "type" : "string",
            "id" : "taxon",
            "indexed" : "true"
         },
         {
            "type" : "string",
            "transform" : [],
            "searchable" : "true",
            "property" : [],
            "indexed" : "true",
            "id" : "taxon_label",
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "Taxon",
            "description" : "Taxonomic group and ancestral groups."
         },
         {
            "display_name" : "Taxon",
            "description" : "Taxonomic group and ancestral groups.",
            "cardinality" : "multi",
            "required" : "false",
            "type" : "string",
            "property" : [],
            "searchable" : "false",
            "transform" : [],
            "indexed" : "true",
            "id" : "taxon_closure"
         },
         {
            "display_name" : "Taxon",
            "description" : "Taxonomic group and ancestral groups.",
            "cardinality" : "multi",
            "required" : "false",
            "type" : "string",
            "property" : [],
            "transform" : [],
            "searchable" : "true",
            "indexed" : "true",
            "id" : "taxon_closure_label"
         },
         {
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "Secondary taxon",
            "description" : "Secondary taxon.",
            "type" : "string",
            "transform" : [],
            "searchable" : "false",
            "property" : [],
            "indexed" : "true",
            "id" : "secondary_taxon"
         },
         {
            "required" : "false",
            "cardinality" : "single",
            "description" : "Secondary taxon.",
            "display_name" : "Secondary taxon",
            "id" : "secondary_taxon_label",
            "indexed" : "true",
            "transform" : [],
            "property" : [],
            "searchable" : "true",
            "type" : "string"
         },
         {
            "id" : "secondary_taxon_closure",
            "indexed" : "true",
            "searchable" : "false",
            "property" : [],
            "transform" : [],
            "type" : "string",
            "required" : "false",
            "cardinality" : "multi",
            "description" : "Secondary taxon closure.",
            "display_name" : "Secondary taxon"
         },
         {
            "required" : "false",
            "cardinality" : "multi",
            "display_name" : "Secondary taxon",
            "description" : "Secondary taxon closure.",
            "transform" : [],
            "searchable" : "true",
            "property" : [],
            "type" : "string",
            "id" : "secondary_taxon_closure_label",
            "indexed" : "true"
         },
         {
            "id" : "isa_partof_closure",
            "indexed" : "true",
            "searchable" : "false",
            "property" : [],
            "transform" : [],
            "type" : "string",
            "description" : "Annotations for this term or its children (over is_a/part_of).",
            "display_name" : "Involved in",
            "required" : "false",
            "cardinality" : "multi"
         },
         {
            "id" : "isa_partof_closure_label",
            "indexed" : "true",
            "property" : [],
            "searchable" : "true",
            "transform" : [],
            "type" : "string",
            "required" : "false",
            "cardinality" : "multi",
            "description" : "Annotations for this term or its children (over is_a/part_of).",
            "display_name" : "Involved in"
         },
         {
            "description" : "Annotations for this term or its children (over regulates).",
            "display_name" : "Inferred annotation",
            "cardinality" : "multi",
            "required" : "false",
            "indexed" : "true",
            "id" : "regulates_closure",
            "type" : "string",
            "property" : [],
            "searchable" : "false",
            "transform" : []
         },
         {
            "required" : "false",
            "cardinality" : "multi",
            "display_name" : "Inferred annotation",
            "description" : "Annotations for this term or its children (over regulates).",
            "transform" : [],
            "searchable" : "true",
            "property" : [],
            "type" : "string",
            "id" : "regulates_closure_label",
            "indexed" : "true"
         },
         {
            "description" : "Closure of ids/accs over has_participant.",
            "display_name" : "Has participant (IDs)",
            "required" : "false",
            "cardinality" : "multi",
            "id" : "has_participant_closure",
            "indexed" : "true",
            "property" : [],
            "transform" : [],
            "searchable" : "false",
            "type" : "string"
         },
         {
            "indexed" : "true",
            "id" : "has_participant_closure_label",
            "type" : "string",
            "property" : [],
            "searchable" : "true",
            "transform" : [],
            "description" : "Closure of labels over has_participant.",
            "display_name" : "Has participant",
            "cardinality" : "multi",
            "required" : "false"
         },
         {
            "searchable" : "false",
            "property" : [],
            "transform" : [],
            "type" : "string",
            "id" : "synonym",
            "indexed" : "true",
            "required" : "false",
            "cardinality" : "multi",
            "display_name" : "Synonym",
            "description" : "Gene or gene product synonyms."
         },
         {
            "id" : "bioentity",
            "indexed" : "true",
            "transform" : [],
            "searchable" : "false",
            "property" : [],
            "type" : "string",
            "required" : "false",
            "cardinality" : "single",
            "description" : "Gene or gene product identifiers.",
            "display_name" : "Gene/product"
         },
         {
            "display_name" : "Gene/product",
            "description" : "Gene or gene product identifiers.",
            "cardinality" : "single",
            "required" : "false",
            "type" : "string",
            "property" : [],
            "transform" : [],
            "searchable" : "true",
            "indexed" : "true",
            "id" : "bioentity_label"
         },
         {
            "required" : "false",
            "cardinality" : "single",
            "description" : "The full name of the gene or gene product.",
            "display_name" : "Gene/product name",
            "id" : "bioentity_name",
            "indexed" : "true",
            "transform" : [],
            "searchable" : "true",
            "property" : [],
            "type" : "string"
         },
         {
            "display_name" : "This should not be displayed",
            "description" : "The bioentity ID used at the database of origin.",
            "required" : "false",
            "cardinality" : "single",
            "transform" : [],
            "searchable" : "false",
            "property" : [],
            "type" : "string",
            "id" : "bioentity_internal_id",
            "indexed" : "false"
         },
         {
            "type" : "string",
            "searchable" : "false",
            "transform" : [],
            "property" : [],
            "indexed" : "true",
            "id" : "qualifier",
            "cardinality" : "multi",
            "required" : "false",
            "display_name" : "Qualifier",
            "description" : "Annotation qualifier."
         },
         {
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "false",
            "indexed" : "true",
            "id" : "annotation_class",
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "Direct annotation",
            "description" : "Direct annotations."
         },
         {
            "indexed" : "true",
            "id" : "annotation_class_label",
            "type" : "string",
            "searchable" : "true",
            "property" : [],
            "transform" : [],
            "description" : "Direct annotations.",
            "display_name" : "Direct annotation",
            "cardinality" : "single",
            "required" : "false"
         },
         {
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "Ontology (aspect)",
            "description" : "Ontology aspect.",
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "false",
            "indexed" : "true",
            "id" : "aspect"
         },
         {
            "indexed" : "true",
            "id" : "bioentity_isoform",
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "false",
            "description" : "Biological isoform.",
            "display_name" : "Isoform",
            "cardinality" : "single",
            "required" : "false"
         },
         {
            "required" : "false",
            "cardinality" : "single",
            "display_name" : "Evidence",
            "description" : "Evidence type.",
            "property" : [],
            "transform" : [],
            "searchable" : "false",
            "type" : "string",
            "id" : "evidence_type",
            "indexed" : "true"
         },
         {
            "display_name" : "Evidence type",
            "description" : "All evidence (evidence closure) for this annotation",
            "required" : "false",
            "cardinality" : "multi",
            "searchable" : "false",
            "property" : [],
            "transform" : [],
            "type" : "string",
            "id" : "evidence_type_closure",
            "indexed" : "true"
         },
         {
            "display_name" : "Evidence with",
            "description" : "Evidence with/from.",
            "required" : "false",
            "cardinality" : "multi",
            "transform" : [],
            "searchable" : "false",
            "property" : [],
            "type" : "string",
            "id" : "evidence_with",
            "indexed" : "true"
         },
         {
            "id" : "reference",
            "indexed" : "true",
            "searchable" : "false",
            "property" : [],
            "transform" : [],
            "type" : "string",
            "required" : "false",
            "cardinality" : "multi",
            "description" : "Database reference.",
            "display_name" : "Reference"
         },
         {
            "id" : "annotation_extension_class",
            "indexed" : "true",
            "property" : [],
            "searchable" : "false",
            "transform" : [],
            "type" : "string",
            "description" : "Extension class for the annotation.",
            "display_name" : "Annotation extension",
            "required" : "false",
            "cardinality" : "multi"
         },
         {
            "cardinality" : "multi",
            "required" : "false",
            "display_name" : "Annotation extension",
            "description" : "Extension class for the annotation.",
            "type" : "string",
            "searchable" : "true",
            "property" : [],
            "transform" : [],
            "indexed" : "true",
            "id" : "annotation_extension_class_label"
         },
         {
            "display_name" : "Annotation extension",
            "description" : "Extension class for the annotation.",
            "cardinality" : "multi",
            "required" : "false",
            "type" : "string",
            "searchable" : "false",
            "transform" : [],
            "property" : [],
            "indexed" : "true",
            "id" : "annotation_extension_class_closure"
         },
         {
            "description" : "Extension class for the annotation.",
            "display_name" : "Annotation extension",
            "required" : "false",
            "cardinality" : "multi",
            "id" : "annotation_extension_class_closure_label",
            "indexed" : "true",
            "property" : [],
            "transform" : [],
            "searchable" : "true",
            "type" : "string"
         },
         {
            "cardinality" : "multi",
            "required" : "false",
            "description" : "Extension class for the annotation (JSON).",
            "display_name" : "Annotation extension",
            "indexed" : "true",
            "id" : "annotation_extension_json",
            "type" : "string",
            "transform" : [],
            "searchable" : "false",
            "property" : []
         },
         {
            "type" : "string",
            "transform" : [],
            "searchable" : "true",
            "property" : [],
            "indexed" : "true",
            "id" : "panther_family",
            "display_name" : "PANTHER family",
            "description" : "PANTHER families that are associated with this entity.",
            "cardinality" : "single",
            "required" : "false"
         },
         {
            "type" : "string",
            "property" : [],
            "searchable" : "true",
            "transform" : [],
            "indexed" : "true",
            "id" : "panther_family_label",
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "PANTHER family",
            "description" : "PANTHER families that are associated with this entity."
         }
      ],
      "document_category" : "annotation",
      "result_weights" : "bioentity^7.0 bioentity_name^6.0 qualifier^5.0 annotation_class^4.7 annotation_extension_json^4.5 assigned_by^4.0 taxon^3.0 evidence_type^2.5 evidence_with^2.0 panther_family^1.5 bioentity_isoform^0.5 reference^0.25 date^0.10",
      "boost_weights" : "annotation_class^2.0 annotation_class_label^1.0 bioentity^2.0 bioentity_label^1.0 bioentity_name^1.0 annotation_extension_class^2.0 annotation_extension_class_label^1.0 reference^1.0 panther_family^1.0 panther_family_label^1.0 bioentity_isoform^1.0 regulates_closure^1.0 regulates_closure_label^1.0",
      "searchable_extension" : "_searchable",
      "description" : "Associations between GO terms and genes or gene products.",
      "_strict" : 0,
      "_infile" : "/home/sjcarbon/local/src/git/amigo/metadata/ann-config.yaml",
      "display_name" : "Annotations"
   },
   "ontology" : {
      "_infile" : "/home/sjcarbon/local/src/git/amigo/metadata/ont-config.yaml",
      "description" : "Gene Ontology Term, Synonym, or Definition.",
      "_strict" : 0,
      "searchable_extension" : "_searchable",
      "display_name" : "Ontology",
      "boost_weights" : "annotation_class^3.0 annotation_class_label^5.5 description^1.0 comment^0.5 synonym^1.0 alternate_id^1.0 regulates_closure^1.0 regulates_closure_label^1.0",
      "result_weights" : "annotation_class^8.0 description^6.0 source^4.0 synonym^3.0 alternate_id^2.0",
      "filter_weights" : "source^4.0 subset^3.0 regulates_closure_label^1.0 is_obsolete^0.0",
      "id" : "ontology",
      "schema_generating" : "true",
      "fields" : [
         {
            "display_name" : "Acc",
            "description" : "Term identifier.",
            "cardinality" : "single",
            "required" : "false",
            "type" : "string",
            "property" : [
               "getIdentifier"
            ],
            "transform" : [],
            "searchable" : "false",
            "indexed" : "true",
            "id" : "id"
         },
         {
            "searchable" : "false",
            "transform" : [],
            "property" : [
               "getIdentifier"
            ],
            "type" : "string",
            "id" : "annotation_class",
            "indexed" : "true",
            "required" : "false",
            "cardinality" : "single",
            "display_name" : "Term",
            "description" : "Term identifier."
         },
         {
            "required" : "false",
            "cardinality" : "single",
            "display_name" : "Term",
            "description" : "Identifier.",
            "property" : [
               "getLabel"
            ],
            "transform" : [],
            "searchable" : "true",
            "type" : "string",
            "id" : "annotation_class_label",
            "indexed" : "true"
         },
         {
            "searchable" : "true",
            "property" : [
               "getDef"
            ],
            "transform" : [],
            "type" : "string",
            "id" : "description",
            "indexed" : "true",
            "required" : "false",
            "cardinality" : "single",
            "display_name" : "Definition",
            "description" : "Term definition."
         },
         {
            "indexed" : "true",
            "id" : "source",
            "type" : "string",
            "transform" : [],
            "searchable" : "false",
            "property" : [
               "getNamespace"
            ],
            "cardinality" : "single",
            "required" : "false",
            "description" : "Term namespace.",
            "display_name" : "Ontology source"
         },
         {
            "display_name" : "Obsoletion",
            "description" : "Is the term obsolete?",
            "cardinality" : "single",
            "required" : "false",
            "type" : "boolean",
            "property" : [
               "getIsObsoleteBinaryString"
            ],
            "transform" : [],
            "searchable" : "false",
            "indexed" : "true",
            "id" : "is_obsolete"
         },
         {
            "indexed" : "true",
            "id" : "comment",
            "type" : "string",
            "property" : [
               "getComment"
            ],
            "transform" : [],
            "searchable" : "true",
            "description" : "Term comment.",
            "display_name" : "Comment",
            "cardinality" : "single",
            "required" : "false"
         },
         {
            "type" : "string",
            "property" : [
               "getOBOSynonymStrings"
            ],
            "searchable" : "true",
            "transform" : [],
            "indexed" : "true",
            "id" : "synonym",
            "cardinality" : "multi",
            "required" : "false",
            "display_name" : "Synonyms",
            "description" : "Term synonyms."
         },
         {
            "id" : "alternate_id",
            "indexed" : "true",
            "transform" : [],
            "searchable" : "false",
            "property" : [
               "getAnnotationPropertyValues",
               "alt_id"
            ],
            "type" : "string",
            "description" : "Alternate term identifier.",
            "display_name" : "Alt ID",
            "required" : "false",
            "cardinality" : "multi"
         },
         {
            "required" : "false",
            "cardinality" : "multi",
            "description" : "Term that replaces this term.",
            "display_name" : "Replaced By",
            "id" : "replaced_by",
            "indexed" : "true",
            "transform" : [],
            "searchable" : "false",
            "property" : [
               "getAnnotationPropertyValues",
               "replaced_by"
            ],
            "type" : "string"
         },
         {
            "required" : "false",
            "cardinality" : "multi",
            "description" : "Others terms you might want to look at.",
            "display_name" : "Consider",
            "id" : "consider",
            "indexed" : "true",
            "transform" : [],
            "property" : [
               "getAnnotationPropertyValues",
               "consider"
            ],
            "searchable" : "false",
            "type" : "string"
         },
         {
            "id" : "subset",
            "indexed" : "true",
            "property" : [
               "getSubsets"
            ],
            "transform" : [],
            "searchable" : "false",
            "type" : "string",
            "required" : "false",
            "cardinality" : "multi",
            "description" : "Special use collections of terms.",
            "display_name" : "Subset"
         },
         {
            "indexed" : "true",
            "id" : "definition_xref",
            "type" : "string",
            "transform" : [],
            "property" : [
               "getDefXref"
            ],
            "searchable" : "false",
            "description" : "Definition cross-reference.",
            "display_name" : "Def xref",
            "cardinality" : "multi",
            "required" : "false"
         },
         {
            "id" : "database_xref",
            "indexed" : "true",
            "transform" : [],
            "searchable" : "false",
            "property" : [
               "getXref"
            ],
            "type" : "string",
            "description" : "Database cross-reference.",
            "display_name" : "DB xref",
            "required" : "false",
            "cardinality" : "multi"
         },
         {
            "id" : "isa_partof_closure",
            "indexed" : "true",
            "transform" : [],
            "property" : [
               "getRelationIDClosure",
               "BFO:0000050"
            ],
            "searchable" : "false",
            "type" : "string",
            "required" : "false",
            "cardinality" : "multi",
            "description" : "Ancestral terms (is_a/part_of).",
            "display_name" : "Is-a/part-of"
         },
         {
            "property" : [
               "getRelationLabelClosure",
               "BFO:0000050"
            ],
            "searchable" : "true",
            "transform" : [],
            "type" : "string",
            "id" : "isa_partof_closure_label",
            "indexed" : "true",
            "display_name" : "Is-a/part-of",
            "description" : "Ancestral terms (is_a/part_of).",
            "required" : "false",
            "cardinality" : "multi"
         },
         {
            "searchable" : "false",
            "transform" : [],
            "property" : [
               "getRelationIDClosure",
               "BFO:0000050",
               "BFO:0000066",
               "RO:0002211",
               "RO:0002212",
               "RO:0002213",
               "RO:0002215",
               "RO:0002216"
            ],
            "type" : "string",
            "id" : "regulates_closure",
            "indexed" : "true",
            "display_name" : "Ancestor",
            "description" : "Ancestral terms (regulates, occurs in, capable_of).",
            "required" : "false",
            "cardinality" : "multi"
         },
         {
            "required" : "false",
            "cardinality" : "multi",
            "display_name" : "Ancestor",
            "description" : "Ancestral terms (regulates, occurs in, capable_of).",
            "property" : [
               "getRelationLabelClosure",
               "BFO:0000050",
               "BFO:0000066",
               "RO:0002211",
               "RO:0002212",
               "RO:0002213",
               "RO:0002215",
               "RO:0002216"
            ],
            "searchable" : "true",
            "transform" : [],
            "type" : "string",
            "id" : "regulates_closure_label",
            "indexed" : "true"
         },
         {
            "type" : "string",
            "property" : [
               "getSegmentShuntGraphJSON",
               "BFO:0000050",
               "BFO:0000066",
               "RO:0002211",
               "RO:0002212",
               "RO:0002213",
               "RO:0002215",
               "RO:0002216"
            ],
            "searchable" : "false",
            "transform" : [],
            "indexed" : "false",
            "id" : "topology_graph_json",
            "display_name" : "Topology graph (JSON)",
            "description" : "JSON blob form of the local stepwise topology graph. Uses various relations (including regulates, occurs in, capable_of).",
            "cardinality" : "single",
            "required" : "false"
         },
         {
            "type" : "string",
            "property" : [
               "getLineageShuntGraphJSON",
               "BFO:0000050",
               "BFO:0000066",
               "RO:0002211",
               "RO:0002212",
               "RO:0002213",
               "RO:0002215",
               "RO:0002216"
            ],
            "searchable" : "false",
            "transform" : [],
            "indexed" : "false",
            "id" : "regulates_transitivity_graph_json",
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "Regulates transitivity graph (JSON)",
            "description" : "JSON blob form of the local relation transitivity graph. Uses various relations (including regulates, occurs in, capable_of)."
         },
         {
            "type" : "string",
            "searchable" : "true",
            "property" : [
               "getIdentifier"
            ],
            "transform" : [],
            "indexed" : "true",
            "id" : "only_in_taxon",
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "Only in taxon",
            "description" : "Only in taxon."
         },
         {
            "description" : "Only in taxon label.",
            "display_name" : "Only in taxon",
            "cardinality" : "single",
            "required" : "false",
            "indexed" : "true",
            "id" : "only_in_taxon_label",
            "type" : "string",
            "property" : [
               "getLabel"
            ],
            "transform" : [],
            "searchable" : "true"
         },
         {
            "searchable" : "false",
            "transform" : [],
            "property" : [
               "getRelationLabelClosure",
               "RO:0002160"
            ],
            "type" : "string",
            "id" : "only_in_taxon_closure",
            "indexed" : "true",
            "required" : "false",
            "cardinality" : "multi",
            "display_name" : "Only in taxon (IDs)",
            "description" : "Only in taxon closure."
         },
         {
            "indexed" : "true",
            "id" : "only_in_taxon_closure_label",
            "type" : "string",
            "searchable" : "true",
            "property" : [
               "getRelationLabelClosure",
               "RO:0002160"
            ],
            "transform" : [],
            "description" : "Only in taxon label closure.",
            "display_name" : "Only in taxon",
            "cardinality" : "multi",
            "required" : "false"
         }
      ],
      "document_category" : "ontology_class",
      "fields_hash" : {
         "definition_xref" : {
            "indexed" : "true",
            "id" : "definition_xref",
            "type" : "string",
            "transform" : [],
            "property" : [
               "getDefXref"
            ],
            "searchable" : "false",
            "description" : "Definition cross-reference.",
            "display_name" : "Def xref",
            "cardinality" : "multi",
            "required" : "false"
         },
         "regulates_closure" : {
            "searchable" : "false",
            "transform" : [],
            "property" : [
               "getRelationIDClosure",
               "BFO:0000050",
               "BFO:0000066",
               "RO:0002211",
               "RO:0002212",
               "RO:0002213",
               "RO:0002215",
               "RO:0002216"
            ],
            "type" : "string",
            "id" : "regulates_closure",
            "indexed" : "true",
            "display_name" : "Ancestor",
            "description" : "Ancestral terms (regulates, occurs in, capable_of).",
            "required" : "false",
            "cardinality" : "multi"
         },
         "only_in_taxon" : {
            "type" : "string",
            "searchable" : "true",
            "property" : [
               "getIdentifier"
            ],
            "transform" : [],
            "indexed" : "true",
            "id" : "only_in_taxon",
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "Only in taxon",
            "description" : "Only in taxon."
         },
         "replaced_by" : {
            "required" : "false",
            "cardinality" : "multi",
            "description" : "Term that replaces this term.",
            "display_name" : "Replaced By",
            "id" : "replaced_by",
            "indexed" : "true",
            "transform" : [],
            "searchable" : "false",
            "property" : [
               "getAnnotationPropertyValues",
               "replaced_by"
            ],
            "type" : "string"
         },
         "only_in_taxon_label" : {
            "description" : "Only in taxon label.",
            "display_name" : "Only in taxon",
            "cardinality" : "single",
            "required" : "false",
            "indexed" : "true",
            "id" : "only_in_taxon_label",
            "type" : "string",
            "property" : [
               "getLabel"
            ],
            "transform" : [],
            "searchable" : "true"
         },
         "isa_partof_closure_label" : {
            "property" : [
               "getRelationLabelClosure",
               "BFO:0000050"
            ],
            "searchable" : "true",
            "transform" : [],
            "type" : "string",
            "id" : "isa_partof_closure_label",
            "indexed" : "true",
            "display_name" : "Is-a/part-of",
            "description" : "Ancestral terms (is_a/part_of).",
            "required" : "false",
            "cardinality" : "multi"
         },
         "alternate_id" : {
            "id" : "alternate_id",
            "indexed" : "true",
            "transform" : [],
            "searchable" : "false",
            "property" : [
               "getAnnotationPropertyValues",
               "alt_id"
            ],
            "type" : "string",
            "description" : "Alternate term identifier.",
            "display_name" : "Alt ID",
            "required" : "false",
            "cardinality" : "multi"
         },
         "regulates_closure_label" : {
            "required" : "false",
            "cardinality" : "multi",
            "display_name" : "Ancestor",
            "description" : "Ancestral terms (regulates, occurs in, capable_of).",
            "property" : [
               "getRelationLabelClosure",
               "BFO:0000050",
               "BFO:0000066",
               "RO:0002211",
               "RO:0002212",
               "RO:0002213",
               "RO:0002215",
               "RO:0002216"
            ],
            "searchable" : "true",
            "transform" : [],
            "type" : "string",
            "id" : "regulates_closure_label",
            "indexed" : "true"
         },
         "only_in_taxon_closure_label" : {
            "indexed" : "true",
            "id" : "only_in_taxon_closure_label",
            "type" : "string",
            "searchable" : "true",
            "property" : [
               "getRelationLabelClosure",
               "RO:0002160"
            ],
            "transform" : [],
            "description" : "Only in taxon label closure.",
            "display_name" : "Only in taxon",
            "cardinality" : "multi",
            "required" : "false"
         },
         "database_xref" : {
            "id" : "database_xref",
            "indexed" : "true",
            "transform" : [],
            "searchable" : "false",
            "property" : [
               "getXref"
            ],
            "type" : "string",
            "description" : "Database cross-reference.",
            "display_name" : "DB xref",
            "required" : "false",
            "cardinality" : "multi"
         },
         "only_in_taxon_closure" : {
            "searchable" : "false",
            "transform" : [],
            "property" : [
               "getRelationLabelClosure",
               "RO:0002160"
            ],
            "type" : "string",
            "id" : "only_in_taxon_closure",
            "indexed" : "true",
            "required" : "false",
            "cardinality" : "multi",
            "display_name" : "Only in taxon (IDs)",
            "description" : "Only in taxon closure."
         },
         "is_obsolete" : {
            "display_name" : "Obsoletion",
            "description" : "Is the term obsolete?",
            "cardinality" : "single",
            "required" : "false",
            "type" : "boolean",
            "property" : [
               "getIsObsoleteBinaryString"
            ],
            "transform" : [],
            "searchable" : "false",
            "indexed" : "true",
            "id" : "is_obsolete"
         },
         "topology_graph_json" : {
            "type" : "string",
            "property" : [
               "getSegmentShuntGraphJSON",
               "BFO:0000050",
               "BFO:0000066",
               "RO:0002211",
               "RO:0002212",
               "RO:0002213",
               "RO:0002215",
               "RO:0002216"
            ],
            "searchable" : "false",
            "transform" : [],
            "indexed" : "false",
            "id" : "topology_graph_json",
            "display_name" : "Topology graph (JSON)",
            "description" : "JSON blob form of the local stepwise topology graph. Uses various relations (including regulates, occurs in, capable_of).",
            "cardinality" : "single",
            "required" : "false"
         },
         "comment" : {
            "indexed" : "true",
            "id" : "comment",
            "type" : "string",
            "property" : [
               "getComment"
            ],
            "transform" : [],
            "searchable" : "true",
            "description" : "Term comment.",
            "display_name" : "Comment",
            "cardinality" : "single",
            "required" : "false"
         },
         "subset" : {
            "id" : "subset",
            "indexed" : "true",
            "property" : [
               "getSubsets"
            ],
            "transform" : [],
            "searchable" : "false",
            "type" : "string",
            "required" : "false",
            "cardinality" : "multi",
            "description" : "Special use collections of terms.",
            "display_name" : "Subset"
         },
         "source" : {
            "indexed" : "true",
            "id" : "source",
            "type" : "string",
            "transform" : [],
            "searchable" : "false",
            "property" : [
               "getNamespace"
            ],
            "cardinality" : "single",
            "required" : "false",
            "description" : "Term namespace.",
            "display_name" : "Ontology source"
         },
         "consider" : {
            "required" : "false",
            "cardinality" : "multi",
            "description" : "Others terms you might want to look at.",
            "display_name" : "Consider",
            "id" : "consider",
            "indexed" : "true",
            "transform" : [],
            "property" : [
               "getAnnotationPropertyValues",
               "consider"
            ],
            "searchable" : "false",
            "type" : "string"
         },
         "synonym" : {
            "type" : "string",
            "property" : [
               "getOBOSynonymStrings"
            ],
            "searchable" : "true",
            "transform" : [],
            "indexed" : "true",
            "id" : "synonym",
            "cardinality" : "multi",
            "required" : "false",
            "display_name" : "Synonyms",
            "description" : "Term synonyms."
         },
         "annotation_class_label" : {
            "required" : "false",
            "cardinality" : "single",
            "display_name" : "Term",
            "description" : "Identifier.",
            "property" : [
               "getLabel"
            ],
            "transform" : [],
            "searchable" : "true",
            "type" : "string",
            "id" : "annotation_class_label",
            "indexed" : "true"
         },
         "id" : {
            "display_name" : "Acc",
            "description" : "Term identifier.",
            "cardinality" : "single",
            "required" : "false",
            "type" : "string",
            "property" : [
               "getIdentifier"
            ],
            "transform" : [],
            "searchable" : "false",
            "indexed" : "true",
            "id" : "id"
         },
         "regulates_transitivity_graph_json" : {
            "type" : "string",
            "property" : [
               "getLineageShuntGraphJSON",
               "BFO:0000050",
               "BFO:0000066",
               "RO:0002211",
               "RO:0002212",
               "RO:0002213",
               "RO:0002215",
               "RO:0002216"
            ],
            "searchable" : "false",
            "transform" : [],
            "indexed" : "false",
            "id" : "regulates_transitivity_graph_json",
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "Regulates transitivity graph (JSON)",
            "description" : "JSON blob form of the local relation transitivity graph. Uses various relations (including regulates, occurs in, capable_of)."
         },
         "isa_partof_closure" : {
            "id" : "isa_partof_closure",
            "indexed" : "true",
            "transform" : [],
            "property" : [
               "getRelationIDClosure",
               "BFO:0000050"
            ],
            "searchable" : "false",
            "type" : "string",
            "required" : "false",
            "cardinality" : "multi",
            "description" : "Ancestral terms (is_a/part_of).",
            "display_name" : "Is-a/part-of"
         },
         "annotation_class" : {
            "searchable" : "false",
            "transform" : [],
            "property" : [
               "getIdentifier"
            ],
            "type" : "string",
            "id" : "annotation_class",
            "indexed" : "true",
            "required" : "false",
            "cardinality" : "single",
            "display_name" : "Term",
            "description" : "Term identifier."
         },
         "description" : {
            "searchable" : "true",
            "property" : [
               "getDef"
            ],
            "transform" : [],
            "type" : "string",
            "id" : "description",
            "indexed" : "true",
            "required" : "false",
            "cardinality" : "single",
            "display_name" : "Definition",
            "description" : "Term definition."
         }
      },
      "weight" : "40",
      "_outfile" : "/home/sjcarbon/local/src/git/amigo/metadata/ont-config.yaml"
   },
   "complex_annotation" : {
      "boost_weights" : "annotation_group_label^1.0 annotation_unit_label^1.0 enabled_by^1.0 enabled_by_label^1.0 location_list_closure^1.0 location_list_closure_label^1.0 process_class_closure_label^1.0 function_class_closure_label^1.0",
      "result_weights" : "function_class^5.0 enabled_by^4.0 location_list^3.0 process_class^2.0 annotation_group^1.0",
      "_infile" : "/home/sjcarbon/local/src/git/amigo/metadata/complex-ann-config.yaml",
      "description" : "An individual unit within LEGO. This is <strong>ALPHA</strong> software.",
      "searchable_extension" : "_searchable",
      "_strict" : 0,
      "display_name" : "Complex annotations (ALPHA)",
      "fields_hash" : {
         "annotation_group_url" : {
            "description" : "???.",
            "display_name" : "Annotation group URL",
            "required" : "false",
            "cardinality" : "single",
            "id" : "annotation_group_url",
            "indexed" : "true",
            "property" : [],
            "searchable" : "false",
            "transform" : [],
            "type" : "string"
         },
         "function_class_label" : {
            "cardinality" : "single",
            "required" : "false",
            "description" : "Common function name.",
            "display_name" : "Function",
            "indexed" : "true",
            "id" : "function_class_label",
            "type" : "string",
            "searchable" : "true",
            "transform" : [],
            "property" : []
         },
         "panther_family" : {
            "required" : "false",
            "cardinality" : "single",
            "display_name" : "PANTHER family",
            "description" : "PANTHER family IDs that are associated with this entity.",
            "searchable" : "true",
            "transform" : [],
            "property" : [],
            "type" : "string",
            "id" : "panther_family",
            "indexed" : "true"
         },
         "id" : {
            "display_name" : "ID",
            "description" : "A unique (and internal) thing.",
            "cardinality" : "single",
            "required" : "false",
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "false",
            "indexed" : "true",
            "id" : "id"
         },
         "taxon_closure" : {
            "required" : "false",
            "cardinality" : "multi",
            "display_name" : "Taxon (IDs)",
            "description" : "Taxon IDs derived from GAF column 13 and ncbi_taxonomy.obo.",
            "property" : [],
            "searchable" : "false",
            "transform" : [],
            "type" : "string",
            "id" : "taxon_closure",
            "indexed" : "true"
         },
         "enabled_by" : {
            "display_name" : "Enabled by",
            "description" : "???",
            "required" : "false",
            "cardinality" : "single",
            "transform" : [],
            "searchable" : "true",
            "property" : [],
            "type" : "string",
            "id" : "enabled_by",
            "indexed" : "true"
         },
         "taxon_closure_label" : {
            "indexed" : "true",
            "id" : "taxon_closure_label",
            "type" : "string",
            "property" : [],
            "searchable" : "true",
            "transform" : [],
            "description" : "Taxon label closure derived from GAF column 13 and ncbi_taxonomy.obo.",
            "display_name" : "Taxon",
            "cardinality" : "multi",
            "required" : "false"
         },
         "taxon" : {
            "description" : "GAF column 13 (taxon).",
            "display_name" : "Taxon",
            "cardinality" : "single",
            "required" : "false",
            "indexed" : "true",
            "id" : "taxon",
            "type" : "string",
            "searchable" : "false",
            "transform" : [],
            "property" : []
         },
         "process_class" : {
            "required" : "false",
            "cardinality" : "single",
            "description" : "Process acc/ID.",
            "display_name" : "Process",
            "id" : "process_class",
            "indexed" : "true",
            "transform" : [],
            "searchable" : "false",
            "property" : [],
            "type" : "string"
         },
         "location_list_label" : {
            "description" : "",
            "display_name" : "Location",
            "cardinality" : "multi",
            "required" : "false",
            "indexed" : "true",
            "id" : "location_list_label",
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "false"
         },
         "location_list_closure" : {
            "cardinality" : "multi",
            "required" : "false",
            "display_name" : "Location",
            "description" : "",
            "type" : "string",
            "property" : [],
            "searchable" : "false",
            "transform" : [],
            "indexed" : "true",
            "id" : "location_list_closure"
         },
         "process_class_label" : {
            "property" : [],
            "searchable" : "true",
            "transform" : [],
            "type" : "string",
            "id" : "process_class_label",
            "indexed" : "true",
            "required" : "false",
            "cardinality" : "single",
            "display_name" : "Process",
            "description" : "Common process name."
         },
         "annotation_unit_label" : {
            "description" : "???.",
            "display_name" : "Annotation unit",
            "required" : "false",
            "cardinality" : "single",
            "id" : "annotation_unit_label",
            "indexed" : "true",
            "property" : [],
            "transform" : [],
            "searchable" : "true",
            "type" : "string"
         },
         "annotation_group_label" : {
            "id" : "annotation_group_label",
            "indexed" : "true",
            "property" : [],
            "transform" : [],
            "searchable" : "true",
            "type" : "string",
            "required" : "false",
            "cardinality" : "single",
            "description" : "???.",
            "display_name" : "Annotation group"
         },
         "owl_blob_json" : {
            "display_name" : "???",
            "description" : "???",
            "cardinality" : "single",
            "required" : "false",
            "type" : "string",
            "property" : [],
            "searchable" : "false",
            "transform" : [],
            "indexed" : "false",
            "id" : "owl_blob_json"
         },
         "location_list" : {
            "indexed" : "true",
            "id" : "location_list",
            "type" : "string",
            "searchable" : "false",
            "transform" : [],
            "property" : [],
            "description" : "",
            "display_name" : "Location",
            "cardinality" : "multi",
            "required" : "false"
         },
         "annotation_unit" : {
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "false",
            "indexed" : "true",
            "id" : "annotation_unit",
            "display_name" : "Annotation unit",
            "description" : "???.",
            "cardinality" : "single",
            "required" : "false"
         },
         "function_class_closure" : {
            "required" : "false",
            "cardinality" : "multi",
            "description" : "???",
            "display_name" : "Function",
            "id" : "function_class_closure",
            "indexed" : "true",
            "property" : [],
            "transform" : [],
            "searchable" : "false",
            "type" : "string"
         },
         "annotation_group" : {
            "display_name" : "Annotation group",
            "description" : "???.",
            "required" : "false",
            "cardinality" : "single",
            "transform" : [],
            "searchable" : "false",
            "property" : [],
            "type" : "string",
            "id" : "annotation_group",
            "indexed" : "true"
         },
         "location_list_closure_label" : {
            "indexed" : "true",
            "id" : "location_list_closure_label",
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "false",
            "cardinality" : "multi",
            "required" : "false",
            "description" : "",
            "display_name" : "Location"
         },
         "enabled_by_label" : {
            "transform" : [],
            "searchable" : "true",
            "property" : [],
            "type" : "string",
            "id" : "enabled_by_label",
            "indexed" : "true",
            "display_name" : "Enabled by",
            "description" : "???",
            "required" : "false",
            "cardinality" : "single"
         },
         "process_class_closure" : {
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "false",
            "indexed" : "true",
            "id" : "process_class_closure",
            "display_name" : "Process",
            "description" : "???",
            "cardinality" : "multi",
            "required" : "false"
         },
         "panther_family_label" : {
            "property" : [],
            "transform" : [],
            "searchable" : "true",
            "type" : "string",
            "id" : "panther_family_label",
            "indexed" : "true",
            "required" : "false",
            "cardinality" : "single",
            "display_name" : "PANTHER family",
            "description" : "PANTHER families that are associated with this entity."
         },
         "function_class_closure_label" : {
            "type" : "string",
            "transform" : [],
            "searchable" : "true",
            "property" : [],
            "indexed" : "true",
            "id" : "function_class_closure_label",
            "cardinality" : "multi",
            "required" : "false",
            "display_name" : "Function",
            "description" : "???"
         },
         "topology_graph_json" : {
            "indexed" : "false",
            "id" : "topology_graph_json",
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "false",
            "description" : "JSON blob form of the local stepwise topology graph.",
            "display_name" : "Topology graph (JSON)",
            "cardinality" : "single",
            "required" : "false"
         },
         "taxon_label" : {
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "true",
            "indexed" : "true",
            "id" : "taxon_label",
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "Taxon",
            "description" : "Taxon derived from GAF column 13 and ncbi_taxonomy.obo."
         },
         "function_class" : {
            "cardinality" : "single",
            "required" : "false",
            "description" : "Function acc/ID.",
            "display_name" : "Function",
            "indexed" : "true",
            "id" : "function_class",
            "type" : "string",
            "transform" : [],
            "searchable" : "false",
            "property" : []
         },
         "process_class_closure_label" : {
            "required" : "false",
            "cardinality" : "multi",
            "description" : "???",
            "display_name" : "Process",
            "id" : "process_class_closure_label",
            "indexed" : "true",
            "property" : [],
            "transform" : [],
            "searchable" : "true",
            "type" : "string"
         }
      },
      "_outfile" : "/home/sjcarbon/local/src/git/amigo/metadata/complex-ann-config.yaml",
      "weight" : "-5",
      "id" : "complex_annotation",
      "filter_weights" : "annotation_group_label^5.0 enabled_by_label^4.5 location_list_closure_label^4.0 process_class_closure_label^3.0 function_class_closure_label^2.0",
      "document_category" : "complex_annotation",
      "schema_generating" : "true",
      "fields" : [
         {
            "display_name" : "ID",
            "description" : "A unique (and internal) thing.",
            "cardinality" : "single",
            "required" : "false",
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "false",
            "indexed" : "true",
            "id" : "id"
         },
         {
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "false",
            "indexed" : "true",
            "id" : "annotation_unit",
            "display_name" : "Annotation unit",
            "description" : "???.",
            "cardinality" : "single",
            "required" : "false"
         },
         {
            "description" : "???.",
            "display_name" : "Annotation unit",
            "required" : "false",
            "cardinality" : "single",
            "id" : "annotation_unit_label",
            "indexed" : "true",
            "property" : [],
            "transform" : [],
            "searchable" : "true",
            "type" : "string"
         },
         {
            "display_name" : "Annotation group",
            "description" : "???.",
            "required" : "false",
            "cardinality" : "single",
            "transform" : [],
            "searchable" : "false",
            "property" : [],
            "type" : "string",
            "id" : "annotation_group",
            "indexed" : "true"
         },
         {
            "id" : "annotation_group_label",
            "indexed" : "true",
            "property" : [],
            "transform" : [],
            "searchable" : "true",
            "type" : "string",
            "required" : "false",
            "cardinality" : "single",
            "description" : "???.",
            "display_name" : "Annotation group"
         },
         {
            "description" : "???.",
            "display_name" : "Annotation group URL",
            "required" : "false",
            "cardinality" : "single",
            "id" : "annotation_group_url",
            "indexed" : "true",
            "property" : [],
            "searchable" : "false",
            "transform" : [],
            "type" : "string"
         },
         {
            "display_name" : "Enabled by",
            "description" : "???",
            "required" : "false",
            "cardinality" : "single",
            "transform" : [],
            "searchable" : "true",
            "property" : [],
            "type" : "string",
            "id" : "enabled_by",
            "indexed" : "true"
         },
         {
            "transform" : [],
            "searchable" : "true",
            "property" : [],
            "type" : "string",
            "id" : "enabled_by_label",
            "indexed" : "true",
            "display_name" : "Enabled by",
            "description" : "???",
            "required" : "false",
            "cardinality" : "single"
         },
         {
            "required" : "false",
            "cardinality" : "single",
            "display_name" : "PANTHER family",
            "description" : "PANTHER family IDs that are associated with this entity.",
            "searchable" : "true",
            "transform" : [],
            "property" : [],
            "type" : "string",
            "id" : "panther_family",
            "indexed" : "true"
         },
         {
            "property" : [],
            "transform" : [],
            "searchable" : "true",
            "type" : "string",
            "id" : "panther_family_label",
            "indexed" : "true",
            "required" : "false",
            "cardinality" : "single",
            "display_name" : "PANTHER family",
            "description" : "PANTHER families that are associated with this entity."
         },
         {
            "description" : "GAF column 13 (taxon).",
            "display_name" : "Taxon",
            "cardinality" : "single",
            "required" : "false",
            "indexed" : "true",
            "id" : "taxon",
            "type" : "string",
            "searchable" : "false",
            "transform" : [],
            "property" : []
         },
         {
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "true",
            "indexed" : "true",
            "id" : "taxon_label",
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "Taxon",
            "description" : "Taxon derived from GAF column 13 and ncbi_taxonomy.obo."
         },
         {
            "required" : "false",
            "cardinality" : "multi",
            "display_name" : "Taxon (IDs)",
            "description" : "Taxon IDs derived from GAF column 13 and ncbi_taxonomy.obo.",
            "property" : [],
            "searchable" : "false",
            "transform" : [],
            "type" : "string",
            "id" : "taxon_closure",
            "indexed" : "true"
         },
         {
            "indexed" : "true",
            "id" : "taxon_closure_label",
            "type" : "string",
            "property" : [],
            "searchable" : "true",
            "transform" : [],
            "description" : "Taxon label closure derived from GAF column 13 and ncbi_taxonomy.obo.",
            "display_name" : "Taxon",
            "cardinality" : "multi",
            "required" : "false"
         },
         {
            "cardinality" : "single",
            "required" : "false",
            "description" : "Function acc/ID.",
            "display_name" : "Function",
            "indexed" : "true",
            "id" : "function_class",
            "type" : "string",
            "transform" : [],
            "searchable" : "false",
            "property" : []
         },
         {
            "cardinality" : "single",
            "required" : "false",
            "description" : "Common function name.",
            "display_name" : "Function",
            "indexed" : "true",
            "id" : "function_class_label",
            "type" : "string",
            "searchable" : "true",
            "transform" : [],
            "property" : []
         },
         {
            "required" : "false",
            "cardinality" : "multi",
            "description" : "???",
            "display_name" : "Function",
            "id" : "function_class_closure",
            "indexed" : "true",
            "property" : [],
            "transform" : [],
            "searchable" : "false",
            "type" : "string"
         },
         {
            "type" : "string",
            "transform" : [],
            "searchable" : "true",
            "property" : [],
            "indexed" : "true",
            "id" : "function_class_closure_label",
            "cardinality" : "multi",
            "required" : "false",
            "display_name" : "Function",
            "description" : "???"
         },
         {
            "required" : "false",
            "cardinality" : "single",
            "description" : "Process acc/ID.",
            "display_name" : "Process",
            "id" : "process_class",
            "indexed" : "true",
            "transform" : [],
            "searchable" : "false",
            "property" : [],
            "type" : "string"
         },
         {
            "property" : [],
            "searchable" : "true",
            "transform" : [],
            "type" : "string",
            "id" : "process_class_label",
            "indexed" : "true",
            "required" : "false",
            "cardinality" : "single",
            "display_name" : "Process",
            "description" : "Common process name."
         },
         {
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "false",
            "indexed" : "true",
            "id" : "process_class_closure",
            "display_name" : "Process",
            "description" : "???",
            "cardinality" : "multi",
            "required" : "false"
         },
         {
            "required" : "false",
            "cardinality" : "multi",
            "description" : "???",
            "display_name" : "Process",
            "id" : "process_class_closure_label",
            "indexed" : "true",
            "property" : [],
            "transform" : [],
            "searchable" : "true",
            "type" : "string"
         },
         {
            "indexed" : "true",
            "id" : "location_list",
            "type" : "string",
            "searchable" : "false",
            "transform" : [],
            "property" : [],
            "description" : "",
            "display_name" : "Location",
            "cardinality" : "multi",
            "required" : "false"
         },
         {
            "description" : "",
            "display_name" : "Location",
            "cardinality" : "multi",
            "required" : "false",
            "indexed" : "true",
            "id" : "location_list_label",
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "false"
         },
         {
            "cardinality" : "multi",
            "required" : "false",
            "display_name" : "Location",
            "description" : "",
            "type" : "string",
            "property" : [],
            "searchable" : "false",
            "transform" : [],
            "indexed" : "true",
            "id" : "location_list_closure"
         },
         {
            "indexed" : "true",
            "id" : "location_list_closure_label",
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "false",
            "cardinality" : "multi",
            "required" : "false",
            "description" : "",
            "display_name" : "Location"
         },
         {
            "display_name" : "???",
            "description" : "???",
            "cardinality" : "single",
            "required" : "false",
            "type" : "string",
            "property" : [],
            "searchable" : "false",
            "transform" : [],
            "indexed" : "false",
            "id" : "owl_blob_json"
         },
         {
            "indexed" : "false",
            "id" : "topology_graph_json",
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "false",
            "description" : "JSON blob form of the local stepwise topology graph.",
            "display_name" : "Topology graph (JSON)",
            "cardinality" : "single",
            "required" : "false"
         }
      ]
   },
   "bbop_term_ac" : {
      "_infile" : "/home/sjcarbon/local/src/git/amigo/metadata/term-autocomplete-config.yaml",
      "_strict" : 0,
      "searchable_extension" : "_searchable",
      "description" : "Easily find ontology classes in GO. For personality only - not a schema configuration.",
      "display_name" : "Term autocomplete",
      "boost_weights" : "annotation_class^5.0 annotation_class_label^5.0 synonym^1.0 alternate_id^1.0",
      "result_weights" : "annotation_class^8.0 synonym^3.0 alternate_id^2.0",
      "id" : "bbop_term_ac",
      "filter_weights" : "annotation_class^8.0 synonym^3.0 alternate_id^2.0",
      "schema_generating" : "false",
      "document_category" : "ontology_class",
      "fields" : [
         {
            "display_name" : "Acc",
            "description" : "Term acc/ID.",
            "required" : "false",
            "cardinality" : "single",
            "searchable" : "false",
            "property" : [],
            "transform" : [],
            "type" : "string",
            "id" : "id",
            "indexed" : "true"
         },
         {
            "transform" : [],
            "property" : [],
            "searchable" : "false",
            "type" : "string",
            "id" : "annotation_class",
            "indexed" : "true",
            "required" : "false",
            "cardinality" : "single",
            "display_name" : "Term",
            "description" : "Term acc/ID."
         },
         {
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "true",
            "indexed" : "true",
            "id" : "annotation_class_label",
            "display_name" : "Term",
            "description" : "Common term name.",
            "cardinality" : "single",
            "required" : "false"
         },
         {
            "id" : "synonym",
            "indexed" : "true",
            "transform" : [],
            "searchable" : "true",
            "property" : [],
            "type" : "string",
            "required" : "false",
            "cardinality" : "multi",
            "description" : "Term synonyms.",
            "display_name" : "Synonyms"
         },
         {
            "indexed" : "true",
            "id" : "alternate_id",
            "type" : "string",
            "property" : [],
            "transform" : [],
            "searchable" : "false",
            "description" : "Alternate term id.",
            "display_name" : "Alt ID",
            "cardinality" : "multi",
            "required" : "false"
         }
      ],
      "fields_hash" : {
         "annotation_class" : {
            "transform" : [],
            "property" : [],
            "searchable" : "false",
            "type" : "string",
            "id" : "annotation_class",
            "indexed" : "true",
            "required" : "false",
            "cardinality" : "single",
            "display_name" : "Term",
            "description" : "Term acc/ID."
         },
         "annotation_class_label" : {
            "type" : "string",
            "transform" : [],
            "property" : [],
            "searchable" : "true",
            "indexed" : "true",
            "id" : "annotation_class_label",
            "display_name" : "Term",
            "description" : "Common term name.",
            "cardinality" : "single",
            "required" : "false"
         },
         "synonym" : {
            "id" : "synonym",
            "indexed" : "true",
            "transform" : [],
            "searchable" : "true",
            "property" : [],
            "type" : "string",
            "required" : "false",
            "cardinality" : "multi",
            "description" : "Term synonyms.",
            "display_name" : "Synonyms"
         },
         "alternate_id" : {
            "indexed" : "true",
            "id" : "alternate_id",
            "type" : "string",
            "property" : [],
            "transform" : [],
            "searchable" : "false",
            "description" : "Alternate term id.",
            "display_name" : "Alt ID",
            "cardinality" : "multi",
            "required" : "false"
         },
         "id" : {
            "display_name" : "Acc",
            "description" : "Term acc/ID.",
            "required" : "false",
            "cardinality" : "single",
            "searchable" : "false",
            "property" : [],
            "transform" : [],
            "type" : "string",
            "id" : "id",
            "indexed" : "true"
         }
      },
      "weight" : "-20",
      "_outfile" : "/home/sjcarbon/local/src/git/amigo/metadata/term-autocomplete-config.yaml"
   },
   "general" : {
      "_outfile" : "/home/sjcarbon/local/src/git/amigo/metadata/general-config.yaml",
      "weight" : "0",
      "fields_hash" : {
         "entity_label" : {
            "type" : "string",
            "property" : [],
            "searchable" : "true",
            "transform" : [],
            "indexed" : "true",
            "id" : "entity_label",
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "Enity label",
            "description" : "The label for this entity."
         },
         "category" : {
            "id" : "category",
            "indexed" : "true",
            "searchable" : "false",
            "property" : [],
            "transform" : [],
            "type" : "string",
            "description" : "The document category that this enitity belongs to.",
            "display_name" : "Document category",
            "required" : "false",
            "cardinality" : "single"
         },
         "general_blob" : {
            "display_name" : "Generic blob",
            "description" : "A hidden searchable blob document to access this item. It should contain all the goodies that we want to search for, like species(?), synonyms, etc.",
            "cardinality" : "single",
            "required" : "false",
            "type" : "string",
            "property" : [],
            "searchable" : "true",
            "transform" : [],
            "indexed" : "true",
            "id" : "general_blob"
         },
         "id" : {
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "Internal ID",
            "description" : "The mangled internal ID for this entity.",
            "type" : "string",
            "property" : [],
            "searchable" : "false",
            "transform" : [],
            "indexed" : "true",
            "id" : "id"
         },
         "entity" : {
            "required" : "false",
            "cardinality" : "single",
            "display_name" : "Entity",
            "description" : "The ID/label for this entity.",
            "searchable" : "false",
            "transform" : [],
            "property" : [],
            "type" : "string",
            "id" : "entity",
            "indexed" : "true"
         }
      },
      "filter_weights" : "category^4.0",
      "id" : "general",
      "document_category" : "general",
      "fields" : [
         {
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "Internal ID",
            "description" : "The mangled internal ID for this entity.",
            "type" : "string",
            "property" : [],
            "searchable" : "false",
            "transform" : [],
            "indexed" : "true",
            "id" : "id"
         },
         {
            "required" : "false",
            "cardinality" : "single",
            "display_name" : "Entity",
            "description" : "The ID/label for this entity.",
            "searchable" : "false",
            "transform" : [],
            "property" : [],
            "type" : "string",
            "id" : "entity",
            "indexed" : "true"
         },
         {
            "type" : "string",
            "property" : [],
            "searchable" : "true",
            "transform" : [],
            "indexed" : "true",
            "id" : "entity_label",
            "cardinality" : "single",
            "required" : "false",
            "display_name" : "Enity label",
            "description" : "The label for this entity."
         },
         {
            "id" : "category",
            "indexed" : "true",
            "searchable" : "false",
            "property" : [],
            "transform" : [],
            "type" : "string",
            "description" : "The document category that this enitity belongs to.",
            "display_name" : "Document category",
            "required" : "false",
            "cardinality" : "single"
         },
         {
            "display_name" : "Generic blob",
            "description" : "A hidden searchable blob document to access this item. It should contain all the goodies that we want to search for, like species(?), synonyms, etc.",
            "cardinality" : "single",
            "required" : "false",
            "type" : "string",
            "property" : [],
            "searchable" : "true",
            "transform" : [],
            "indexed" : "true",
            "id" : "general_blob"
         }
      ],
      "schema_generating" : "true",
      "result_weights" : "entity^3.0 category^1.0",
      "boost_weights" : "entity^3.0 entity_label^3.0 general_blob^3.0",
      "_strict" : 0,
      "description" : "A generic search document to get a general overview of everything.",
      "searchable_extension" : "_searchable",
      "_infile" : "/home/sjcarbon/local/src/git/amigo/metadata/general-config.yaml",
      "display_name" : "General"
   }
};
/*
 * Package: server.js
 * 
 * Namespace: amigo.data.server
 * 
 * This package was automatically created during AmiGO 2 installation.
 * 
 * Purpose: Useful information about GO and the AmiGO installation.
 *          Also serves as a repository and getter for web
 *          resources such as images.
 * 
 * NOTE: This file is generated dynamically at installation time.
 *       Hard to work with unit tests--hope it's not too bad.
 *       Want to keep this real simple.
 */

// Module and namespace checking.
if ( typeof amigo == "undefined" ){ var amigo = {}; }
if ( typeof amigo.data == "undefined" ){ amigo.data = {}; }

/*
 * Constructor: server
 * 
 * The configuration for the server settings.
 * Essentially a JSONification of the config.pl AmiGO 2 file.
 * 
 * Arguments:
 *  n/a
 */
amigo.data.server = function(){

    // All of the server/instance-specific meta-data.
    var meta_data = {"js_base":"http://localhost:9999/static/js","html_base":"http://localhost:9999/static","js_dev_base":"http://localhost:9999/static/staging","bbop_img_star":"http://localhost:9999/static/images/star.png","species":[],"galaxy_base":"http://galaxy.berkeleybop.org/","evidence_codes":{},"css_base":"http://localhost:9999/static/css","app_base":"http://localhost:9999","image_base":"http://localhost:9999/static/images","species_map":{},"beta":"1","term_regexp":"all|GO:[0-9]{7}","sources":[],"ontologies":[],"gp_types":[],"golr_base":"http://localhost:8080/solr/"};

    ///
    /// Break out the data and various functions to access them...
    ///

    /*
     * Function: js_base
     * 
     * Access to AmiGO variable js_base.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  string
     */
    var js_base = meta_data.js_base;
    this.js_base = function(){ return js_base; };

    /*
     * Function: html_base
     * 
     * Access to AmiGO variable html_base.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  string
     */
    var html_base = meta_data.html_base;
    this.html_base = function(){ return html_base; };

    /*
     * Function: js_dev_base
     * 
     * Access to AmiGO variable js_dev_base.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  string
     */
    var js_dev_base = meta_data.js_dev_base;
    this.js_dev_base = function(){ return js_dev_base; };

    /*
     * Function: bbop_img_star
     * 
     * Access to AmiGO variable bbop_img_star.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  string
     */
    var bbop_img_star = meta_data.bbop_img_star;
    this.bbop_img_star = function(){ return bbop_img_star; };

    /*
     * Function: species
     * 
     * Access to AmiGO variable species.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  string
     */
    var species = meta_data.species;
    this.species = function(){ return species; };

    /*
     * Function: galaxy_base
     * 
     * Access to AmiGO variable galaxy_base.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  string
     */
    var galaxy_base = meta_data.galaxy_base;
    this.galaxy_base = function(){ return galaxy_base; };

    /*
     * Function: evidence_codes
     * 
     * Access to AmiGO variable evidence_codes.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  string
     */
    var evidence_codes = meta_data.evidence_codes;
    this.evidence_codes = function(){ return evidence_codes; };

    /*
     * Function: css_base
     * 
     * Access to AmiGO variable css_base.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  string
     */
    var css_base = meta_data.css_base;
    this.css_base = function(){ return css_base; };

    /*
     * Function: app_base
     * 
     * Access to AmiGO variable app_base.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  string
     */
    var app_base = meta_data.app_base;
    this.app_base = function(){ return app_base; };

    /*
     * Function: image_base
     * 
     * Access to AmiGO variable image_base.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  string
     */
    var image_base = meta_data.image_base;
    this.image_base = function(){ return image_base; };

    /*
     * Function: species_map
     * 
     * Access to AmiGO variable species_map.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  string
     */
    var species_map = meta_data.species_map;
    this.species_map = function(){ return species_map; };

    /*
     * Function: beta
     * 
     * Access to AmiGO variable beta.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  string
     */
    var beta = meta_data.beta;
    this.beta = function(){ return beta; };

    /*
     * Function: term_regexp
     * 
     * Access to AmiGO variable term_regexp.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  string
     */
    var term_regexp = meta_data.term_regexp;
    this.term_regexp = function(){ return term_regexp; };

    /*
     * Function: sources
     * 
     * Access to AmiGO variable sources.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  string
     */
    var sources = meta_data.sources;
    this.sources = function(){ return sources; };

    /*
     * Function: ontologies
     * 
     * Access to AmiGO variable ontologies.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  string
     */
    var ontologies = meta_data.ontologies;
    this.ontologies = function(){ return ontologies; };

    /*
     * Function: gp_types
     * 
     * Access to AmiGO variable gp_types.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  string
     */
    var gp_types = meta_data.gp_types;
    this.gp_types = function(){ return gp_types; };

    /*
     * Function: golr_base
     * 
     * Access to AmiGO variable golr_base.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  string
     */
    var golr_base = meta_data.golr_base;
    this.golr_base = function(){ return golr_base; };


    // Does it look like a term?
    var tre_str = meta_data.term_regexp;
    var tre = new RegExp(tre_str);

    /*
     * Function: term_id_p
     * 
     * True or false on whether or not a string looks like a GO term id.
     * 
     * Parameters:
     *  term_id - the string to test
     * 
     * Returns:
     *  boolean
     */
    this.term_id_p = function(term_id){
       var retval = false;
       if( tre.test(term_id) ){
          retval = true;
       }
       return retval;
    };

    /*
     * Function: get_image_resource
     * 
     * Get a named resource from the meta_data hash if possible.
     * 
     * Parameters:
     *  resource - the string id of the resource
     * 
     * Returns:
     * string (url) of resource
     */
    this.get_image_resource = function(resource){

       var retval = null;
       var mangled_res = 'bbop_img_' + resource;

       if( meta_data[mangled_res] ){
          retval = meta_data[mangled_res];
       }
       return retval;
    };
};
/*
 * Package: definitions.js
 * 
 * Namespace: amigo.data.definitions
 * 
 * Purpose: Useful information about common GO datatypes and
 * structures, as well as some constants.
 */

// Module and namespace checking.
if ( typeof amigo == "undefined" ){ var amigo = {}; }
if ( typeof amigo.data == "undefined" ){ amigo.data = {}; }

/*
 * Constructor: definitions
 * 
 * Encapsulate common structures and constants.
 * 
 * Arguments:
 *  n/a
 */
amigo.data.definitions = function(){

    /*
     * Function: gaf_from_golr_fields
     * 
     * A list of fields to generate a GAF from using golr fields.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  list of strings
     */
    this.gaf_from_golr_fields = function(){
	return [
	    'source', // c1
	    'bioentity_internal_id', // c2; not bioentity
	    'bioentity_label', // c3
	    'qualifier', // c4
	    'annotation_class', // c5
	    'reference', // c6
	    'evidence_type', // c7
	    'evidence_with', // c8
	    'aspect', // c9
	    'bioentity_name', // c10
	    'synonym', // c11
	    'type', // c12
	    'taxon', // c13
	    'date', // c14
	    'assigned_by', // c15
	    'annotation_extension_class', // c16
	    'bioentity_isoform' // c17
	];
    };

    /*
     * Function: download_limit
     * 
     * The maximum allowed number of items to download for out server.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  integer
     */
    this.download_limit = function(){
	//return 7500;
	return 10000;
    };

};
/* 
 * Package: xrefs.js
 * 
 * Namespace: amigo.data.xrefs
 * 
 * This package was automatically created during an AmiGO 2 installation
 * from the GO.xrf_abbs file at: "http://www.geneontology.org/doc/GO.xrf_abbs".
 *
 * NOTE: This file is generated dynamically at installation time.
 * Hard to work with unit tests--hope it's not too bad. You have to
 * occasionally copy back to keep the unit tests sane.
 */

// All of the server/instance-specific meta-data.
if ( typeof amigo == "undefined" ){ var amigo = {}; }
if ( typeof amigo.data == "undefined" ){ amigo.data = {}; }

/*
 * Variable: xrefs
 * 
 * All the external references that we know about.
 */
amigo.data.xrefs = {
   "hgnc" : {
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_example" : "http://www.genenames.org/data/hgnc_data.php?hgnc_id=HGNC:29",
      "url_syntax" : "http://www.genenames.org/data/hgnc_data.php?hgnc_id=HGNC:[example_id]",
      "abbreviation" : "HGNC",
      "generic_url" : "http://www.genenames.org/",
      "datatype" : null,
      "local_id_syntax" : "[0-9]+",
      "fullname" : null,
      "example_id" : "HGNC:29",
      "name" : null,
      "database" : "HUGO Gene Nomenclature Committee",
      "entity_type" : "SO:0000704 ! gene"
   },
   "roslin_institute" : {
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_syntax" : null,
      "url_example" : null,
      "generic_url" : "http://www.roslin.ac.uk/",
      "abbreviation" : "Roslin_Institute",
      "datatype" : null,
      "fullname" : null,
      "database" : "Roslin Institute",
      "example_id" : null,
      "name" : null,
      "entity_type" : "BET:0000000 ! entity"
   },
   "pubmed" : {
      "name" : null,
      "database" : "PubMed",
      "example_id" : "PMID:4208797",
      "entity_type" : "BET:0000000 ! entity",
      "local_id_syntax" : "[0-9]+",
      "fullname" : null,
      "url_syntax" : "http://www.ncbi.nlm.nih.gov/pubmed/[example_id]",
      "url_example" : "http://www.ncbi.nlm.nih.gov/pubmed/4208797",
      "datatype" : null,
      "generic_url" : "http://www.ncbi.nlm.nih.gov/PubMed/",
      "abbreviation" : "PubMed",
      "object" : null,
      "uri_prefix" : null,
      "id" : null
   },
   "ddbj" : {
      "fullname" : null,
      "name" : null,
      "example_id" : "DDBJ:AA816246",
      "database" : "DNA Databank of Japan",
      "entity_type" : "BET:0000000 ! entity",
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_example" : "http://arsa.ddbj.nig.ac.jp/arsa/ddbjSplSearch?KeyWord=AA816246",
      "url_syntax" : "http://arsa.ddbj.nig.ac.jp/arsa/ddbjSplSearch?KeyWord=[example_id]",
      "abbreviation" : "DDBJ",
      "generic_url" : "http://www.ddbj.nig.ac.jp/",
      "datatype" : null
   },
   "cdd" : {
      "database" : "Conserved Domain Database at NCBI",
      "example_id" : "CDD:34222",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null,
      "url_example" : "http://www.ncbi.nlm.nih.gov/Structure/cdd/cddsrv.cgi?uid=34222",
      "url_syntax" : "http://www.ncbi.nlm.nih.gov/Structure/cdd/cddsrv.cgi?uid=[example_id]",
      "datatype" : null,
      "abbreviation" : "CDD",
      "generic_url" : "http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?db=cdd",
      "object" : null,
      "uri_prefix" : null,
      "id" : null
   },
   "hgnc_gene" : {
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "HGNC_gene:ABCA1",
      "name" : null,
      "database" : "HUGO Gene Nomenclature Committee",
      "fullname" : null,
      "datatype" : null,
      "abbreviation" : "HGNC_gene",
      "generic_url" : "http://www.genenames.org/",
      "url_example" : "http://www.genenames.org/data/hgnc_data.php?app_sym=ABCA1",
      "url_syntax" : "http://www.genenames.org/data/hgnc_data.php?app_sym=[example_id]",
      "id" : null,
      "object" : null,
      "uri_prefix" : null
   },
   "wikipedia" : {
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "Wikipedia:Endoplasmic_reticulum",
      "database" : "Wikipedia",
      "name" : null,
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "abbreviation" : "Wikipedia",
      "generic_url" : "http://en.wikipedia.org/",
      "url_syntax" : "http://en.wikipedia.org/wiki/[example_id]",
      "url_example" : "http://en.wikipedia.org/wiki/Endoplasmic_reticulum"
   },
   "nif_subcellular" : {
      "url_syntax" : "http://www.neurolex.org/wiki/[example_id]",
      "url_example" : "http://www.neurolex.org/wiki/sao1770195789",
      "generic_url" : "http://www.neurolex.org/wiki",
      "abbreviation" : "NIF_Subcellular",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "example_id" : "NIF_Subcellular:sao1186862860",
      "database" : "Neuroscience Information Framework standard ontology, subcellular hierarchy",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null
   },
   "ppi" : {
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_example" : null,
      "url_syntax" : null,
      "generic_url" : "http://genome.pseudomonas-syringae.org/",
      "abbreviation" : "PPI",
      "datatype" : null,
      "fullname" : null,
      "name" : null,
      "example_id" : null,
      "database" : "Pseudomonas syringae community annotation project",
      "entity_type" : "BET:0000000 ! entity"
   },
   "cas_spc" : {
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "abbreviation" : "CAS_SPC",
      "generic_url" : "http://research.calacademy.org/research/ichthyology/catalog/fishcatsearch.html",
      "datatype" : null,
      "url_syntax" : "http://research.calacademy.org/research/ichthyology/catalog/getname.asp?rank=Species&id=[example_id]",
      "url_example" : "http://research.calacademy.org/research/ichthyology/catalog/getname.asp?rank=Species&id=1979",
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : null,
      "name" : null,
      "database" : "Catalog of Fishes species database"
   },
   "dictybase_gene_name" : {
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "database" : "dictyBase",
      "example_id" : "dictyBase_gene_name:mlcE",
      "name" : null,
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "abbreviation" : "dictyBase_gene_name",
      "generic_url" : "http://dictybase.org",
      "datatype" : null,
      "url_syntax" : "http://dictybase.org/gene/[example_id]",
      "url_example" : "http://dictybase.org/gene/mlcE"
   },
   "dictybase" : {
      "local_id_syntax" : "DDB_G[0-9]{7}",
      "fullname" : null,
      "database" : "dictyBase",
      "example_id" : "dictyBase:DDB_G0277859",
      "name" : null,
      "entity_type" : "SO:0000704 ! gene",
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_example" : "http://dictybase.org/gene/DDB_G0277859",
      "url_syntax" : "http://dictybase.org/gene/[example_id]",
      "abbreviation" : "DictyBase",
      "generic_url" : "http://dictybase.org",
      "datatype" : null
   },
   "cgd_locus" : {
      "name" : null,
      "example_id" : "CGD_LOCUS:HWP1",
      "database" : "Candida Genome Database",
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null,
      "url_syntax" : "http://www.candidagenome.org/cgi-bin/locus.pl?locus=[example_id]",
      "url_example" : "http://www.candidagenome.org/cgi-bin/locus.pl?locus=HWP1",
      "generic_url" : "http://www.candidagenome.org/",
      "abbreviation" : "CGD_LOCUS",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null
   },
   "pseudocap" : {
      "name" : null,
      "example_id" : "PseudoCAP:PA4756",
      "database" : "Pseudomonas Genome Project",
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null,
      "url_example" : "http://v2.pseudomonas.com/getAnnotation.do?locusID=PA4756",
      "url_syntax" : "http://v2.pseudomonas.com/getAnnotation.do?locusID=[example_id]",
      "datatype" : null,
      "generic_url" : "http://v2.pseudomonas.com/",
      "abbreviation" : "PseudoCAP",
      "object" : null,
      "uri_prefix" : null,
      "id" : null
   },
   "tigr_cmr" : {
      "generic_url" : "http://cmr.jcvi.org/",
      "abbreviation" : "TIGR_CMR",
      "datatype" : null,
      "url_example" : "http://cmr.jcvi.org/cgi-bin/CMR/shared/GenePage.cgi?locus=VCA0557",
      "url_syntax" : "http://cmr.jcvi.org/cgi-bin/CMR/shared/GenePage.cgi?locus=[example_id]",
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "entity_type" : "PR:000000001 ! protein",
      "database" : "EGAD database at the J. Craig Venter Institute",
      "name" : null,
      "example_id" : "JCVI_CMR:VCA0557",
      "fullname" : null
   },
   "obo_sf_po" : {
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "OBO_SF_PO:3184921",
      "database" : "Source Forge OBO Plant Ontology (PO) term request tracker",
      "name" : null,
      "fullname" : null,
      "generic_url" : "http://sourceforge.net/tracker/?func=browse&group_id=76834&atid=835555",
      "abbreviation" : "OBO_SF_PO",
      "datatype" : null,
      "url_syntax" : "https://sourceforge.net/tracker/index.php?func=detail&aid=[example_id]&group_id=76834&atid=835555",
      "url_example" : "https://sourceforge.net/tracker/index.php?func=detail&aid=3184921&group_id=76834&atid=835555",
      "id" : null,
      "uri_prefix" : null,
      "object" : null
   },
   "eurofung" : {
      "datatype" : null,
      "abbreviation" : "Eurofung",
      "generic_url" : "http://www.eurofung.net/option=com_content&task=section&id=3&Itemid=4",
      "url_syntax" : null,
      "url_example" : null,
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "entity_type" : "BET:0000000 ! entity",
      "name" : null,
      "example_id" : null,
      "database" : "Eurofungbase community annotation",
      "fullname" : null
   },
   "uberon" : {
      "fullname" : null,
      "description" : "A multi-species anatomy ontology",
      "local_id_syntax" : "[0-9]{7}",
      "entity_type" : "CARO:0000000 ! anatomical entity",
      "database" : "Uber-anatomy ontology",
      "example_id" : "URBERON:0002398",
      "name" : null,
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "abbreviation" : "UBERON",
      "generic_url" : "http://uberon.org",
      "datatype" : null,
      "url_syntax" : "http://purl.obolibrary.org/obo/UBERON_[example_id]",
      "url_example" : "http://purl.obolibrary.org/obo/UBERON_0002398"
   },
   "prodom" : {
      "url_example" : "http://prodom.prabi.fr/prodom/current/cgi-bin/request.pl?question=DBEN&query=PD000001",
      "url_syntax" : "http://prodom.prabi.fr/prodom/current/cgi-bin/request.pl?question=DBEN&query=[example_id]",
      "generic_url" : "http://prodom.prabi.fr/prodom/current/html/home.php",
      "abbreviation" : "ProDom",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "example_id" : "ProDom:PD000001",
      "database" : "ProDom protein domain families",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null,
      "description" : "ProDom protein domain families automatically generated from UniProtKB"
   },
   "pubchem_bioassay" : {
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "abbreviation" : "PubChem_BioAssay",
      "generic_url" : "http://pubchem.ncbi.nlm.nih.gov/",
      "datatype" : null,
      "url_example" : "http://pubchem.ncbi.nlm.nih.gov/assay/assay.cgi?aid=177",
      "url_syntax" : "http://pubchem.ncbi.nlm.nih.gov/assay/assay.cgi?aid=[example_id]",
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "PubChem_BioAssay:177",
      "name" : null,
      "database" : "NCBI PubChem database of bioassay records"
   },
   "genbank" : {
      "url_example" : "http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=nucleotide&val=AA816246",
      "url_syntax" : "http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=nucleotide&val=[example_id]",
      "abbreviation" : "GenBank",
      "generic_url" : "http://www.ncbi.nlm.nih.gov/Genbank/",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "example_id" : "GB:AA816246",
      "name" : null,
      "database" : "GenBank",
      "entity_type" : "PR:000000001 ! protein",
      "local_id_syntax" : "([A-Z]{2}[0-9]{6})|([A-Z]{1}[0-9]{5})",
      "fullname" : null,
      "description" : "The NIH genetic sequence database, an annotated collection of all publicly available DNA sequences."
   },
   "um-bbd" : {
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "database" : "University of Minnesota Biocatalysis/Biodegradation Database",
      "example_id" : null,
      "name" : null,
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "generic_url" : "http://umbbd.msi.umn.edu/",
      "abbreviation" : "UM-BBD",
      "url_example" : null,
      "url_syntax" : null
   },
   "prosite" : {
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_syntax" : "http://www.expasy.ch/cgi-bin/prosite-search-ac?[example_id]",
      "url_example" : "http://www.expasy.ch/cgi-bin/prosite-search-ac?PS00365",
      "datatype" : null,
      "generic_url" : "http://www.expasy.ch/prosite/",
      "abbreviation" : "Prosite",
      "fullname" : null,
      "example_id" : "Prosite:PS00365",
      "name" : null,
      "database" : "Prosite database of protein families and domains",
      "entity_type" : "SO:0000839 ! polypeptide region"
   },
   "biocyc" : {
      "fullname" : null,
      "database" : "BioCyc collection of metabolic pathway databases",
      "example_id" : "BioCyc:PWY-5271",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_syntax" : "http://biocyc.org/META/NEW-IMAGE?type=PATHWAY&object=[example_id]",
      "url_example" : "http://biocyc.org/META/NEW-IMAGE?type=PATHWAY&object=PWY-5271",
      "datatype" : null,
      "abbreviation" : "BioCyc",
      "generic_url" : "http://biocyc.org/"
   },
   "unipathway" : {
      "example_id" : "UniPathway:UPA00155",
      "name" : null,
      "database" : "UniPathway",
      "entity_type" : "GO:0008150 ! biological_process",
      "description" : "UniPathway is a a metabolic door to UniProtKB/Swiss-Prot, a curated resource of metabolic pathways for the UniProtKB/Swiss-Prot knowledgebase.",
      "fullname" : null,
      "url_example" : "http://www.grenoble.prabi.fr/obiwarehouse/unipathway/upa?upid=UPA00155",
      "url_syntax" : "http://www.grenoble.prabi.fr/obiwarehouse/unipathway/upa?upid=[example_id]",
      "datatype" : null,
      "abbreviation" : "UniPathway",
      "generic_url" : "http://www.grenoble.prabi.fr/obiwarehouse/unipathway",
      "object" : null,
      "uri_prefix" : null,
      "id" : null
   },
   "go_central" : {
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "generic_url" : "http://www.geneontology.org/GO.refgenome.shtml",
      "abbreviation" : "GO_Central",
      "url_syntax" : null,
      "url_example" : null,
      "description" : "Manual annotation from PAINT curators into the UniProt Protein2GO curation tool.",
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "name" : null,
      "example_id" : null,
      "database" : "GO Central"
   },
   "cog" : {
      "fullname" : null,
      "example_id" : null,
      "name" : null,
      "database" : "NCBI Clusters of Orthologous Groups",
      "entity_type" : "BET:0000000 ! entity",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_example" : null,
      "url_syntax" : null,
      "datatype" : null,
      "abbreviation" : "COG",
      "generic_url" : "http://www.ncbi.nlm.nih.gov/COG/"
   },
   "iuphar_gpcr" : {
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "IUPHAR_GPCR:1279",
      "database" : "International Union of Pharmacology",
      "name" : null,
      "fullname" : null,
      "datatype" : null,
      "generic_url" : "http://www.iuphar.org/",
      "abbreviation" : "IUPHAR_GPCR",
      "url_syntax" : "http://www.iuphar-db.org/DATABASE/FamilyMenuForward?familyId=[example_id]",
      "url_example" : "http://www.iuphar-db.org/DATABASE/FamilyMenuForward?familyId=13",
      "id" : null,
      "object" : null,
      "uri_prefix" : null
   },
   "ncbi_gp" : {
      "url_example" : "http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=protein&val=EAL72968",
      "url_syntax" : "http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=protein&val=[example_id]",
      "datatype" : null,
      "abbreviation" : "NCBI_GP",
      "generic_url" : "http://www.ncbi.nlm.nih.gov/",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "example_id" : "NCBI_GP:EAL72968",
      "name" : null,
      "database" : "NCBI GenPept",
      "entity_type" : "PR:000000001 ! protein",
      "local_id_syntax" : "[A-Z]{3}[0-9]{5}(\\.[0-9]+)?",
      "fullname" : null
   },
   "pamgo_vmd" : {
      "database" : "Virginia Bioinformatics Institute Microbial Database",
      "example_id" : "PAMGO_VMD:109198",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null,
      "description" : "Virginia Bioinformatics Institute Microbial Database; member of PAMGO Interest Group",
      "url_example" : "http://vmd.vbi.vt.edu/cgi-bin/browse/go_detail.cgi?gene_id=109198",
      "url_syntax" : "http://vmd.vbi.vt.edu/cgi-bin/browse/go_detail.cgi?gene_id=[example_id]",
      "abbreviation" : "PAMGO_VMD",
      "generic_url" : "http://phytophthora.vbi.vt.edu",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null
   },
   "jcvi_egad" : {
      "url_syntax" : "http://cmr.jcvi.org/cgi-bin/CMR/EgadSearch.cgi?search_string=[example_id]",
      "url_example" : "http://cmr.jcvi.org/cgi-bin/CMR/EgadSearch.cgi?search_string=74462",
      "datatype" : null,
      "generic_url" : "http://cmr.jcvi.org/",
      "abbreviation" : "JCVI_EGAD",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "name" : null,
      "example_id" : "JCVI_EGAD:74462",
      "database" : "JCVI CMR Egad",
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null
   },
   "pamgo_mgg" : {
      "entity_type" : "BET:0000000 ! entity",
      "database" : "Magnaporthe grisea database",
      "example_id" : "PAMGO_MGG:MGG_05132",
      "name" : null,
      "fullname" : null,
      "description" : "Magnaporthe grisea database at North Carolina State University; member of PAMGO Interest Group",
      "abbreviation" : "PAMGO_MGG",
      "generic_url" : "http://scotland.fgl.ncsu.edu/smeng/GoAnnotationMagnaporthegrisea.html",
      "datatype" : null,
      "url_example" : "http://scotland.fgl.ncsu.edu/cgi-bin/adHocQuery.cgi?adHocQuery_dbName=smeng_goannotation&Action=Data&QueryName=Functional+Categorization+of+MGG+GO+Annotation&P_KeyWord=MGG_05132",
      "url_syntax" : "http://scotland.fgl.ncsu.edu/cgi-bin/adHocQuery.cgi?adHocQuery_dbName=smeng_goannotation&Action=Data&QueryName=Functional+Categorization+of+MGG+GO+Annotation&P_KeyWord=[example_id]",
      "id" : null,
      "uri_prefix" : null,
      "object" : null
   },
   "so" : {
      "abbreviation" : "SO",
      "generic_url" : "http://sequenceontology.org/",
      "datatype" : null,
      "url_example" : "http://song.sourceforge.net/SOterm_tables.html#SO:0000195",
      "url_syntax" : "http://song.sourceforge.net/SOterm_tables.html#SO:[example_id]",
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "entity_type" : "SO:0000110 ! sequence feature",
      "example_id" : "SO:0000195",
      "database" : "Sequence Ontology",
      "name" : null,
      "fullname" : null,
      "local_id_syntax" : "\\d{7}"
   },
   "unimod" : {
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_syntax" : "http://www.unimod.org/modifications_view.php?editid1=[example_id]",
      "url_example" : "http://www.unimod.org/modifications_view.php?editid1=1287",
      "datatype" : null,
      "generic_url" : "http://www.unimod.org/",
      "abbreviation" : "UniMod",
      "description" : "protein modifications for mass spectrometry",
      "fullname" : null,
      "example_id" : "UniMod:1287",
      "name" : null,
      "database" : "UniMod",
      "entity_type" : "BET:0000000 ! entity"
   },
   "cgen" : {
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "name" : null,
      "example_id" : "CGEN:PrID131022",
      "database" : "Compugen Gene Ontology Gene Association Data",
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "generic_url" : "http://www.cgen.com/",
      "abbreviation" : "CGEN",
      "datatype" : null,
      "url_example" : null,
      "url_syntax" : null
   },
   "casref" : {
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "abbreviation" : "CASREF",
      "generic_url" : "http://research.calacademy.org/research/ichthyology/catalog/fishcatsearch.html",
      "url_syntax" : "http://research.calacademy.org/research/ichthyology/catalog/getref.asp?id=[example_id]",
      "url_example" : "http://research.calacademy.org/research/ichthyology/catalog/getref.asp?id=2031",
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "CASREF:2031",
      "database" : "Catalog of Fishes publications database",
      "name" : null
   },
   "pfam" : {
      "local_id_syntax" : "PF[0-9]{5}",
      "fullname" : null,
      "description" : "Pfam is a collection of protein families represented by sequence alignments and hidden Markov models (HMMs)",
      "example_id" : "Pfam:PF00046",
      "database" : "Pfam database of protein families",
      "name" : null,
      "entity_type" : "SO:0000839 ! polypeptide region",
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_syntax" : "http://www.sanger.ac.uk/cgi-bin/Pfam/getacc?[example_id]",
      "url_example" : "http://www.sanger.ac.uk/cgi-bin/Pfam/getacc?PF00046",
      "generic_url" : "http://www.sanger.ac.uk/Software/Pfam/",
      "abbreviation" : "Pfam",
      "datatype" : null
   },
   "gr_ref" : {
      "name" : null,
      "example_id" : "GR_REF:659",
      "database" : "Gramene",
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null,
      "url_syntax" : "http://www.gramene.org/db/literature/pub_search?ref_id=[example_id]",
      "url_example" : "http://www.gramene.org/db/literature/pub_search?ref_id=659",
      "abbreviation" : "GR_REF",
      "generic_url" : "http://www.gramene.org/",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null
   },
   "tigr_genprop" : {
      "abbreviation" : "TIGR_GenProp",
      "generic_url" : "http://cmr.jcvi.org/",
      "datatype" : null,
      "url_syntax" : "http://cmr.jcvi.org/cgi-bin/CMR/shared/GenomePropDefinition.cgi?prop_acc=[example_id]",
      "url_example" : "http://cmr.jcvi.org/cgi-bin/CMR/shared/GenomePropDefinition.cgi?prop_acc=GenProp0120",
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "entity_type" : "GO:0008150 ! biological_process",
      "database" : "Genome Properties database at the J. Craig Venter Institute",
      "name" : null,
      "example_id" : "JCVI_GenProp:GenProp0120",
      "fullname" : null,
      "local_id_syntax" : "GenProp[0-9]{4}"
   },
   "ncbitaxon" : {
      "abbreviation" : "NCBITaxon",
      "generic_url" : "http://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/",
      "datatype" : null,
      "url_syntax" : "http://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi?id=[example_id]",
      "url_example" : "http://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi?id=3702",
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "entity_type" : "BET:0000000 ! entity",
      "database" : "NCBI Taxonomy",
      "example_id" : "taxon:7227",
      "name" : null,
      "fullname" : null
   },
   "ensemblfungi" : {
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_example" : "http://www.ensemblgenomes.org/id/YOR197W",
      "url_syntax" : "http://www.ensemblgenomes.org/id/[example_ID]",
      "abbreviation" : "EnsemblFungi",
      "generic_url" : "http://fungi.ensembl.org/",
      "datatype" : null,
      "fullname" : null,
      "name" : null,
      "example_id" : "EnsemblFungi:YOR197W",
      "database" : "Ensembl Fungi, the Ensembl Genomes database for accessing fungal genome data",
      "entity_type" : "SO:0000704 ! gene"
   },
   "ecogene_g" : {
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_syntax" : null,
      "url_example" : null,
      "generic_url" : "http://www.ecogene.org/",
      "abbreviation" : "ECOGENE_G",
      "datatype" : null,
      "fullname" : null,
      "example_id" : "ECOGENE_G:deoC",
      "database" : "EcoGene Database of Escherichia coli Sequence and Function",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity"
   },
   "um-bbd_pathwayid" : {
      "fullname" : null,
      "example_id" : "UM-BBD_pathwayID:acr",
      "name" : null,
      "database" : "University of Minnesota Biocatalysis/Biodegradation Database",
      "entity_type" : "BET:0000000 ! entity",
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_syntax" : "http://umbbd.msi.umn.edu/[example_id]/[example_id]_map.html",
      "url_example" : "http://umbbd.msi.umn.edu/acr/acr_map.html",
      "generic_url" : "http://umbbd.msi.umn.edu/",
      "abbreviation" : "UM-BBD_pathwayID",
      "datatype" : null
   },
   "kegg_ligand" : {
      "local_id_syntax" : "C\\d{5}",
      "fullname" : null,
      "example_id" : "KEGG_LIGAND:C00577",
      "database" : "KEGG LIGAND Database",
      "name" : null,
      "entity_type" : "CHEBI:24431 ! chemical entity",
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_example" : "http://www.genome.jp/dbget-bin/www_bget?cpd:C00577",
      "url_syntax" : "http://www.genome.jp/dbget-bin/www_bget?cpd:[example_id]",
      "abbreviation" : "KEGG_LIGAND",
      "generic_url" : "http://www.genome.ad.jp/kegg/docs/upd_ligand.html",
      "datatype" : null
   },
   "mitre" : {
      "fullname" : null,
      "example_id" : null,
      "name" : null,
      "database" : "The MITRE Corporation",
      "entity_type" : "BET:0000000 ! entity",
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_syntax" : null,
      "url_example" : null,
      "generic_url" : "http://www.mitre.org/",
      "abbreviation" : "MITRE",
      "datatype" : null
   },
   "ecoliwiki" : {
      "description" : "EcoliHub\\'s subsystem for community annotation of E. coli K-12",
      "fullname" : null,
      "local_id_syntax" : "[A-Za-z]{3,4}",
      "entity_type" : "SO:0000704 ! gene",
      "example_id" : null,
      "database" : "EcoliWiki from EcoliHub",
      "name" : null,
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "generic_url" : "http://ecoliwiki.net/",
      "abbreviation" : "EcoliWiki",
      "url_syntax" : null,
      "url_example" : null
   },
   "pharmgkb" : {
      "database" : "Pharmacogenetics and Pharmacogenomics Knowledge Base",
      "example_id" : "PharmGKB:PA267",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null,
      "url_example" : "http://www.pharmgkb.org/do/serve?objId=PA267",
      "url_syntax" : "http://www.pharmgkb.org/do/serve?objId=[example_id]",
      "datatype" : null,
      "generic_url" : "http://www.pharmgkb.org",
      "abbreviation" : "PharmGKB",
      "object" : null,
      "uri_prefix" : null,
      "id" : null
   },
   "panther" : {
      "name" : null,
      "example_id" : "PANTHER:PTHR11455",
      "database" : "Protein ANalysis THrough Evolutionary Relationships Classification System",
      "entity_type" : "NCIT:C20130 ! protein family",
      "local_id_syntax" : "PTN[0-9]{9}|PTHR[0-9]{5}_[A-Z0-9]+",
      "fullname" : null,
      "url_example" : "http://www.pantherdb.org/panther/lookupId.jsp?id=PTHR10000",
      "url_syntax" : "http://www.pantherdb.org/panther/lookupId.jsp?id=[example_id]",
      "abbreviation" : "PANTHER",
      "generic_url" : "http://www.pantherdb.org/",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null
   },
   "wbbt" : {
      "example_id" : "WBbt:0005733",
      "database" : "C. elegans gross anatomy",
      "name" : null,
      "entity_type" : "UBERON:0001062 ! metazoan anatomical entity",
      "local_id_syntax" : "[0-9]{7}",
      "fullname" : null,
      "url_syntax" : null,
      "url_example" : null,
      "datatype" : null,
      "abbreviation" : "WBbt",
      "generic_url" : "http://www.wormbase.org/",
      "object" : null,
      "uri_prefix" : null,
      "id" : null
   },
   "bfo" : {
      "example_id" : "BFO:0000066",
      "database" : "Basic Formal Ontology",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "description" : "An upper ontology used by Open Bio Ontologies (OBO) Foundry. BFO contains upper-level classes as well as core relations such as part_of (BFO_0000050)",
      "fullname" : null,
      "url_syntax" : "http://purl.obolibrary.org/obo/BFO_[example_id]",
      "url_example" : "http://purl.obolibrary.org/obo/BFO_0000066",
      "datatype" : null,
      "generic_url" : "http://purl.obolibrary.org/obo/bfo",
      "abbreviation" : "BFO",
      "object" : null,
      "uri_prefix" : null,
      "id" : null
   },
   "issn" : {
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "generic_url" : "http://www.issn.org/",
      "abbreviation" : "ISSN",
      "url_example" : null,
      "url_syntax" : null,
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "database" : "International Standard Serial Number",
      "example_id" : "ISSN:1234-1231",
      "name" : null
   },
   "vmd" : {
      "entity_type" : "BET:0000000 ! entity",
      "database" : "Virginia Bioinformatics Institute Microbial Database",
      "example_id" : "VMD:109198",
      "name" : null,
      "fullname" : null,
      "datatype" : null,
      "generic_url" : "http://phytophthora.vbi.vt.edu",
      "abbreviation" : "VMD",
      "url_example" : "http://vmd.vbi.vt.edu/cgi-bin/browse/browserDetail_new.cgi?gene_id=109198",
      "url_syntax" : "http://vmd.vbi.vt.edu/cgi-bin/browse/browserDetail_new.cgi?gene_id=[example_id]",
      "id" : null,
      "object" : null,
      "uri_prefix" : null
   },
   "ncbi_gi" : {
      "url_syntax" : "http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?val=[example_id]",
      "url_example" : "http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?val=113194944",
      "abbreviation" : "NCBI_gi",
      "generic_url" : "http://www.ncbi.nlm.nih.gov/",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "name" : null,
      "example_id" : "NCBI_gi:113194944",
      "database" : "NCBI databases",
      "entity_type" : "SO:0000704 ! gene",
      "local_id_syntax" : "[0-9]{6,}",
      "fullname" : null
   },
   "tigr_tigrfams" : {
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "generic_url" : "http://search.jcvi.org/",
      "abbreviation" : "TIGR_TIGRFAMS",
      "url_syntax" : "http://search.jcvi.org/search?p&q=[example_id]",
      "url_example" : "http://search.jcvi.org/search?p&q=TIGR00254",
      "fullname" : null,
      "entity_type" : "SO:0000839 ! polypeptide region",
      "name" : null,
      "example_id" : "JCVI_TIGRFAMS:TIGR00254",
      "database" : "TIGRFAMs HMM collection at the J. Craig Venter Institute"
   },
   "jcvi_medtr" : {
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "abbreviation" : "JCVI_Medtr",
      "generic_url" : "http://medicago.jcvi.org/cgi-bin/medicago/overview.cgi",
      "url_example" : "http://medicago.jcvi.org/cgi-bin/medicago/search/shared/ORF_infopage.cgi?orf=Medtr5g024510",
      "url_syntax" : "http://medicago.jcvi.org/cgi-bin/medicago/search/shared/ORF_infopage.cgi?orf=[example_id]",
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "database" : "Medicago truncatula genome database at the J. Craig Venter Institute",
      "example_id" : "JCVI_Medtr:Medtr5g024510",
      "name" : null
   },
   "ncbi" : {
      "generic_url" : "http://www.ncbi.nlm.nih.gov/",
      "abbreviation" : "NCBI",
      "datatype" : null,
      "url_example" : null,
      "url_syntax" : null,
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : null,
      "name" : null,
      "database" : "National Center for Biotechnology Information",
      "fullname" : null
   },
   "aspgd_ref" : {
      "example_id" : "AspGD_REF:90",
      "name" : null,
      "database" : "Aspergillus Genome Database",
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null,
      "url_example" : "http://www.aspergillusgenome.org/cgi-bin/reference/reference.pl?dbid=90",
      "url_syntax" : "http://www.aspergillusgenome.org/cgi-bin/reference/reference.pl?dbid=[example_id]",
      "datatype" : null,
      "generic_url" : "http://www.aspergillusgenome.org/",
      "abbreviation" : "AspGD_REF",
      "object" : null,
      "uri_prefix" : null,
      "id" : null
   },
   "rhea" : {
      "description" : "Rhea is a freely available, manually annotated database of chemical reactions created in collaboration with the Swiss Institute of Bioinformatics (SIB).",
      "fullname" : null,
      "example_id" : "RHEA:25811",
      "name" : null,
      "database" : "Rhea, the Annotated Reactions Database",
      "entity_type" : "BET:0000000 ! entity",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_example" : "http://www.ebi.ac.uk/rhea/reaction.xhtml?id=25811",
      "url_syntax" : "http://www.ebi.ac.uk/rhea/reaction.xhtml?id=[example_id]",
      "datatype" : null,
      "generic_url" : "http://www.ebi.ac.uk/rhea/",
      "abbreviation" : "RHEA"
   },
   "prints" : {
      "fullname" : null,
      "entity_type" : "SO:0000839 ! polypeptide region",
      "example_id" : "PRINTS:PR00025",
      "database" : "PRINTS compendium of protein fingerprints",
      "name" : null,
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "generic_url" : "http://www.bioinf.manchester.ac.uk/dbbrowser/PRINTS/",
      "abbreviation" : "PRINTS",
      "url_example" : "http://www.bioinf.manchester.ac.uk/cgi-bin/dbbrowser/sprint/searchprintss.cgi?display_opts=Prints&category=None&queryform=false&regexpr=off&prints_accn=PR00025",
      "url_syntax" : "http://www.bioinf.manchester.ac.uk/cgi-bin/dbbrowser/sprint/searchprintss.cgi?display_opts=Prints&category=None&queryform=false&regexpr=off&prints_accn=[example_id]"
   },
   "cl" : {
      "url_example" : "http://purl.obolibrary.org/obo/CL_0000041",
      "url_syntax" : "http://purl.obolibrary.org/obo/CL_[example_id]",
      "abbreviation" : "CL",
      "generic_url" : "http://cellontology.org",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "example_id" : "CL:0000041",
      "name" : null,
      "database" : "Cell Type Ontology",
      "entity_type" : "GO:0005623 ! cell",
      "local_id_syntax" : "[0-9]{7}",
      "fullname" : null
   },
   "doi" : {
      "example_id" : "DOI:10.1016/S0963-9969(99)00021-6",
      "name" : null,
      "database" : "Digital Object Identifier",
      "entity_type" : "BET:0000000 ! entity",
      "local_id_syntax" : "10\\.[0-9]+\\/.*",
      "fullname" : null,
      "url_example" : "http://dx.doi.org/DOI:10.1016/S0963-9969(99)00021-6",
      "url_syntax" : "http://dx.doi.org/DOI:[example_id]",
      "datatype" : null,
      "generic_url" : "http://dx.doi.org/",
      "abbreviation" : "DOI",
      "object" : null,
      "uri_prefix" : null,
      "id" : null
   },
   "mengo" : {
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : null,
      "database" : "Microbial ENergy processes Gene Ontology Project",
      "name" : null,
      "fullname" : null,
      "abbreviation" : "MENGO",
      "generic_url" : "http://mengo.vbi.vt.edu/",
      "datatype" : null,
      "url_example" : null,
      "url_syntax" : null,
      "id" : null,
      "uri_prefix" : null,
      "object" : null
   },
   "echobase" : {
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "abbreviation" : "EchoBASE",
      "generic_url" : "http://www.ecoli-york.org/",
      "datatype" : null,
      "url_syntax" : "http://www.biolws1.york.ac.uk/echobase/Gene.cfm?recordID=[example_id]",
      "url_example" : "http://www.biolws1.york.ac.uk/echobase/Gene.cfm?recordID=EB0231",
      "fullname" : null,
      "local_id_syntax" : "EB[0-9]{4}",
      "entity_type" : "SO:0000704 ! gene",
      "name" : null,
      "example_id" : "EchoBASE:EB0231",
      "database" : "EchoBASE post-genomic database for Escherichia coli"
   },
   "mim" : {
      "generic_url" : "http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?db=OMIM",
      "abbreviation" : "MIM",
      "datatype" : null,
      "url_syntax" : "http://omim.org/entry/[example_id]",
      "url_example" : "http://omim.org/entry/190198",
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "entity_type" : "BET:0000000 ! entity",
      "database" : "Mendelian Inheritance in Man",
      "name" : null,
      "example_id" : "OMIM:190198",
      "fullname" : null
   },
   "pompep" : {
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_example" : null,
      "url_syntax" : null,
      "datatype" : null,
      "abbreviation" : "Pompep",
      "generic_url" : "ftp://ftp.sanger.ac.uk/pub/yeast/pombe/Protein_data/",
      "fullname" : null,
      "database" : "Schizosaccharomyces pombe protein data",
      "example_id" : "Pompep:SPAC890.04C",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity"
   },
   "pdb" : {
      "fullname" : null,
      "local_id_syntax" : "[A-Za-z0-9]{4}",
      "entity_type" : "PR:000000001 ! protein",
      "example_id" : "PDB:1A4U",
      "name" : null,
      "database" : "Protein Data Bank",
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "abbreviation" : "PDB",
      "generic_url" : "http://www.rcsb.org/pdb/",
      "url_example" : "http://www.rcsb.org/pdb/cgi/explore.cgi?pdbId=1A4U",
      "url_syntax" : "http://www.rcsb.org/pdb/cgi/explore.cgi?pdbId=[example_id]"
   },
   "jcvi" : {
      "database" : "J. Craig Venter Institute",
      "example_id" : null,
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null,
      "url_syntax" : null,
      "url_example" : null,
      "datatype" : null,
      "abbreviation" : "JCVI",
      "generic_url" : "http://www.jcvi.org/",
      "object" : null,
      "uri_prefix" : null,
      "id" : null
   },
   "kegg_pathway" : {
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "KEGG_PATHWAY:ot00020",
      "database" : "KEGG Pathways Database",
      "name" : null,
      "fullname" : null,
      "abbreviation" : "KEGG_PATHWAY",
      "generic_url" : "http://www.genome.jp/kegg/pathway.html",
      "datatype" : null,
      "url_example" : "http://www.genome.jp/dbget-bin/www_bget?path:ot00020",
      "url_syntax" : "http://www.genome.jp/dbget-bin/www_bget?path:[example_id]",
      "id" : null,
      "uri_prefix" : null,
      "object" : null
   },
   "prow" : {
      "entity_type" : "BET:0000000 ! entity",
      "name" : null,
      "example_id" : null,
      "database" : "Protein Reviews on the Web",
      "fullname" : null,
      "generic_url" : "http://www.ncbi.nlm.nih.gov/prow/",
      "abbreviation" : "PROW",
      "datatype" : null,
      "url_syntax" : null,
      "url_example" : null,
      "id" : null,
      "uri_prefix" : null,
      "object" : null
   },
   "cgsc" : {
      "fullname" : null,
      "example_id" : "CGSC:rbsK",
      "name" : null,
      "database" : "CGSC",
      "entity_type" : "BET:0000000 ! entity",
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_syntax" : null,
      "url_example" : "http://cgsc.biology.yale.edu/Site.php?ID=315",
      "generic_url" : "http://cgsc.biology.yale.edu/",
      "abbreviation" : "CGSC",
      "datatype" : null
   },
   "enzyme" : {
      "fullname" : null,
      "database" : "Swiss Institute of Bioinformatics enzyme database",
      "example_id" : "ENZYME:EC 1.1.1.1",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_example" : "http://www.expasy.ch/cgi-bin/nicezyme.pl?1.1.1.1",
      "url_syntax" : "http://www.expasy.ch/cgi-bin/nicezyme.pl?[example_id]",
      "datatype" : null,
      "abbreviation" : "ENZYME",
      "generic_url" : "http://www.expasy.ch/"
   },
   "tigr_egad" : {
      "entity_type" : "PR:000000001 ! protein",
      "name" : null,
      "database" : "EGAD database at the J. Craig Venter Institute",
      "example_id" : "JCVI_CMR:VCA0557",
      "fullname" : null,
      "generic_url" : "http://cmr.jcvi.org/",
      "abbreviation" : "TIGR_EGAD",
      "datatype" : null,
      "url_syntax" : "http://cmr.jcvi.org/cgi-bin/CMR/shared/GenePage.cgi?locus=[example_id]",
      "url_example" : "http://cmr.jcvi.org/cgi-bin/CMR/shared/GenePage.cgi?locus=VCA0557",
      "id" : null,
      "uri_prefix" : null,
      "object" : null
   },
   "um-bbd_ruleid" : {
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_syntax" : "http://umbbd.msi.umn.edu/servlets/rule.jsp?rule=[example_id]",
      "url_example" : "http://umbbd.msi.umn.edu/servlets/rule.jsp?rule=bt0330",
      "datatype" : null,
      "abbreviation" : "UM-BBD_ruleID",
      "generic_url" : "http://umbbd.msi.umn.edu/",
      "fullname" : null,
      "database" : "University of Minnesota Biocatalysis/Biodegradation Database",
      "example_id" : "UM-BBD_ruleID:bt0330",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity"
   },
   "spd" : {
      "url_syntax" : "http://www.riken.jp/SPD/[example_id].html",
      "url_example" : "http://www.riken.jp/SPD/05/05F01.html",
      "datatype" : null,
      "generic_url" : "http://www.riken.jp/SPD/",
      "abbreviation" : "SPD",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "database" : "Schizosaccharomyces pombe Postgenome Database at RIKEN; includes Orfeome Localisation data",
      "example_id" : "SPD:05/05F01",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "local_id_syntax" : "[0-9]{2}/[0-9]{2}[A-Z][0-9]{2}",
      "fullname" : null
   },
   "metacyc" : {
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_example" : "http://biocyc.org/META/NEW-IMAGE?type=NIL&object=GLUTDEG-PWY",
      "url_syntax" : "http://biocyc.org/META/NEW-IMAGE?type=NIL&object=[example_id]",
      "datatype" : null,
      "generic_url" : "http://metacyc.org/",
      "abbreviation" : "MetaCyc",
      "fullname" : null,
      "name" : null,
      "example_id" : "MetaCyc:GLUTDEG-PWY",
      "database" : "Metabolic Encyclopedia of metabolic and other pathways",
      "entity_type" : "BET:0000000 ! entity"
   },
   "maizegdb_locus" : {
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_example" : "http://www.maizegdb.org/cgi-bin/displaylocusresults.cgi?term=ZmPK1",
      "url_syntax" : "http://www.maizegdb.org/cgi-bin/displaylocusresults.cgi?term=[example_id]",
      "abbreviation" : "MaizeGDB_Locus",
      "generic_url" : "http://www.maizegdb.org",
      "datatype" : null,
      "local_id_syntax" : "[A-Za-z][A-Za-z0-9]*",
      "fullname" : null,
      "database" : "MaizeGDB",
      "example_id" : "MaizeGDB_Locus:ZmPK1",
      "name" : null,
      "entity_type" : "SO:0000704 ! gene"
   },
   "pubchem_compound" : {
      "entity_type" : "CHEBI:24431 ! chemical entity",
      "example_id" : "PubChem_Compound:2244",
      "database" : "NCBI PubChem database of chemical structures",
      "name" : null,
      "fullname" : null,
      "local_id_syntax" : "[0-9]+",
      "abbreviation" : "PubChem_Compound",
      "generic_url" : "http://pubchem.ncbi.nlm.nih.gov/",
      "datatype" : null,
      "url_syntax" : "http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?CMD=search&DB=pccompound&term=[example_id]",
      "url_example" : "http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?CMD=search&DB=pccompound&term=2244",
      "id" : null,
      "uri_prefix" : null,
      "object" : null
   },
   "goc" : {
      "datatype" : null,
      "generic_url" : "http://www.geneontology.org/",
      "abbreviation" : "GOC",
      "url_example" : null,
      "url_syntax" : null,
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "entity_type" : "BET:0000000 ! entity",
      "name" : null,
      "example_id" : null,
      "database" : "Gene Ontology Consortium",
      "fullname" : null
   },
   "pir" : {
      "example_id" : "PIR:I49499",
      "name" : null,
      "database" : "Protein Information Resource",
      "entity_type" : "PR:000000001 ! protein",
      "local_id_syntax" : "[A-Z]{1}[0-9]{5}",
      "fullname" : null,
      "url_syntax" : "http://pir.georgetown.edu/cgi-bin/pirwww/nbrfget?uid=[example_id]",
      "url_example" : "http://pir.georgetown.edu/cgi-bin/pirwww/nbrfget?uid=I49499",
      "generic_url" : "http://pir.georgetown.edu/",
      "abbreviation" : "PIR",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null
   },
   "uniprotkb-subcell" : {
      "datatype" : null,
      "generic_url" : "http://www.uniprot.org/locations/",
      "abbreviation" : "UniProtKB-SubCell",
      "url_example" : "http://www.uniprot.org/locations/SL-0012",
      "url_syntax" : "http://www.uniprot.org/locations/[example_id]",
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "UniProtKB-SubCell:SL-0012",
      "database" : "UniProt Knowledgebase Subcellular Location vocabulary",
      "name" : null,
      "fullname" : null
   },
   "ecogene" : {
      "datatype" : null,
      "abbreviation" : "ECOGENE",
      "generic_url" : "http://www.ecogene.org/",
      "url_example" : "http://www.ecogene.org/geneInfo.php?eg_id=EG10818",
      "url_syntax" : "http://www.ecogene.org/geneInfo.php?eg_id=[example_id]",
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "entity_type" : "SO:0000704 ! gene",
      "example_id" : "ECOGENE:EG10818",
      "database" : "EcoGene Database of Escherichia coli Sequence and Function",
      "name" : null,
      "fullname" : null,
      "local_id_syntax" : "EG[0-9]{5}"
   },
   "jcvi_tigrfams" : {
      "entity_type" : "SO:0000839 ! polypeptide region",
      "example_id" : "JCVI_TIGRFAMS:TIGR00254",
      "database" : "TIGRFAMs HMM collection at the J. Craig Venter Institute",
      "name" : null,
      "fullname" : null,
      "datatype" : null,
      "generic_url" : "http://search.jcvi.org/",
      "abbreviation" : "JCVI_TIGRFAMS",
      "url_syntax" : "http://search.jcvi.org/search?p&q=[example_id]",
      "url_example" : "http://search.jcvi.org/search?p&q=TIGR00254",
      "id" : null,
      "object" : null,
      "uri_prefix" : null
   },
   "pato" : {
      "name" : null,
      "example_id" : "PATO:0001420",
      "database" : "Phenotypic quality ontology",
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null,
      "url_example" : null,
      "url_syntax" : null,
      "datatype" : null,
      "abbreviation" : "PATO",
      "generic_url" : "http://www.bioontology.org/wiki/index.php/PATO:Main_Page",
      "object" : null,
      "uri_prefix" : null,
      "id" : null
   },
   "genedb" : {
      "datatype" : null,
      "abbreviation" : "GeneDB",
      "generic_url" : "http://www.genedb.org/gene/",
      "url_syntax" : "http://www.genedb.org/gene/[example_id]",
      "url_example" : "http://www.genedb.org/gene/PF3D7_1467300",
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "entity_type" : "SO:0000704 ! gene",
      "name" : null,
      "example_id" : "PF3D7_1467300",
      "database" : "GeneDB",
      "fullname" : null,
      "local_id_syntax" : "((LmjF|LinJ|LmxM)\\.[0-9]{2}\\.[0-9]{4})|(PF3D7_[0-9]{7})|(Tb[0-9]+\\.[A-Za-z0-9]+\\.[0-9]+)|(TcCLB\\.[0-9]{6}\\.[0-9]+)"
   },
   "apidb_plasmodb" : {
      "fullname" : null,
      "database" : "PlasmoDB Plasmodium Genome Resource",
      "example_id" : "ApiDB_PlasmoDB:PF11_0344",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_syntax" : "http://www.plasmodb.org/gene/[example_id]",
      "url_example" : "http://www.plasmodb.org/gene/PF11_0344",
      "generic_url" : "http://plasmodb.org/",
      "abbreviation" : "ApiDB_PlasmoDB",
      "datatype" : null
   },
   "cbs" : {
      "fullname" : null,
      "name" : null,
      "example_id" : "CBS:TMHMM",
      "database" : "Center for Biological Sequence Analysis",
      "entity_type" : "BET:0000000 ! entity",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_example" : "http://www.cbs.dtu.dk/services/[example_id]/",
      "url_syntax" : null,
      "datatype" : null,
      "abbreviation" : "CBS",
      "generic_url" : "http://www.cbs.dtu.dk/"
   },
   "tigr" : {
      "fullname" : null,
      "name" : null,
      "database" : "J. Craig Venter Institute",
      "example_id" : null,
      "entity_type" : "BET:0000000 ! entity",
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_example" : null,
      "url_syntax" : null,
      "generic_url" : "http://www.jcvi.org/",
      "abbreviation" : "TIGR",
      "datatype" : null
   },
   "cgdid" : {
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_example" : "http://www.candidagenome.org/cgi-bin/locus.pl?dbid=CAL0005516",
      "url_syntax" : "http://www.candidagenome.org/cgi-bin/locus.pl?dbid=[example_id]",
      "datatype" : null,
      "abbreviation" : "CGDID",
      "generic_url" : "http://www.candidagenome.org/",
      "local_id_syntax" : "(CAL|CAF)[0-9]{7}",
      "fullname" : null,
      "name" : null,
      "database" : "Candida Genome Database",
      "example_id" : "CGD:CAL0005516",
      "entity_type" : "SO:0000704 ! gene"
   },
   "broad" : {
      "example_id" : null,
      "name" : null,
      "database" : "Broad Institute",
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null,
      "url_syntax" : null,
      "url_example" : null,
      "datatype" : null,
      "generic_url" : "http://www.broad.mit.edu/",
      "abbreviation" : "Broad",
      "object" : null,
      "uri_prefix" : null,
      "id" : null
   },
   "ddb" : {
      "local_id_syntax" : "DDB_G[0-9]{7}",
      "fullname" : null,
      "example_id" : "dictyBase:DDB_G0277859",
      "database" : "dictyBase",
      "name" : null,
      "entity_type" : "SO:0000704 ! gene",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_syntax" : "http://dictybase.org/gene/[example_id]",
      "url_example" : "http://dictybase.org/gene/DDB_G0277859",
      "datatype" : null,
      "abbreviation" : "DDB",
      "generic_url" : "http://dictybase.org"
   },
   "fypo" : {
      "example_id" : "FYPO:0000001",
      "database" : "Fission Yeast Phenotype Ontology",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "local_id_syntax" : "\\d{7}",
      "fullname" : null,
      "url_example" : null,
      "url_syntax" : null,
      "abbreviation" : "FYPO",
      "generic_url" : "http://www.pombase.org/",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null
   },
   "poc" : {
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_syntax" : null,
      "url_example" : null,
      "generic_url" : "http://www.plantontology.org/",
      "abbreviation" : "POC",
      "datatype" : null,
      "fullname" : null,
      "example_id" : null,
      "name" : null,
      "database" : "Plant Ontology Consortium",
      "entity_type" : "BET:0000000 ! entity"
   },
   "go" : {
      "fullname" : null,
      "local_id_syntax" : "\\d{7}",
      "entity_type" : "GO:0032991 ! macromolecular complex",
      "example_id" : "GO:0004352",
      "name" : null,
      "database" : "Gene Ontology Database",
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "abbreviation" : "GO",
      "generic_url" : "http://amigo.geneontology.org/",
      "url_syntax" : "http://amigo.geneontology.org/amigo/term/GO:[example_id]",
      "url_example" : "http://amigo.geneontology.org/amigo/term/GO:0004352"
   },
   "eck" : {
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_syntax" : "http://www.ecogene.org/geneInfo.php?eck_id=[example_id]",
      "url_example" : "http://www.ecogene.org/geneInfo.php?eck_id=ECK3746",
      "datatype" : null,
      "abbreviation" : "ECK",
      "generic_url" : "http://www.ecogene.org/",
      "local_id_syntax" : "ECK[0-9]{4}",
      "fullname" : null,
      "database" : "EcoGene Database of Escherichia coli Sequence and Function",
      "example_id" : "ECK:ECK3746",
      "name" : null,
      "entity_type" : "SO:0000704 ! gene"
   },
   "sabio-rk" : {
      "url_example" : "http://sabio.villa-bosch.de/reacdetails.jsp?reactid=1858",
      "url_syntax" : "http://sabio.villa-bosch.de/reacdetails.jsp?reactid=[example_id]",
      "datatype" : null,
      "generic_url" : "http://sabio.villa-bosch.de/",
      "abbreviation" : "SABIO-RK",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "database" : "SABIO Reaction Kinetics",
      "example_id" : "SABIO-RK:1858",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "description" : "The SABIO-RK (System for the Analysis of Biochemical Pathways - Reaction Kinetics) is a web-based application based on the SABIO relational database that contains information about biochemical reactions, their kinetic equations with their parameters, and the experimental conditions under which these parameters were measured.",
      "fullname" : null
   },
   "agbase" : {
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : null,
      "name" : null,
      "database" : "AgBase resource for functional analysis of agricultural plant and animal gene products",
      "fullname" : null,
      "generic_url" : "http://www.agbase.msstate.edu/",
      "abbreviation" : "AgBase",
      "datatype" : null,
      "url_example" : null,
      "url_syntax" : "http://www.agbase.msstate.edu/cgi-bin/getEntry.pl?db_pick=[ChickGO/MaizeGO]&uid=[example_id]",
      "id" : null,
      "uri_prefix" : null,
      "object" : null
   },
   "yeastfunc" : {
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "name" : null,
      "example_id" : null,
      "database" : "Yeast Function",
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "generic_url" : "http://func.med.harvard.edu/yeast/",
      "abbreviation" : "YeastFunc",
      "datatype" : null,
      "url_syntax" : null,
      "url_example" : null
   },
   "biosis" : {
      "url_example" : null,
      "url_syntax" : null,
      "datatype" : null,
      "abbreviation" : "BIOSIS",
      "generic_url" : "http://www.biosis.org/",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "name" : null,
      "example_id" : "BIOSIS:200200247281",
      "database" : "BIOSIS previews",
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null
   },
   "ntnu_sb" : {
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : null,
      "name" : null,
      "database" : "Norwegian University of Science and Technology, Systems Biology team",
      "fullname" : null,
      "generic_url" : "http://www.ntnu.edu/nt/systemsbiology",
      "abbreviation" : "NTNU_SB",
      "datatype" : null,
      "url_example" : null,
      "url_syntax" : null,
      "id" : null,
      "uri_prefix" : null,
      "object" : null
   },
   "subtilistg" : {
      "database" : "Bacillus subtilis Genome Sequence Project",
      "example_id" : "SUBTILISTG:accC",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null,
      "url_example" : null,
      "url_syntax" : null,
      "datatype" : null,
      "abbreviation" : "SUBTILISTG",
      "generic_url" : "http://genolist.pasteur.fr/SubtiList/",
      "object" : null,
      "uri_prefix" : null,
      "id" : null
   },
   "dflat" : {
      "url_syntax" : null,
      "url_example" : null,
      "datatype" : null,
      "abbreviation" : "DFLAT",
      "generic_url" : "http://bcb.cs.tufts.edu/dflat/",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "example_id" : null,
      "name" : null,
      "database" : "Developmental FunctionaL Annotation at Tufts",
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null
   },
   "sgn_ref" : {
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "SGN_ref:861",
      "name" : null,
      "database" : "Sol Genomics Network",
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "generic_url" : "http://www.sgn.cornell.edu/",
      "abbreviation" : "SGN_ref",
      "url_example" : "http://www.sgn.cornell.edu/chado/publication.pl?pub_id=861",
      "url_syntax" : "http://www.sgn.cornell.edu/chado/publication.pl?pub_id=[example_id]"
   },
   "rgd" : {
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "generic_url" : "http://rgd.mcw.edu/",
      "abbreviation" : "RGD",
      "url_syntax" : "http://rgd.mcw.edu/generalSearch/RgdSearch.jsp?quickSearch=1&searchKeyword=[example_id]",
      "url_example" : "http://rgd.mcw.edu/generalSearch/RgdSearch.jsp?quickSearch=1&searchKeyword=2004",
      "fullname" : null,
      "local_id_syntax" : "[0-9]{4,7}",
      "entity_type" : "SO:0000704 ! gene",
      "example_id" : "RGD:2004",
      "database" : "Rat Genome Database",
      "name" : null
   },
   "sp_sl" : {
      "url_example" : "http://www.uniprot.org/locations/SL-0012",
      "url_syntax" : "http://www.uniprot.org/locations/[example_id]",
      "generic_url" : "http://www.uniprot.org/locations/",
      "abbreviation" : "SP_SL",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "database" : "UniProt Knowledgebase Subcellular Location vocabulary",
      "name" : null,
      "example_id" : "UniProtKB-SubCell:SL-0012",
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null
   },
   "h-invdb" : {
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "name" : null,
      "example_id" : null,
      "database" : "H-invitational Database",
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "generic_url" : "http://www.h-invitational.jp/",
      "abbreviation" : "H-invDB",
      "datatype" : null,
      "url_example" : null,
      "url_syntax" : null
   },
   "sgn" : {
      "fullname" : null,
      "example_id" : "SGN:4476",
      "name" : null,
      "database" : "Sol Genomics Network",
      "entity_type" : "SO:0000704 ! gene",
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_example" : "http://www.sgn.cornell.edu/phenome/locus_display.pl?locus_id=4476",
      "url_syntax" : "http://www.sgn.cornell.edu/phenome/locus_display.pl?locus_id=[example_id]",
      "generic_url" : "http://www.sgn.cornell.edu/",
      "abbreviation" : "SGN",
      "datatype" : null
   },
   "pinc" : {
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_example" : null,
      "url_syntax" : null,
      "generic_url" : "http://www.proteome.com/",
      "abbreviation" : "PINC",
      "datatype" : null,
      "fullname" : null,
      "description" : "represents GO annotations created in 2001 for NCBI and extracted into UniProtKB-GOA from EntrezGene",
      "name" : null,
      "example_id" : null,
      "database" : "Proteome Inc.",
      "entity_type" : "BET:0000000 ! entity"
   },
   "bhf-ucl" : {
      "url_syntax" : null,
      "url_example" : null,
      "datatype" : null,
      "abbreviation" : "BHF-UCL",
      "generic_url" : "http://www.ucl.ac.uk/cardiovasculargeneontology/",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "example_id" : null,
      "name" : null,
      "database" : "Cardiovascular Gene Ontology Annotation Initiative",
      "entity_type" : "BET:0000000 ! entity",
      "description" : "The Cardiovascular Gene Ontology Annotation Initiative is supported by the British Heart Foundation (BHF) and located at University College London (UCL).",
      "fullname" : null
   },
   "imgt_ligm" : {
      "example_id" : "IMGT_LIGM:U03895",
      "database" : "ImMunoGeneTics database covering immunoglobulins and T-cell receptors",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "description" : "Database of immunoglobulins and T cell receptors from human and other vertebrates, with translation for fully annotated sequences.",
      "fullname" : null,
      "url_syntax" : null,
      "url_example" : null,
      "datatype" : null,
      "generic_url" : "http://imgt.cines.fr",
      "abbreviation" : "IMGT_LIGM",
      "object" : null,
      "uri_prefix" : null,
      "id" : null
   },
   "tgd_locus" : {
      "fullname" : null,
      "database" : "Tetrahymena Genome Database",
      "example_id" : "TGD_LOCUS:PDD1",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_example" : "http://db.ciliate.org/cgi-bin/locus.pl?locus=PDD1",
      "url_syntax" : "http://db.ciliate.org/cgi-bin/locus.pl?locus=[example_id]",
      "generic_url" : "http://www.ciliate.org/",
      "abbreviation" : "TGD_LOCUS",
      "datatype" : null
   },
   "nc-iubmb" : {
      "entity_type" : "BET:0000000 ! entity",
      "database" : "Nomenclature Committee of the International Union of Biochemistry and Molecular Biology",
      "example_id" : null,
      "name" : null,
      "fullname" : null,
      "datatype" : null,
      "generic_url" : "http://www.chem.qmw.ac.uk/iubmb/",
      "abbreviation" : "NC-IUBMB",
      "url_example" : null,
      "url_syntax" : null,
      "id" : null,
      "object" : null,
      "uri_prefix" : null
   },
   "interpro" : {
      "local_id_syntax" : "IPR\\d{6}",
      "fullname" : null,
      "example_id" : "InterPro:IPR000001",
      "database" : "InterPro database of protein domains and motifs",
      "name" : null,
      "entity_type" : "SO:0000839 ! polypeptide region",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_syntax" : "http://www.ebi.ac.uk/interpro/entry/[example_id]",
      "url_example" : "http://www.ebi.ac.uk/interpro/entry/IPR015421",
      "datatype" : null,
      "generic_url" : "http://www.ebi.ac.uk/interpro/",
      "abbreviation" : "INTERPRO"
   },
   "img" : {
      "fullname" : null,
      "example_id" : "IMG:640008772",
      "name" : null,
      "database" : "Integrated Microbial Genomes; JGI web site for genome annotation",
      "entity_type" : "BET:0000000 ! entity",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_example" : "http://img.jgi.doe.gov/cgi-bin/pub/main.cgi?section=GeneDetail&page=geneDetail&gene_oid=640008772",
      "url_syntax" : "http://img.jgi.doe.gov/cgi-bin/pub/main.cgi?section=GeneDetail&page=geneDetail&gene_oid=[example_id]",
      "datatype" : null,
      "abbreviation" : "IMG",
      "generic_url" : "http://img.jgi.doe.gov"
   },
   "hamap" : {
      "url_syntax" : "http://hamap.expasy.org/unirule/[example_id]",
      "url_example" : "http://hamap.expasy.org/unirule/MF_00131",
      "generic_url" : "http://hamap.expasy.org/",
      "abbreviation" : "HAMAP",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "example_id" : "HAMAP:MF_00031",
      "name" : null,
      "database" : "High-quality Automated and Manual Annotation of microbial Proteomes",
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null
   },
   "aspgd_locus" : {
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "database" : "Aspergillus Genome Database",
      "example_id" : "AspGD_LOCUS:AN10942",
      "name" : null,
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "abbreviation" : "AspGD_LOCUS",
      "generic_url" : "http://www.aspergillusgenome.org/",
      "datatype" : null,
      "url_example" : "http://www.aspergillusgenome.org/cgi-bin/locus.pl?locus=AN10942",
      "url_syntax" : "http://www.aspergillusgenome.org/cgi-bin/locus.pl?locus=[example_id]"
   },
   "biomdid" : {
      "url_syntax" : "http://www.ebi.ac.uk/compneur-srv/biomodels-main/publ-model.do?mid=[example_id]",
      "url_example" : "http://www.ebi.ac.uk/compneur-srv/biomodels-main/publ-model.do?mid=BIOMD0000000045",
      "datatype" : null,
      "generic_url" : "http://www.ebi.ac.uk/biomodels/",
      "abbreviation" : "BIOMDID",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "example_id" : "BIOMD:BIOMD0000000045",
      "database" : "BioModels Database",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null
   },
   "ensembl" : {
      "fullname" : null,
      "local_id_syntax" : "ENS[A-Z0-9]{10,17}",
      "entity_type" : "SO:0000673 ! transcript",
      "name" : null,
      "database" : "Ensembl database of automatically annotated genomic data",
      "example_id" : "ENSEMBL:ENSP00000265949",
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "generic_url" : "http://www.ensembl.org/",
      "abbreviation" : "Ensembl",
      "url_syntax" : "http://www.ensembl.org/id/[example_id]",
      "url_example" : "http://www.ensembl.org/id/ENSP00000265949"
   },
   "wbls" : {
      "database" : "C. elegans development",
      "example_id" : "WBls:0000010",
      "name" : null,
      "entity_type" : "WBls:0000075 ! nematoda life stage",
      "local_id_syntax" : "[0-9]{7}",
      "fullname" : null,
      "url_example" : null,
      "url_syntax" : null,
      "datatype" : null,
      "generic_url" : "http://www.wormbase.org/",
      "abbreviation" : "WBls",
      "object" : null,
      "uri_prefix" : null,
      "id" : null
   },
   "coriell" : {
      "url_example" : "http://ccr.coriell.org/Sections/Search/Sample_Detail.aspx?Ref=GM07892",
      "url_syntax" : "http://ccr.coriell.org/Sections/Search/Sample_Detail.aspx?Ref=[example_id]",
      "datatype" : null,
      "abbreviation" : "CORIELL",
      "generic_url" : "http://ccr.coriell.org/",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "database" : "Coriell Institute for Medical Research",
      "example_id" : "GM07892",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "description" : "The Coriell Cell Repositories provide essential research reagents to the scientific community by establishing, verifying, maintaining, and distributing cell cultures and DNA derived from cell cultures. These collections, supported by funds from the National Institutes of Health (NIH) and several foundations, are extensively utilized by research scientists around the world.",
      "fullname" : null
   },
   "taxon" : {
      "name" : null,
      "example_id" : "taxon:7227",
      "database" : "NCBI Taxonomy",
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null,
      "url_example" : "http://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi?id=3702",
      "url_syntax" : "http://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi?id=[example_id]",
      "abbreviation" : "taxon",
      "generic_url" : "http://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null
   },
   "smart" : {
      "fullname" : null,
      "name" : null,
      "example_id" : "SMART:SM00005",
      "database" : "Simple Modular Architecture Research Tool",
      "entity_type" : "SO:0000839 ! polypeptide region",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_example" : "http://smart.embl-heidelberg.de/smart/do_annotation.pl?BLAST=DUMMY&DOMAIN=SM00005",
      "url_syntax" : "http://smart.embl-heidelberg.de/smart/do_annotation.pl?BLAST=DUMMY&DOMAIN=[example_id]",
      "datatype" : null,
      "generic_url" : "http://smart.embl-heidelberg.de/",
      "abbreviation" : "SMART"
   },
   "tc" : {
      "fullname" : null,
      "entity_type" : "PR:000000001 ! protein",
      "example_id" : "TC:9.A.4.1.1",
      "name" : null,
      "database" : "Transport Protein Database",
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "generic_url" : "http://www.tcdb.org/",
      "abbreviation" : "TC",
      "datatype" : null,
      "url_example" : "http://www.tcdb.org/tcdb/index.php?tc=9.A.4.1.1",
      "url_syntax" : "http://www.tcdb.org/tcdb/index.php?tc=[example_id]"
   },
   "paint_ref" : {
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_example" : "http://www.geneontology.org/gene-associations/submission/paint/PTHR10046/PTHR10046.txt",
      "url_syntax" : "http://www.geneontology.org/gene-associations/submission/paint/[example_id]/[example_id].txt",
      "abbreviation" : "PAINT_REF",
      "generic_url" : "http://www.pantherdb.org/",
      "datatype" : null,
      "fullname" : null,
      "example_id" : "PAINT_REF:PTHR10046",
      "database" : "Phylogenetic Annotation INference Tool References",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity"
   },
   "nmpdr" : {
      "fullname" : null,
      "name" : null,
      "example_id" : "NMPDR:fig|306254.1.peg.183",
      "database" : "National Microbial Pathogen Data Resource",
      "entity_type" : "BET:0000000 ! entity",
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_syntax" : "http://www.nmpdr.org/linkin.cgi?id=[example_id]",
      "url_example" : "http://www.nmpdr.org/linkin.cgi?id=fig|306254.1.peg.183",
      "abbreviation" : "NMPDR",
      "generic_url" : "http://www.nmpdr.org",
      "datatype" : null
   },
   "jcvi_ref" : {
      "abbreviation" : "JCVI_REF",
      "generic_url" : "http://cmr.jcvi.org/",
      "datatype" : null,
      "url_syntax" : null,
      "url_example" : "http://cmr.jcvi.org/CMR/AnnotationSops.shtml",
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "entity_type" : "BET:0000000 ! entity",
      "name" : null,
      "example_id" : "JCVI_REF:GO_ref",
      "database" : "J. Craig Venter Institute",
      "fullname" : null
   },
   "tgd_ref" : {
      "datatype" : null,
      "generic_url" : "http://www.ciliate.org/",
      "abbreviation" : "TGD_REF",
      "url_syntax" : "http://db.ciliate.org/cgi-bin/reference/reference.pl?dbid=[example_id]",
      "url_example" : "http://db.ciliate.org/cgi-bin/reference/reference.pl?dbid=T000005818",
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "entity_type" : "BET:0000000 ! entity",
      "database" : "Tetrahymena Genome Database",
      "example_id" : "TGD_REF:T000005818",
      "name" : null,
      "fullname" : null
   },
   "uniprot" : {
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "abbreviation" : "UniProt",
      "generic_url" : "http://www.uniprot.org",
      "datatype" : null,
      "url_syntax" : "http://www.uniprot.org/uniprot/[example_id]",
      "url_example" : "http://www.uniprot.org/uniprot/P51587",
      "fullname" : null,
      "description" : "A central repository of protein sequence and function created by joining the information contained in Swiss-Prot, TrEMBL, and PIR database",
      "local_id_syntax" : "([OPQ][0-9][A-Z0-9]{3}[0-9]|[A-NR-Z]([0-9][A-Z][A-Z0-9]{2}){1,2}[0-9])((-[0-9]+)|:PRO_[0-9]{10}|:VAR_[0-9]{6}){0,1}",
      "entity_type" : "PR:000000001 ! protein",
      "database" : "Universal Protein Knowledgebase",
      "name" : null,
      "example_id" : "UniProtKB:P51587"
   },
   "ncbi_gene" : {
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_syntax" : "http://www.ncbi.nlm.nih.gov/sites/entrez?cmd=Retrieve&db=gene&list_uids=[example_id]",
      "url_example" : "http://www.ncbi.nlm.nih.gov/sites/entrez?cmd=Retrieve&db=gene&list_uids=4771",
      "datatype" : null,
      "abbreviation" : "NCBI_Gene",
      "generic_url" : "http://www.ncbi.nlm.nih.gov/",
      "local_id_syntax" : "\\d+",
      "fullname" : null,
      "database" : "NCBI Gene",
      "example_id" : "NCBI_Gene:4771",
      "name" : null,
      "entity_type" : "SO:0000704 ! gene"
   },
   "ptarget" : {
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "name" : null,
      "example_id" : null,
      "database" : "pTARGET Prediction server for protein subcellular localization",
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "abbreviation" : "pTARGET",
      "generic_url" : "http://bioinformatics.albany.edu/~ptarget/",
      "datatype" : null,
      "url_example" : null,
      "url_syntax" : null
   },
   "fbbt" : {
      "url_example" : "http://flybase.org/cgi-bin/fbcvq.html?query=FBbt:00005177",
      "url_syntax" : "http://flybase.org/cgi-bin/fbcvq.html?query=FBbt:[example_id]",
      "datatype" : null,
      "generic_url" : "http://flybase.org/",
      "abbreviation" : "FBbt",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "name" : null,
      "example_id" : "FBbt:00005177",
      "database" : "Drosophila gross anatomy",
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null
   },
   "jstor" : {
      "entity_type" : "BET:0000000 ! entity",
      "database" : "Digital archive of scholarly articles",
      "example_id" : "JSTOR:3093870",
      "name" : null,
      "fullname" : null,
      "datatype" : null,
      "abbreviation" : "JSTOR",
      "generic_url" : "http://www.jstor.org/",
      "url_syntax" : "http://www.jstor.org/stable/[example_id]",
      "url_example" : "http://www.jstor.org/stable/3093870",
      "id" : null,
      "object" : null,
      "uri_prefix" : null
   },
   "rgdid" : {
      "url_example" : "http://rgd.mcw.edu/generalSearch/RgdSearch.jsp?quickSearch=1&searchKeyword=2004",
      "url_syntax" : "http://rgd.mcw.edu/generalSearch/RgdSearch.jsp?quickSearch=1&searchKeyword=[example_id]",
      "generic_url" : "http://rgd.mcw.edu/",
      "abbreviation" : "RGDID",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "name" : null,
      "database" : "Rat Genome Database",
      "example_id" : "RGD:2004",
      "entity_type" : "SO:0000704 ! gene",
      "local_id_syntax" : "[0-9]{4,7}",
      "fullname" : null
   },
   "refgenome" : {
      "url_syntax" : null,
      "url_example" : null,
      "datatype" : null,
      "generic_url" : "http://www.geneontology.org/GO.refgenome.shtml",
      "abbreviation" : "RefGenome",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "example_id" : null,
      "database" : "GO Reference Genomes",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null
   },
   "mesh" : {
      "url_syntax" : "http://www.nlm.nih.gov/cgi/mesh/2005/MB_cgi?mode=&term=[example_id]",
      "url_example" : "http://www.nlm.nih.gov/cgi/mesh/2005/MB_cgi?mode=&term=mitosis",
      "generic_url" : "http://www.nlm.nih.gov/mesh/2005/MBrowser.html",
      "abbreviation" : "MeSH",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "name" : null,
      "example_id" : "MeSH:mitosis",
      "database" : "Medical Subject Headings",
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null
   },
   "isbn" : {
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "name" : null,
      "example_id" : "ISBN:0781702534",
      "database" : "International Standard Book Number",
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "generic_url" : "http://isbntools.com/",
      "abbreviation" : "ISBN",
      "datatype" : null,
      "url_syntax" : "https://en.wikipedia.org/w/index.php?title=Special%3ABookSources&isbn=[example_id]",
      "url_example" : "https://en.wikipedia.org/w/index.php?title=Special%3ABookSources&isbn=0123456789"
   },
   "alzheimers_university_of_toronto" : {
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "database" : "Alzheimers Project at University of Toronto",
      "example_id" : null,
      "name" : null,
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "generic_url" : "http://www.ims.utoronto.ca/",
      "abbreviation" : "Alzheimers_University_of_Toronto",
      "url_example" : null,
      "url_syntax" : null
   },
   "agricola_ind" : {
      "datatype" : null,
      "abbreviation" : "AGRICOLA_IND",
      "generic_url" : "http://agricola.nal.usda.gov/",
      "url_example" : null,
      "url_syntax" : null,
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "entity_type" : "BET:0000000 ! entity",
      "database" : "AGRICultural OnLine Access",
      "example_id" : "AGRICOLA_IND:IND23252955",
      "name" : null,
      "fullname" : null
   },
   "nasc_code" : {
      "url_example" : "http://seeds.nottingham.ac.uk/NASC/stockatidb.lasso?code=N3371",
      "url_syntax" : "http://seeds.nottingham.ac.uk/NASC/stockatidb.lasso?code=[example_id]",
      "abbreviation" : "NASC_code",
      "generic_url" : "http://arabidopsis.info",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "name" : null,
      "example_id" : "NASC_code:N3371",
      "database" : "Nottingham Arabidopsis Stock Centre Seeds Database",
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null
   },
   "cgd" : {
      "entity_type" : "SO:0000704 ! gene",
      "example_id" : "CGD:CAL0005516",
      "database" : "Candida Genome Database",
      "name" : null,
      "fullname" : null,
      "local_id_syntax" : "(CAL|CAF)[0-9]{7}",
      "abbreviation" : "CGD",
      "generic_url" : "http://www.candidagenome.org/",
      "datatype" : null,
      "url_syntax" : "http://www.candidagenome.org/cgi-bin/locus.pl?dbid=[example_id]",
      "url_example" : "http://www.candidagenome.org/cgi-bin/locus.pl?dbid=CAL0005516",
      "id" : null,
      "uri_prefix" : null,
      "object" : null
   },
   "wb_ref" : {
      "datatype" : null,
      "abbreviation" : "WB_REF",
      "generic_url" : "http://www.wormbase.org/",
      "url_syntax" : "http://www.wormbase.org/db/misc/paper?name=[example_id]",
      "url_example" : "http://www.wormbase.org/db/misc/paper?name=WBPaper00004823",
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "WB_REF:WBPaper00004823",
      "database" : "WormBase database of nematode biology",
      "name" : null,
      "fullname" : null
   },
   "mips_funcat" : {
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_example" : "http://mips.gsf.de/cgi-bin/proj/funcatDB/search_advanced.pl?action=2&wert=11.02",
      "url_syntax" : "http://mips.gsf.de/cgi-bin/proj/funcatDB/search_advanced.pl?action=2&wert=[example_id]",
      "abbreviation" : "MIPS_funcat",
      "generic_url" : "http://mips.gsf.de/proj/funcatDB/",
      "datatype" : null,
      "fullname" : null,
      "name" : null,
      "example_id" : "MIPS_funcat:11.02",
      "database" : "MIPS Functional Catalogue",
      "entity_type" : "BET:0000000 ! entity"
   },
   "hpa" : {
      "database" : "Human Protein Atlas tissue profile information",
      "example_id" : "HPA:HPA000237",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null,
      "url_syntax" : "http://www.proteinatlas.org/tissue_profile.php?antibody_id=[example_id]",
      "url_example" : "http://www.proteinatlas.org/tissue_profile.php?antibody_id=HPA000237",
      "abbreviation" : "HPA",
      "generic_url" : "http://www.proteinatlas.org/",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null
   },
   "dbsnp" : {
      "local_id_syntax" : "\\d+",
      "fullname" : null,
      "example_id" : "dbSNP:rs3131969",
      "name" : null,
      "database" : "NCBI dbSNP",
      "entity_type" : "BET:0000000 ! entity",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_syntax" : "http://www.ncbi.nlm.nih.gov/projects/SNP/snp_ref.cgi?rs=[example_id]",
      "url_example" : "http://www.ncbi.nlm.nih.gov/projects/SNP/snp_ref.cgi?rs=rs3131969",
      "datatype" : null,
      "abbreviation" : "dbSNP",
      "generic_url" : "http://www.ncbi.nlm.nih.gov/projects/SNP"
   },
   "gr_qtl" : {
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_syntax" : "http://www.gramene.org/db/qtl/qtl_display?qtl_accession_id=[example_id]",
      "url_example" : "http://www.gramene.org/db/qtl/qtl_display?qtl_accession_id=CQU7",
      "datatype" : null,
      "generic_url" : "http://www.gramene.org/",
      "abbreviation" : "GR_QTL",
      "fullname" : null,
      "example_id" : "GR_QTL:CQU7",
      "name" : null,
      "database" : "Gramene",
      "entity_type" : "BET:0000000 ! entity"
   },
   "ec" : {
      "fullname" : null,
      "entity_type" : "GO:0003824 ! catalytic activity",
      "example_id" : "EC:1.4.3.6",
      "name" : null,
      "database" : "Enzyme Commission",
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "generic_url" : "http://www.chem.qmul.ac.uk/iubmb/enzyme/",
      "abbreviation" : "EC",
      "datatype" : null,
      "url_syntax" : "http://www.expasy.org/enzyme/[example_id]",
      "url_example" : "http://www.expasy.org/enzyme/1.4.3.6"
   },
   "mtbbase" : {
      "fullname" : null,
      "name" : null,
      "example_id" : null,
      "database" : "Collection and Refinement of Physiological Data on Mycobacterium tuberculosis",
      "entity_type" : "BET:0000000 ! entity",
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_syntax" : null,
      "url_example" : null,
      "abbreviation" : "MTBBASE",
      "generic_url" : "http://www.ark.in-berlin.de/Site/MTBbase.html",
      "datatype" : null
   },
   "mod" : {
      "abbreviation" : "MOD",
      "generic_url" : "http://psidev.sourceforge.net/mod/",
      "datatype" : null,
      "url_example" : "http://www.ebi.ac.uk/ontology-lookup/?termId=MOD:00219",
      "url_syntax" : "http://www.ebi.ac.uk/ontology-lookup/?termId=MOD:[example_id]",
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "entity_type" : "BET:0000000 ! entity",
      "database" : "Proteomics Standards Initiative protein modification ontology",
      "name" : null,
      "example_id" : "MOD:00219",
      "fullname" : null
   },
   "muscletrait" : {
      "entity_type" : "BET:0000000 ! entity",
      "name" : null,
      "database" : "TRAnscript Integrated Table",
      "example_id" : null,
      "fullname" : null,
      "description" : "an integrated database of transcripts expressed in human skeletal muscle",
      "generic_url" : "http://muscle.cribi.unipd.it/",
      "abbreviation" : "MuscleTRAIT",
      "datatype" : null,
      "url_syntax" : null,
      "url_example" : null,
      "id" : null,
      "uri_prefix" : null,
      "object" : null
   },
   "kegg_reaction" : {
      "database" : "KEGG Reaction Database",
      "example_id" : "KEGG:R02328",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "local_id_syntax" : "R\\d+",
      "fullname" : null,
      "url_syntax" : "http://www.genome.jp/dbget-bin/www_bget?rn:[example_id]",
      "url_example" : "http://www.genome.jp/dbget-bin/www_bget?rn:R02328",
      "generic_url" : "http://www.genome.jp/kegg/reaction/",
      "abbreviation" : "KEGG_REACTION",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null
   },
   "protein_id" : {
      "entity_type" : "PR:000000001 ! protein",
      "example_id" : "protein_id:CAA71991",
      "name" : null,
      "database" : "DDBJ / ENA / GenBank",
      "description" : "protein identifier shared by DDBJ/EMBL-bank/GenBank nucleotide sequence databases",
      "fullname" : null,
      "local_id_syntax" : "[A-Z]{3}[0-9]{5}(\\.[0-9]+)?",
      "datatype" : null,
      "generic_url" : "http://www.ncbi.nlm.nih.gov/Genbank/",
      "abbreviation" : "protein_id",
      "url_example" : null,
      "url_syntax" : null,
      "id" : null,
      "object" : null,
      "uri_prefix" : null
   },
   "ipi" : {
      "entity_type" : "BET:0000000 ! entity",
      "name" : null,
      "example_id" : "IPI:IPI00000005.1",
      "database" : "International Protein Index",
      "fullname" : null,
      "generic_url" : "http://www.ebi.ac.uk/IPI/IPIhelp.html",
      "abbreviation" : "IPI",
      "datatype" : null,
      "url_syntax" : null,
      "url_example" : null,
      "id" : null,
      "uri_prefix" : null,
      "object" : null
   },
   "ensembl_geneid" : {
      "url_example" : "http://www.ensembl.org/id/ENSG00000126016",
      "url_syntax" : "http://www.ensembl.org/id/[example_id]",
      "abbreviation" : "ENSEMBL_GeneID",
      "generic_url" : "http://www.ensembl.org/",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "database" : "Ensembl database of automatically annotated genomic data",
      "example_id" : "ENSEMBL_GeneID:ENSG00000126016",
      "name" : null,
      "entity_type" : "SO:0000704 ! gene",
      "local_id_syntax" : "ENSG[0-9]{9,16}",
      "fullname" : null
   },
   "agricola_id" : {
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_syntax" : null,
      "url_example" : null,
      "datatype" : null,
      "generic_url" : "http://agricola.nal.usda.gov/",
      "abbreviation" : "AGRICOLA_ID",
      "fullname" : null,
      "database" : "AGRICultural OnLine Access",
      "example_id" : "AGRICOLA_NAL:TP248.2 P76 v.14",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity"
   },
   "h-invdb_locus" : {
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "generic_url" : "http://www.h-invitational.jp/",
      "abbreviation" : "H-invDB_locus",
      "datatype" : null,
      "url_syntax" : "http://www.h-invitational.jp/hinv/spsoup/locus_view?hix_id=[example_id]",
      "url_example" : "http://www.h-invitational.jp/hinv/spsoup/locus_view?hix_id=HIX0014446",
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "H-invDB_locus:HIX0014446",
      "name" : null,
      "database" : "H-invitational Database"
   },
   "aspgdid" : {
      "example_id" : "AspGD:ASPL0000067538",
      "name" : null,
      "database" : "Aspergillus Genome Database",
      "entity_type" : "SO:0000704 ! gene",
      "local_id_syntax" : "ASPL[0-9]{10}",
      "fullname" : null,
      "url_example" : "http://www.aspergillusgenome.org/cgi-bin/locus.pl?dbid=ASPL0000067538",
      "url_syntax" : "http://www.aspergillusgenome.org/cgi-bin/locus.pl?dbid=[example_id]",
      "datatype" : null,
      "generic_url" : "http://www.aspergillusgenome.org/",
      "abbreviation" : "AspGDID",
      "object" : null,
      "uri_prefix" : null,
      "id" : null
   },
   "unigene" : {
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_example" : "http://www.ncbi.nlm.nih.gov/UniGene/clust.cgi?ORG=Hs&CID=212293",
      "url_syntax" : "http://www.ncbi.nlm.nih.gov/UniGene/clust.cgi?ORG=[organism_abbreviation]&CID=[cluster_id]",
      "generic_url" : "http://www.ncbi.nlm.nih.gov/UniGene",
      "abbreviation" : "UniGene",
      "datatype" : null,
      "fullname" : null,
      "description" : "NCBI transcript cluster database, organized by transcriptome. Each UniGene entry is a set of transcript sequences that appear to come from the same transcription locus (gene or expressed pseudogene).",
      "example_id" : "UniGene:Hs.212293",
      "database" : "UniGene",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity"
   },
   "mgi" : {
      "datatype" : null,
      "abbreviation" : "MGI",
      "generic_url" : "http://www.informatics.jax.org/",
      "url_example" : "http://www.informatics.jax.org/accession/MGI:80863",
      "url_syntax" : "http://www.informatics.jax.org/accession/[example_id]",
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "entity_type" : "VariO:0001 ! variation",
      "database" : "Mouse Genome Informatics",
      "example_id" : "MGI:MGI:80863",
      "name" : null,
      "fullname" : null,
      "local_id_syntax" : "MGI:[0-9]{5,}"
   },
   "jcvi_cmr" : {
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_syntax" : "http://cmr.jcvi.org/cgi-bin/CMR/shared/GenePage.cgi?locus=[example_id]",
      "url_example" : "http://cmr.jcvi.org/cgi-bin/CMR/shared/GenePage.cgi?locus=VCA0557",
      "abbreviation" : "JCVI_CMR",
      "generic_url" : "http://cmr.jcvi.org/",
      "datatype" : null,
      "fullname" : null,
      "example_id" : "JCVI_CMR:VCA0557",
      "name" : null,
      "database" : "EGAD database at the J. Craig Venter Institute",
      "entity_type" : "PR:000000001 ! protein"
   },
   "multifun" : {
      "abbreviation" : "MultiFun",
      "generic_url" : "http://genprotec.mbl.edu/files/MultiFun.html",
      "datatype" : null,
      "url_example" : null,
      "url_syntax" : null,
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "entity_type" : "BET:0000000 ! entity",
      "name" : null,
      "example_id" : null,
      "database" : "MultiFun cell function assignment schema",
      "fullname" : null
   },
   "tair" : {
      "entity_type" : "SO:0000185 ! primary transcript",
      "example_id" : "TAIR:locus:2146653",
      "database" : "The Arabidopsis Information Resource",
      "name" : null,
      "fullname" : null,
      "local_id_syntax" : "locus:[0-9]{7}",
      "generic_url" : "http://www.arabidopsis.org/",
      "abbreviation" : "TAIR",
      "datatype" : null,
      "url_example" : "http://arabidopsis.org/servlets/TairObject?accession=locus:2146653",
      "url_syntax" : "http://arabidopsis.org/servlets/TairObject?accession=[example_id]",
      "id" : null,
      "uri_prefix" : null,
      "object" : null
   },
   "maizegdb" : {
      "url_syntax" : "http://www.maizegdb.org/cgi-bin/id_search.cgi?id=[example_id]",
      "url_example" : "http://www.maizegdb.org/cgi-bin/id_search.cgi?id=881225",
      "datatype" : null,
      "generic_url" : "http://www.maizegdb.org",
      "abbreviation" : "MaizeGDB",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "example_id" : "MaizeGDB:881225",
      "name" : null,
      "database" : "MaizeGDB",
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null
   },
   "uniprotkb-kw" : {
      "example_id" : "UniProtKB-KW:KW-0812",
      "database" : "UniProt Knowledgebase keywords",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null,
      "url_example" : "http://www.uniprot.org/keywords/KW-0812",
      "url_syntax" : "http://www.uniprot.org/keywords/[example_id]",
      "generic_url" : "http://www.uniprot.org/keywords/",
      "abbreviation" : "UniProtKB-KW",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null
   },
   "pombase" : {
      "local_id_syntax" : "S\\w+(\\.)?\\w+(\\.)?",
      "fullname" : null,
      "example_id" : "PomBase:SPBC11B10.09",
      "name" : null,
      "database" : "PomBase",
      "entity_type" : "SO:0000704 ! gene",
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_syntax" : "http://www.pombase.org/spombe/result/[example_id]",
      "url_example" : "http://www.pombase.org/spombe/result/SPBC11B10.09",
      "generic_url" : "http://www.pombase.org/",
      "abbreviation" : "PomBase",
      "datatype" : null
   },
   "cog_cluster" : {
      "entity_type" : "BET:0000000 ! entity",
      "name" : null,
      "example_id" : "COG_Cluster:COG0001",
      "database" : "NCBI COG cluster",
      "fullname" : null,
      "generic_url" : "http://www.ncbi.nlm.nih.gov/COG/",
      "abbreviation" : "COG_Cluster",
      "datatype" : null,
      "url_example" : "http://www.ncbi.nlm.nih.gov/COG/new/release/cow.cgi?cog=COG0001",
      "url_syntax" : "http://www.ncbi.nlm.nih.gov/COG/new/release/cow.cgi?cog=[example_id]",
      "id" : null,
      "uri_prefix" : null,
      "object" : null
   },
   "pmid" : {
      "url_syntax" : "http://www.ncbi.nlm.nih.gov/pubmed/[example_id]",
      "url_example" : "http://www.ncbi.nlm.nih.gov/pubmed/4208797",
      "abbreviation" : "PMID",
      "generic_url" : "http://www.ncbi.nlm.nih.gov/PubMed/",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "database" : "PubMed",
      "example_id" : "PMID:4208797",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "local_id_syntax" : "[0-9]+",
      "fullname" : null
   },
   "aracyc" : {
      "url_example" : "http://www.arabidopsis.org:1555/ARA/NEW-IMAGE?type=NIL&object=PWYQT-62",
      "url_syntax" : "http://www.arabidopsis.org:1555/ARA/NEW-IMAGE?type=NIL&object=[example_id]",
      "abbreviation" : "AraCyc",
      "generic_url" : "http://www.arabidopsis.org/biocyc/index.jsp",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "database" : "AraCyc metabolic pathway database for Arabidopsis thaliana",
      "example_id" : "AraCyc:PWYQT-62",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null
   },
   "jcvi_genprop" : {
      "url_syntax" : "http://cmr.jcvi.org/cgi-bin/CMR/shared/GenomePropDefinition.cgi?prop_acc=[example_id]",
      "url_example" : "http://cmr.jcvi.org/cgi-bin/CMR/shared/GenomePropDefinition.cgi?prop_acc=GenProp0120",
      "generic_url" : "http://cmr.jcvi.org/",
      "abbreviation" : "JCVI_GenProp",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "example_id" : "JCVI_GenProp:GenProp0120",
      "database" : "Genome Properties database at the J. Craig Venter Institute",
      "name" : null,
      "entity_type" : "GO:0008150 ! biological_process",
      "local_id_syntax" : "GenProp[0-9]{4}",
      "fullname" : null
   },
   "rfam" : {
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "database" : "Rfam database of RNA families",
      "example_id" : "Rfam:RF00012",
      "name" : null,
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "abbreviation" : "Rfam",
      "generic_url" : "http://rfam.sanger.ac.uk/",
      "url_example" : "http://rfam.sanger.ac.uk/family/RF00012",
      "url_syntax" : "http://rfam.sanger.ac.uk/family/[example_id]"
   },
   "reac" : {
      "datatype" : null,
      "abbreviation" : "REAC",
      "generic_url" : "http://www.reactome.org/",
      "url_example" : "http://www.reactome.org/cgi-bin/eventbrowser_st_id?ST_ID=REACT_604",
      "url_syntax" : "http://www.reactome.org/cgi-bin/eventbrowser_st_id?ST_ID=[example_id]",
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "Reactome:REACT_604",
      "database" : "Reactome - a curated knowledgebase of biological pathways",
      "name" : null,
      "fullname" : null,
      "local_id_syntax" : "REACT_[0-9]+"
   },
   "um-bbd_reactionid" : {
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "abbreviation" : "UM-BBD_reactionID",
      "generic_url" : "http://umbbd.msi.umn.edu/",
      "url_syntax" : "http://umbbd.msi.umn.edu/servlets/pageservlet?ptype=r&reacID=[example_id]",
      "url_example" : "http://umbbd.msi.umn.edu/servlets/pageservlet?ptype=r&reacID=r0129",
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "UM-BBD_reactionID:r0129",
      "name" : null,
      "database" : "University of Minnesota Biocatalysis/Biodegradation Database"
   },
   "ensemblplants" : {
      "example_id" : "EnsemblPlants:LOC_Os01g22954",
      "database" : "Ensembl Plants, the Ensembl Genomes database for accessing plant genome data",
      "name" : null,
      "entity_type" : "SO:0000704 ! gene",
      "fullname" : null,
      "url_example" : "http://www.ensemblgenomes.org/id/LOC_Os01g22954",
      "url_syntax" : "http://www.ensemblgenomes.org/id/[example_ID]",
      "datatype" : null,
      "abbreviation" : "EnsemblPlants",
      "generic_url" : "http://plants.ensembl.org/",
      "object" : null,
      "uri_prefix" : null,
      "id" : null
   },
   "pfamb" : {
      "fullname" : null,
      "database" : "Pfam-B supplement to Pfam",
      "example_id" : "PfamB:PB014624",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_example" : null,
      "url_syntax" : null,
      "generic_url" : "http://www.sanger.ac.uk/Software/Pfam/",
      "abbreviation" : "PfamB",
      "datatype" : null
   },
   "rnacentral" : {
      "entity_type" : "CHEBI:33697 ! ribonucleic acid",
      "name" : null,
      "example_id" : "RNAcentral:URS000047C79B_9606",
      "database" : "RNAcentral",
      "fullname" : null,
      "description" : "An international database of ncRNA sequences",
      "local_id_syntax" : "URS[0-9A-F]{10}([_\\/][0-9]+){0,1}",
      "generic_url" : "http://rnacentral.org",
      "abbreviation" : "RNAcentral",
      "datatype" : null,
      "url_syntax" : "http://rnacentral.org/rna/[example_id]",
      "url_example" : "http://rnacentral.org/rna/URS000047C79B_9606",
      "id" : null,
      "uri_prefix" : null,
      "object" : null
   },
   "tigr_ref" : {
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_syntax" : null,
      "url_example" : "http://cmr.jcvi.org/CMR/AnnotationSops.shtml",
      "datatype" : null,
      "abbreviation" : "TIGR_REF",
      "generic_url" : "http://cmr.jcvi.org/",
      "fullname" : null,
      "database" : "J. Craig Venter Institute",
      "name" : null,
      "example_id" : "JCVI_REF:GO_ref",
      "entity_type" : "BET:0000000 ! entity"
   },
   "corum" : {
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "CORUM:837",
      "name" : null,
      "database" : "CORUM - the Comprehensive Resource of Mammalian protein complexes",
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "generic_url" : "http://mips.gsf.de/genre/proj/corum/",
      "abbreviation" : "CORUM",
      "datatype" : null,
      "url_syntax" : "http://mips.gsf.de/genre/proj/corum/complexdetails.html?id=[example_id]",
      "url_example" : "http://mips.gsf.de/genre/proj/corum/complexdetails.html?id=837"
   },
   "mgd" : {
      "url_syntax" : null,
      "url_example" : null,
      "datatype" : null,
      "generic_url" : "http://www.informatics.jax.org/",
      "abbreviation" : "MGD",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "example_id" : "MGD:Adcy9",
      "name" : null,
      "database" : "Mouse Genome Database",
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null
   },
   "pro" : {
      "url_syntax" : "http://www.proconsortium.org/cgi-bin/pro/entry_pro?id=PR:[example_id]",
      "url_example" : "http://www.proconsortium.org/cgi-bin/pro/entry_pro?id=PR:000025380",
      "generic_url" : "http://www.proconsortium.org/pro/pro.shtml",
      "abbreviation" : "PRO",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "database" : "Protein Ontology",
      "name" : null,
      "example_id" : "PR:000025380",
      "entity_type" : "PR:000000001 ! protein",
      "local_id_syntax" : "[0-9]{9}",
      "fullname" : null
   },
   "merops_fam" : {
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_syntax" : "http://merops.sanger.ac.uk/cgi-bin/famsum?family=[example_id]",
      "url_example" : "http://merops.sanger.ac.uk/cgi-bin/famsum?family=m18",
      "abbreviation" : "MEROPS_fam",
      "generic_url" : "http://merops.sanger.ac.uk/",
      "datatype" : null,
      "fullname" : null,
      "database" : "MEROPS peptidase database",
      "example_id" : "MEROPS_fam:M18",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity"
   },
   "sgd_ref" : {
      "fullname" : null,
      "name" : null,
      "example_id" : "SGD_REF:S000049602",
      "database" : "Saccharomyces Genome Database",
      "entity_type" : "BET:0000000 ! entity",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_example" : "http://www.yeastgenome.org/reference/S000049602/overview",
      "url_syntax" : "http://www.yeastgenome.org/reference/[example_is]/overview",
      "datatype" : null,
      "abbreviation" : "SGD_REF",
      "generic_url" : "http://www.yeastgenome.org/"
   },
   "patric" : {
      "description" : "PathoSystems Resource Integration Center at the Virginia Bioinformatics Institute",
      "fullname" : null,
      "example_id" : "PATRIC:cds.000002.436951",
      "database" : "PathoSystems Resource Integration Center",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_syntax" : "http://patric.vbi.vt.edu/gene/overview.php?fid=[example_id]",
      "url_example" : "http://patric.vbi.vt.edu/gene/overview.php?fid=cds.000002.436951",
      "datatype" : null,
      "abbreviation" : "PATRIC",
      "generic_url" : "http://patric.vbi.vt.edu"
   },
   "h-invdb_cdna" : {
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "generic_url" : "http://www.h-invitational.jp/",
      "abbreviation" : "H-invDB_cDNA",
      "url_syntax" : "http://www.h-invitational.jp/hinv/spsoup/transcript_view?acc_id=[example_id]",
      "url_example" : "http://www.h-invitational.jp/hinv/spsoup/transcript_view?acc_id=AK093149",
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "database" : "H-invitational Database",
      "example_id" : "H-invDB_cDNA:AK093148",
      "name" : null
   },
   "pubchem_substance" : {
      "local_id_syntax" : "[0-9]{4,}",
      "fullname" : null,
      "database" : "NCBI PubChem database of chemical substances",
      "example_id" : "PubChem_Substance:4594",
      "name" : null,
      "entity_type" : "CHEBI:24431 ! chemical entity",
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_example" : "http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?CMD=search&DB=pcsubstance&term=4594",
      "url_syntax" : "http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?CMD=search&DB=pcsubstance&term=[example_id]",
      "generic_url" : "http://pubchem.ncbi.nlm.nih.gov/",
      "abbreviation" : "PubChem_Substance",
      "datatype" : null
   },
   "refseq" : {
      "datatype" : null,
      "abbreviation" : "RefSeq",
      "generic_url" : "http://www.ncbi.nlm.nih.gov/RefSeq/",
      "url_example" : "http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?val=XP_001068954",
      "url_syntax" : "http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?val=[example_id]",
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "entity_type" : "PR:000000001 ! protein",
      "example_id" : "RefSeq:XP_001068954",
      "database" : "RefSeq",
      "name" : null,
      "fullname" : null,
      "local_id_syntax" : "(NC|AC|NG|NT|NW|NZ|NM|NR|XM|XR|NP|AP|XP|YP|ZP)_[0-9]+(\\.[0-9]+){0,1}"
   },
   "omim" : {
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "OMIM:190198",
      "name" : null,
      "database" : "Mendelian Inheritance in Man",
      "fullname" : null,
      "abbreviation" : "OMIM",
      "generic_url" : "http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?db=OMIM",
      "datatype" : null,
      "url_example" : "http://omim.org/entry/190198",
      "url_syntax" : "http://omim.org/entry/[example_id]",
      "id" : null,
      "uri_prefix" : null,
      "object" : null
   },
   "brenda" : {
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "abbreviation" : "BRENDA",
      "generic_url" : "http://www.brenda-enzymes.info",
      "datatype" : null,
      "url_syntax" : "http://www.brenda-enzymes.info/php/result_flat.php4?ecno=[example_id]",
      "url_example" : "http://www.brenda-enzymes.info/php/result_flat.php4?ecno=4.2.1.3",
      "fullname" : null,
      "entity_type" : "GO:0003824 ! catalytic activity",
      "database" : "BRENDA, The Comprehensive Enzyme Information System",
      "example_id" : "BRENDA:4.2.1.3",
      "name" : null
   },
   "vbrc" : {
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "name" : null,
      "example_id" : "VBRC:F35742",
      "database" : "Viral Bioinformatics Resource Center",
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "abbreviation" : "VBRC",
      "generic_url" : "http://vbrc.org",
      "datatype" : null,
      "url_syntax" : "http://vbrc.org/query.asp?web_id=VBRC:[example_id]",
      "url_example" : "http://vbrc.org/query.asp?web_id=VBRC:F35742"
   },
   "ri" : {
      "generic_url" : "http://www.roslin.ac.uk/",
      "abbreviation" : "RI",
      "datatype" : null,
      "url_example" : null,
      "url_syntax" : null,
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "entity_type" : "BET:0000000 ! entity",
      "name" : null,
      "database" : "Roslin Institute",
      "example_id" : null,
      "fullname" : null
   },
   "medline" : {
      "url_example" : null,
      "url_syntax" : null,
      "datatype" : null,
      "abbreviation" : "MEDLINE",
      "generic_url" : "http://www.nlm.nih.gov/databases/databases_medline.html",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "example_id" : "MEDLINE:20572430",
      "name" : null,
      "database" : "Medline literature database",
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null
   },
   "seed" : {
      "fullname" : null,
      "description" : "Project to annotate the first 1000 sequenced genomes, develop detailed metabolic reconstructions, and construct the corresponding stoichiometric matrices",
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "SEED:fig|83331.1.peg.1",
      "name" : null,
      "database" : "The SEED;",
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "generic_url" : "http://www.theseed.org",
      "abbreviation" : "SEED",
      "datatype" : null,
      "url_syntax" : "http://www.theseed.org/linkin.cgi?id=[example_id]",
      "url_example" : "http://www.theseed.org/linkin.cgi?id=fig|83331.1.peg.1"
   },
   "mi" : {
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_syntax" : null,
      "url_example" : null,
      "generic_url" : "http://psidev.sourceforge.net/mi/xml/doc/user/index.html",
      "abbreviation" : "MI",
      "datatype" : null,
      "fullname" : null,
      "example_id" : "MI:0018",
      "database" : "Proteomic Standard Initiative for Molecular Interaction",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity"
   },
   "iuphar_receptor" : {
      "url_syntax" : "http://www.iuphar-db.org/DATABASE/ObjectDisplayForward?objectId=[example_id]",
      "url_example" : "http://www.iuphar-db.org/DATABASE/ObjectDisplayForward?objectId=56",
      "abbreviation" : "IUPHAR_RECEPTOR",
      "generic_url" : "http://www.iuphar.org/",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "example_id" : "IUPHAR_RECEPTOR:2205",
      "name" : null,
      "database" : "International Union of Pharmacology",
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null
   },
   "biopixie_mefit" : {
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : null,
      "database" : "biological Process Inference from eXperimental Interaction Evidence/Microarray Experiment Functional Integration Technology",
      "name" : null,
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "abbreviation" : "bioPIXIE_MEFIT",
      "generic_url" : "http://pixie.princeton.edu/pixie/",
      "url_example" : null,
      "url_syntax" : null
   },
   "gdb" : {
      "name" : null,
      "example_id" : "GDB:306600",
      "database" : "Human Genome Database",
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null,
      "url_example" : "http://www.gdb.org/gdb-bin/genera/accno?accessionNum=GDB:306600",
      "url_syntax" : "http://www.gdb.org/gdb-bin/genera/accno?accessionNum=GDB:[example_id]",
      "generic_url" : "http://www.gdb.org/",
      "abbreviation" : "GDB",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null
   },
   "sgdid" : {
      "fullname" : null,
      "local_id_syntax" : "S[0-9]{9}",
      "entity_type" : "SO:0000704 ! gene",
      "database" : "Saccharomyces Genome Database",
      "example_id" : "SGD:S000006169",
      "name" : null,
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "generic_url" : "http://www.yeastgenome.org/",
      "abbreviation" : "SGDID",
      "datatype" : null,
      "url_syntax" : "http://www.yeastgenome.org/locus/[example_id]/overview",
      "url_example" : "http://www.yeastgenome.org/locus/S000006169/overview"
   },
   "parkinsonsuk-ucl" : {
      "database" : "Parkinsons Disease Gene Ontology Initiative",
      "example_id" : null,
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null,
      "url_syntax" : null,
      "url_example" : null,
      "abbreviation" : "ParkinsonsUK-UCL",
      "generic_url" : "http://www.ucl.ac.uk/functional-gene-annotation/neurological",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null
   },
   "hugo" : {
      "url_syntax" : null,
      "url_example" : null,
      "generic_url" : "http://www.hugo-international.org/",
      "abbreviation" : "HUGO",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "database" : "Human Genome Organisation",
      "example_id" : null,
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null
   },
   "flybase" : {
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "generic_url" : "http://flybase.org/",
      "abbreviation" : "FLYBASE",
      "url_syntax" : "http://flybase.org/reports/[example_id].html",
      "url_example" : "http://flybase.org/reports/FBgn0000024.html",
      "fullname" : null,
      "local_id_syntax" : "FBgn[0-9]{7}",
      "entity_type" : "SO:0000704 ! gene",
      "name" : null,
      "example_id" : "FB:FBgn0000024",
      "database" : "FlyBase"
   },
   "transfac" : {
      "fullname" : null,
      "example_id" : null,
      "name" : null,
      "database" : "TRANSFAC database of eukaryotic transcription factors",
      "entity_type" : "BET:0000000 ! entity",
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_example" : null,
      "url_syntax" : null,
      "generic_url" : "http://www.gene-regulation.com/pub/databases.html#transfac",
      "abbreviation" : "TRANSFAC",
      "datatype" : null
   },
   "cog_pathway" : {
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "generic_url" : "http://www.ncbi.nlm.nih.gov/COG/",
      "abbreviation" : "COG_Pathway",
      "url_example" : "http://www.ncbi.nlm.nih.gov/COG/new/release/coglist.cgi?pathw=14",
      "url_syntax" : "http://www.ncbi.nlm.nih.gov/COG/new/release/coglist.cgi?pathw=[example_id]",
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "COG_Pathway:14",
      "database" : "NCBI COG pathway",
      "name" : null
   },
   "merops" : {
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_example" : "http://merops.sanger.ac.uk/cgi-bin/pepsum?mid=A08.001",
      "url_syntax" : "http://merops.sanger.ac.uk/cgi-bin/pepsum?mid=[example_id]",
      "datatype" : null,
      "abbreviation" : "MEROPS",
      "generic_url" : "http://merops.sanger.ac.uk/",
      "fullname" : null,
      "example_id" : "MEROPS:A08.001",
      "name" : null,
      "database" : "MEROPS peptidase database",
      "entity_type" : "PR:000000001 ! protein"
   },
   "pamgo" : {
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : null,
      "name" : null,
      "database" : "Plant-Associated Microbe Gene Ontology Interest Group",
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "generic_url" : "http://pamgo.vbi.vt.edu/",
      "abbreviation" : "PAMGO",
      "url_syntax" : null,
      "url_example" : null
   },
   "ensemblplants/gramene" : {
      "entity_type" : "SO:0000704 ! gene",
      "example_id" : "EnsemblPlants:LOC_Os01g22954",
      "name" : null,
      "database" : "Ensembl Plants, the Ensembl Genomes database for accessing plant genome data",
      "fullname" : null,
      "generic_url" : "http://plants.ensembl.org/",
      "abbreviation" : "EnsemblPlants/Gramene",
      "datatype" : null,
      "url_syntax" : "http://www.ensemblgenomes.org/id/[example_ID]",
      "url_example" : "http://www.ensemblgenomes.org/id/LOC_Os01g22954",
      "id" : null,
      "uri_prefix" : null,
      "object" : null
   },
   "biomd" : {
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "BIOMD:BIOMD0000000045",
      "name" : null,
      "database" : "BioModels Database",
      "fullname" : null,
      "generic_url" : "http://www.ebi.ac.uk/biomodels/",
      "abbreviation" : "BIOMD",
      "datatype" : null,
      "url_syntax" : "http://www.ebi.ac.uk/compneur-srv/biomodels-main/publ-model.do?mid=[example_id]",
      "url_example" : "http://www.ebi.ac.uk/compneur-srv/biomodels-main/publ-model.do?mid=BIOMD0000000045",
      "id" : null,
      "uri_prefix" : null,
      "object" : null
   },
   "omssa" : {
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "name" : null,
      "example_id" : null,
      "database" : "Open Mass Spectrometry Search Algorithm",
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "generic_url" : "http://pubchem.ncbi.nlm.nih.gov/omssa/",
      "abbreviation" : "OMSSA",
      "datatype" : null,
      "url_syntax" : null,
      "url_example" : null
   },
   "po_ref" : {
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "generic_url" : "http://wiki.plantontology.org:8080/index.php/PO_references",
      "abbreviation" : "PO_REF",
      "url_example" : "http://wiki.plantontology.org:8080/index.php/PO_REF:00001",
      "url_syntax" : "http://wiki.plantontology.org:8080/index.php/PO_REF:[example_id]",
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "database" : "Plant Ontology custom references",
      "example_id" : "PO_REF:00001",
      "name" : null
   },
   "phenoscape" : {
      "url_example" : null,
      "url_syntax" : null,
      "generic_url" : "http://phenoscape.org/",
      "abbreviation" : "PhenoScape",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "example_id" : null,
      "database" : "PhenoScape Knowledgebase",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null
   },
   "eco" : {
      "database" : "Evidence Code ontology",
      "example_id" : "ECO:0000002",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "local_id_syntax" : "\\d{7}",
      "fullname" : null,
      "url_syntax" : null,
      "url_example" : null,
      "datatype" : null,
      "abbreviation" : "ECO",
      "generic_url" : "http://www.geneontology.org/",
      "object" : null,
      "uri_prefix" : null,
      "id" : null
   },
   "agi_locuscode" : {
      "entity_type" : "SO:0000704 ! gene",
      "example_id" : "AGI_LocusCode:At2g17950",
      "database" : "Arabidopsis Genome Initiative",
      "name" : null,
      "fullname" : null,
      "description" : "Comprises TAIR, TIGR and MIPS",
      "local_id_syntax" : "A[Tt][MmCc0-5][Gg][0-9]{5}(\\.[0-9]{1})?",
      "generic_url" : "http://www.arabidopsis.org",
      "abbreviation" : "AGI_LocusCode",
      "datatype" : null,
      "url_syntax" : "http://arabidopsis.org/servlets/TairObject?type=locus&name=[example_id]",
      "url_example" : "http://arabidopsis.org/servlets/TairObject?type=locus&name=At2g17950",
      "id" : null,
      "uri_prefix" : null,
      "object" : null
   },
   "psort" : {
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "generic_url" : "http://www.psort.org/",
      "abbreviation" : "PSORT",
      "url_example" : null,
      "url_syntax" : null,
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "database" : "PSORT protein subcellular localization databases and prediction tools for bacteria",
      "example_id" : null,
      "name" : null
   },
   "obo_rel" : {
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "database" : "OBO relation ontology",
      "example_id" : "OBO_REL:part_of",
      "name" : null,
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "abbreviation" : "OBO_REL",
      "generic_url" : "http://www.obofoundry.org/ro/",
      "datatype" : null,
      "url_syntax" : null,
      "url_example" : null
   },
   "rnamdb" : {
      "fullname" : null,
      "database" : "RNA Modification Database",
      "name" : null,
      "example_id" : "RNAmods:037",
      "entity_type" : "BET:0000000 ! entity",
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_syntax" : "http://s59.cas.albany.edu/RNAmods/cgi-bin/rnashow.cgi?[example_id]",
      "url_example" : "http://s59.cas.albany.edu/RNAmods/cgi-bin/rnashow.cgi?091",
      "generic_url" : "http://s59.cas.albany.edu/RNAmods/",
      "abbreviation" : "RNAMDB",
      "datatype" : null
   },
   "uniprotkb" : {
      "datatype" : null,
      "generic_url" : "http://www.uniprot.org",
      "abbreviation" : "UniProtKB",
      "url_example" : "http://www.uniprot.org/uniprot/P51587",
      "url_syntax" : "http://www.uniprot.org/uniprot/[example_id]",
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "entity_type" : "PR:000000001 ! protein",
      "database" : "Universal Protein Knowledgebase",
      "example_id" : "UniProtKB:P51587",
      "name" : null,
      "description" : "A central repository of protein sequence and function created by joining the information contained in Swiss-Prot, TrEMBL, and PIR database",
      "fullname" : null,
      "local_id_syntax" : "([OPQ][0-9][A-Z0-9]{3}[0-9]|[A-NR-Z]([0-9][A-Z][A-Z0-9]{2}){1,2}[0-9])((-[0-9]+)|:PRO_[0-9]{10}|:VAR_[0-9]{6}){0,1}"
   },
   "mo" : {
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_example" : "http://mged.sourceforge.net/ontologies/MGEDontology.php#Action",
      "url_syntax" : "http://mged.sourceforge.net/ontologies/MGEDontology.php#[example_id]",
      "abbreviation" : "MO",
      "generic_url" : "http://mged.sourceforge.net/ontologies/MGEDontology.php",
      "datatype" : null,
      "fullname" : null,
      "example_id" : "MO:Action",
      "database" : "MGED Ontology",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity"
   },
   "ensembl_transcriptid" : {
      "url_syntax" : "http://www.ensembl.org/id/[example_id]",
      "url_example" : "http://www.ensembl.org/id/ENST00000371959",
      "datatype" : null,
      "generic_url" : "http://www.ensembl.org/",
      "abbreviation" : "ENSEMBL_TranscriptID",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "example_id" : "ENSEMBL_TranscriptID:ENST00000371959",
      "name" : null,
      "database" : "Ensembl database of automatically annotated genomic data",
      "entity_type" : "SO:0000673 ! transcript",
      "local_id_syntax" : "ENST[0-9]{9,16}",
      "fullname" : null
   },
   "smd" : {
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "generic_url" : "http://genome-www.stanford.edu/microarray",
      "abbreviation" : "SMD",
      "datatype" : null,
      "url_example" : null,
      "url_syntax" : null,
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : null,
      "database" : "Stanford Microarray Database",
      "name" : null
   },
   "ncbi_taxid" : {
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "abbreviation" : "ncbi_taxid",
      "generic_url" : "http://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/",
      "datatype" : null,
      "url_syntax" : "http://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi?id=[example_id]",
      "url_example" : "http://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi?id=3702",
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "name" : null,
      "database" : "NCBI Taxonomy",
      "example_id" : "taxon:7227"
   },
   "reactome" : {
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "abbreviation" : "Reactome",
      "generic_url" : "http://www.reactome.org/",
      "datatype" : null,
      "url_example" : "http://www.reactome.org/cgi-bin/eventbrowser_st_id?ST_ID=REACT_604",
      "url_syntax" : "http://www.reactome.org/cgi-bin/eventbrowser_st_id?ST_ID=[example_id]",
      "fullname" : null,
      "local_id_syntax" : "REACT_[0-9]+",
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "Reactome:REACT_604",
      "name" : null,
      "database" : "Reactome - a curated knowledgebase of biological pathways"
   },
   "lifedb" : {
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_syntax" : "http://www.dkfz.de/LIFEdb/LIFEdb.aspx?ID=[example_id]",
      "url_example" : "http://www.dkfz.de/LIFEdb/LIFEdb.aspx?ID=DKFZp564O1716",
      "datatype" : null,
      "generic_url" : "http://www.lifedb.de/",
      "abbreviation" : "LIFEdb",
      "description" : "LifeDB is a database for information on protein localization, interaction, functional assays and expression.",
      "fullname" : null,
      "name" : null,
      "example_id" : "LIFEdb:DKFZp564O1716",
      "database" : "LifeDB",
      "entity_type" : "BET:0000000 ! entity"
   },
   "ncbi_locus_tag" : {
      "example_id" : "NCBI_locus_tag:CTN_0547",
      "name" : null,
      "database" : "NCBI locus tag",
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null,
      "url_example" : null,
      "url_syntax" : null,
      "generic_url" : "http://www.ncbi.nlm.nih.gov/",
      "abbreviation" : "NCBI_locus_tag",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null
   },
   "ddb_ref" : {
      "datatype" : null,
      "abbreviation" : "DDB_REF",
      "generic_url" : "http://dictybase.org",
      "url_syntax" : "http://dictybase.org/db/cgi-bin/dictyBase/reference/reference.pl?refNo=[example_id]",
      "url_example" : "http://dictybase.org/db/cgi-bin/dictyBase/reference/reference.pl?refNo=10157",
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "entity_type" : "BET:0000000 ! entity",
      "database" : "dictyBase literature references",
      "example_id" : "dictyBase_REF:10157",
      "name" : null,
      "fullname" : null
   },
   "ddanat" : {
      "entity_type" : "CARO:0000000 ! anatomical entity",
      "example_id" : "DDANAT:0000068",
      "name" : null,
      "database" : "Dictyostelium discoideum anatomy",
      "fullname" : null,
      "local_id_syntax" : "[0-9]{7}",
      "datatype" : null,
      "generic_url" : "http://dictybase.org/Dicty_Info/dicty_anatomy_ontology.html",
      "abbreviation" : "DDANAT",
      "url_syntax" : null,
      "url_example" : null,
      "id" : null,
      "object" : null,
      "uri_prefix" : null
   },
   "resid" : {
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "RESID:AA0062",
      "name" : null,
      "database" : "RESID Database of Protein Modifications",
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "generic_url" : "ftp://ftp.ncifcrf.gov/pub/users/residues/",
      "abbreviation" : "RESID",
      "url_syntax" : null,
      "url_example" : null
   },
   "embl" : {
      "example_id" : "EMBL:AA816246",
      "database" : "EMBL Nucleotide Sequence Database",
      "name" : null,
      "entity_type" : "SO:0000704 ! gene",
      "local_id_syntax" : "([A-Z]{1}[0-9]{5})|([A-Z]{2}[0-9]{6})|([A-Z]{4}[0-9]{8,9})",
      "description" : "International nucleotide sequence database collaboration, comprising EMBL-EBI nucleotide sequence data library (EMBL-Bank), DNA DataBank of Japan (DDBJ), and NCBI GenBank",
      "fullname" : null,
      "url_example" : "http://www.ebi.ac.uk/cgi-bin/emblfetch?style=html&Submit=Go&id=AA816246",
      "url_syntax" : "http://www.ebi.ac.uk/cgi-bin/emblfetch?style=html&Submit=Go&id=[example_id]",
      "datatype" : null,
      "generic_url" : "http://www.ebi.ac.uk/embl/",
      "abbreviation" : "EMBL",
      "object" : null,
      "uri_prefix" : null,
      "id" : null
   },
   "superfamily" : {
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_syntax" : "http://supfam.cs.bris.ac.uk/SUPERFAMILY/cgi-bin/scop.cgi?ipid=SSF[example_id]",
      "url_example" : "http://supfam.cs.bris.ac.uk/SUPERFAMILY/cgi-bin/scop.cgi?ipid=SSF51905",
      "abbreviation" : "SUPERFAMILY",
      "generic_url" : "http://supfam.cs.bris.ac.uk/SUPERFAMILY/index.html",
      "datatype" : null,
      "fullname" : null,
      "description" : "A database of structural and functional protein annotations for completely sequenced genomes",
      "name" : null,
      "example_id" : "SUPERFAMILY:51905",
      "database" : "SUPERFAMILY protein annotation database",
      "entity_type" : "BET:0000000 ! entity"
   },
   "trait" : {
      "description" : "an integrated database of transcripts expressed in human skeletal muscle",
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : null,
      "name" : null,
      "database" : "TRAnscript Integrated Table",
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "abbreviation" : "TRAIT",
      "generic_url" : "http://muscle.cribi.unipd.it/",
      "url_syntax" : null,
      "url_example" : null
   },
   "sp_kw" : {
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "name" : null,
      "database" : "UniProt Knowledgebase keywords",
      "example_id" : "UniProtKB-KW:KW-0812",
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "generic_url" : "http://www.uniprot.org/keywords/",
      "abbreviation" : "SP_KW",
      "datatype" : null,
      "url_syntax" : "http://www.uniprot.org/keywords/[example_id]",
      "url_example" : "http://www.uniprot.org/keywords/KW-0812"
   },
   "gonuts" : {
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_syntax" : "http://gowiki.tamu.edu/wiki/index.php/[example_id]",
      "url_example" : "http://gowiki.tamu.edu/wiki/index.php/MOUSE:CD28",
      "abbreviation" : "GONUTS",
      "generic_url" : "http://gowiki.tamu.edu",
      "datatype" : null,
      "fullname" : null,
      "description" : "Third party documentation for GO and community annotation system.",
      "database" : "Gene Ontology Normal Usage Tracking System (GONUTS)",
      "example_id" : "GONUTS:MOUSE:CD28",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity"
   },
   "rnamods" : {
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "RNAmods:037",
      "database" : "RNA Modification Database",
      "name" : null,
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "abbreviation" : "RNAmods",
      "generic_url" : "http://s59.cas.albany.edu/RNAmods/",
      "datatype" : null,
      "url_example" : "http://s59.cas.albany.edu/RNAmods/cgi-bin/rnashow.cgi?091",
      "url_syntax" : "http://s59.cas.albany.edu/RNAmods/cgi-bin/rnashow.cgi?[example_id]"
   },
   "zfin" : {
      "url_example" : "http://zfin.org/cgi-bin/ZFIN_jump?record=ZDB-GENE-990415-103",
      "url_syntax" : "http://zfin.org/cgi-bin/ZFIN_jump?record=[example_id]",
      "generic_url" : "http://zfin.org/",
      "abbreviation" : "ZFIN",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "example_id" : "ZFIN:ZDB-GENE-990415-103",
      "name" : null,
      "database" : "Zebrafish Information Network",
      "entity_type" : "VariO:0001 ! variation",
      "local_id_syntax" : "ZDB-(GENE|GENO|MRPHLNO)-[0-9]{6}-[0-9]+",
      "fullname" : null
   },
   "broad_neurospora" : {
      "fullname" : null,
      "description" : "Neurospora crassa database at the Broad Institute",
      "example_id" : "BROAD_NEUROSPORA:7000007580576824",
      "name" : null,
      "database" : "Neurospora crassa Database",
      "entity_type" : "BET:0000000 ! entity",
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_example" : "http://www.broadinstitute.org/annotation/genome/neurospora/GeneDetails.html?sp=S7000007580576824",
      "url_syntax" : "http://www.broadinstitute.org/annotation/genome/neurospora/GeneDetails.html?sp=S[example_id]",
      "abbreviation" : "Broad_NEUROSPORA",
      "generic_url" : "http://www.broadinstitute.org/annotation/genome/neurospora/MultiHome.html",
      "datatype" : null
   },
   "sgd_locus" : {
      "url_syntax" : "http://www.yeastgenome.org/locus/[example_id]/overview",
      "url_example" : "http://www.yeastgenome.org/locus/S000006169/overview",
      "datatype" : null,
      "abbreviation" : "SGD_LOCUS",
      "generic_url" : "http://www.yeastgenome.org/",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "name" : null,
      "example_id" : "SGD_LOCUS:GAL4",
      "database" : "Saccharomyces Genome Database",
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null
   },
   "hpa_antibody" : {
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "database" : "Human Protein Atlas antibody information",
      "example_id" : "HPA_antibody:HPA000237",
      "name" : null,
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "abbreviation" : "HPA_antibody",
      "generic_url" : "http://www.proteinatlas.org/",
      "datatype" : null,
      "url_syntax" : "http://www.proteinatlas.org/antibody_info.php?antibody_id=[example_id]",
      "url_example" : "http://www.proteinatlas.org/antibody_info.php?antibody_id=HPA000237"
   },
   "pirsf" : {
      "url_example" : "http://pir.georgetown.edu/cgi-bin/ipcSF?id=SF002327",
      "url_syntax" : "http://pir.georgetown.edu/cgi-bin/ipcSF?id=[example_id]",
      "datatype" : null,
      "generic_url" : "http://pir.georgetown.edu/pirsf/",
      "abbreviation" : "PIRSF",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "name" : null,
      "example_id" : "PIRSF:SF002327",
      "database" : "PIR Superfamily Classification System",
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null
   },
   "subtilist" : {
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "generic_url" : "http://genolist.pasteur.fr/SubtiList/",
      "abbreviation" : "SUBTILIST",
      "datatype" : null,
      "url_example" : null,
      "url_syntax" : null,
      "fullname" : null,
      "entity_type" : "PR:000000001 ! protein",
      "database" : "Bacillus subtilis Genome Sequence Project",
      "example_id" : "SUBTILISTG:BG11384",
      "name" : null
   },
   "locusid" : {
      "entity_type" : "SO:0000704 ! gene",
      "example_id" : "NCBI_Gene:4771",
      "name" : null,
      "database" : "NCBI Gene",
      "fullname" : null,
      "local_id_syntax" : "\\d+",
      "abbreviation" : "LocusID",
      "generic_url" : "http://www.ncbi.nlm.nih.gov/",
      "datatype" : null,
      "url_syntax" : "http://www.ncbi.nlm.nih.gov/sites/entrez?cmd=Retrieve&db=gene&list_uids=[example_id]",
      "url_example" : "http://www.ncbi.nlm.nih.gov/sites/entrez?cmd=Retrieve&db=gene&list_uids=4771",
      "id" : null,
      "uri_prefix" : null,
      "object" : null
   },
   "obi" : {
      "local_id_syntax" : "\\d{7}",
      "fullname" : null,
      "database" : "Ontology for Biomedical Investigations",
      "example_id" : "OBI:0000038",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_syntax" : null,
      "url_example" : null,
      "datatype" : null,
      "abbreviation" : "OBI",
      "generic_url" : "http://obi-ontology.org/page/Main_Page"
   },
   "wormbase" : {
      "name" : null,
      "example_id" : "WB:WBGene00003001",
      "database" : "WormBase database of nematode biology",
      "entity_type" : "PR:000000001 ! protein",
      "local_id_syntax" : "(WP:CE[0-9]{5})|(WB(Gene|Var|RNAi|Transgene)[0-9]{8})",
      "fullname" : null,
      "url_syntax" : "http://www.wormbase.org/db/gene/gene?name=[example_id]",
      "url_example" : "http://www.wormbase.org/db/get?class=Gene;name=WBGene00003001",
      "generic_url" : "http://www.wormbase.org/",
      "abbreviation" : "WormBase",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null
   },
   "sgd" : {
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_syntax" : "http://www.yeastgenome.org/locus/[example_id]/overview",
      "url_example" : "http://www.yeastgenome.org/locus/S000006169/overview",
      "datatype" : null,
      "generic_url" : "http://www.yeastgenome.org/",
      "abbreviation" : "SGD",
      "local_id_syntax" : "S[0-9]{9}",
      "fullname" : null,
      "example_id" : "SGD:S000006169",
      "name" : null,
      "database" : "Saccharomyces Genome Database",
      "entity_type" : "SO:0000704 ! gene"
   },
   "gb" : {
      "entity_type" : "PR:000000001 ! protein",
      "database" : "GenBank",
      "name" : null,
      "example_id" : "GB:AA816246",
      "description" : "The NIH genetic sequence database, an annotated collection of all publicly available DNA sequences.",
      "fullname" : null,
      "local_id_syntax" : "([A-Z]{2}[0-9]{6})|([A-Z]{1}[0-9]{5})",
      "datatype" : null,
      "abbreviation" : "GB",
      "generic_url" : "http://www.ncbi.nlm.nih.gov/Genbank/",
      "url_example" : "http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=nucleotide&val=AA816246",
      "url_syntax" : "http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?db=nucleotide&val=[example_id]",
      "id" : null,
      "object" : null,
      "uri_prefix" : null
   },
   "cog_function" : {
      "fullname" : null,
      "database" : "NCBI COG function",
      "example_id" : "COG_Function:H",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_syntax" : "http://www.ncbi.nlm.nih.gov/COG/grace/shokog.cgi?fun=[example_id]",
      "url_example" : "http://www.ncbi.nlm.nih.gov/COG/grace/shokog.cgi?fun=H",
      "generic_url" : "http://www.ncbi.nlm.nih.gov/COG/",
      "abbreviation" : "COG_Function",
      "datatype" : null
   },
   "gr" : {
      "abbreviation" : "GR",
      "generic_url" : "http://www.gramene.org/",
      "datatype" : null,
      "url_syntax" : "http://www.gramene.org/db/searches/browser?search_type=All&RGN=on&query=[example_id]",
      "url_example" : "http://www.gramene.org/db/searches/browser?search_type=All&RGN=on&query=sd1",
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "entity_type" : "PR:000000001 ! protein",
      "name" : null,
      "example_id" : "GR:sd1",
      "database" : "Gramene",
      "fullname" : null,
      "local_id_syntax" : "[A-Z][0-9][A-Z0-9]{3}[0-9]"
   },
   "iuphar" : {
      "example_id" : null,
      "name" : null,
      "database" : "International Union of Pharmacology",
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null,
      "url_syntax" : null,
      "url_example" : null,
      "abbreviation" : "IUPHAR",
      "generic_url" : "http://www.iuphar.org/",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null
   },
   "uniparc" : {
      "url_example" : "http://www.uniprot.org/uniparc/UPI000000000A",
      "url_syntax" : "http://www.uniprot.org/uniparc/[example_id]",
      "datatype" : null,
      "abbreviation" : "UniParc",
      "generic_url" : "http://www.uniprot.org/uniparc/",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "example_id" : "UniParc:UPI000000000A",
      "database" : "UniProt Archive",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "description" : "A non-redundant archive of protein sequences extracted from Swiss-Prot, TrEMBL, PIR-PSD, EMBL, Ensembl, IPI, PDB, RefSeq, FlyBase, WormBase, European Patent Office, United States Patent and Trademark Office, and Japanese Patent Office",
      "fullname" : null
   },
   "psi-mod" : {
      "abbreviation" : "PSI-MOD",
      "generic_url" : "http://psidev.sourceforge.net/mod/",
      "datatype" : null,
      "url_syntax" : "http://www.ebi.ac.uk/ontology-lookup/?termId=MOD:[example_id]",
      "url_example" : "http://www.ebi.ac.uk/ontology-lookup/?termId=MOD:00219",
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "MOD:00219",
      "database" : "Proteomics Standards Initiative protein modification ontology",
      "name" : null,
      "fullname" : null
   },
   "gr_gene" : {
      "url_syntax" : "http://www.gramene.org/db/genes/search_gene?acc=[example_id]",
      "url_example" : "http://www.gramene.org/db/genes/search_gene?acc=GR:0060198",
      "generic_url" : "http://www.gramene.org/",
      "abbreviation" : "GR_gene",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "example_id" : "GR_GENE:GR:0060198",
      "name" : null,
      "database" : "Gramene",
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null
   },
   "vz" : {
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "abbreviation" : "VZ",
      "generic_url" : "http://viralzone.expasy.org/",
      "url_example" : "http://viralzone.expasy.org/all_by_protein/957.html",
      "url_syntax" : "http://viralzone.expasy.org/all_by_protein/[example_id].html",
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "VZ:957",
      "database" : "ViralZone",
      "name" : null
   },
   "cgd_ref" : {
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "name" : null,
      "example_id" : "CGD_REF:1490",
      "database" : "Candida Genome Database",
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "generic_url" : "http://www.candidagenome.org/",
      "abbreviation" : "CGD_REF",
      "url_example" : "http://www.candidagenome.org/cgi-bin/reference/reference.pl?dbid=1490",
      "url_syntax" : "http://www.candidagenome.org/cgi-bin/reference/reference.pl?dbid=[example_id]"
   },
   "aspgd" : {
      "entity_type" : "SO:0000704 ! gene",
      "example_id" : "AspGD:ASPL0000067538",
      "database" : "Aspergillus Genome Database",
      "name" : null,
      "fullname" : null,
      "local_id_syntax" : "ASPL[0-9]{10}",
      "datatype" : null,
      "generic_url" : "http://www.aspergillusgenome.org/",
      "abbreviation" : "AspGD",
      "url_example" : "http://www.aspergillusgenome.org/cgi-bin/locus.pl?dbid=ASPL0000067538",
      "url_syntax" : "http://www.aspergillusgenome.org/cgi-bin/locus.pl?dbid=[example_id]",
      "id" : null,
      "object" : null,
      "uri_prefix" : null
   },
   "cas_gen" : {
      "entity_type" : "BET:0000000 ! entity",
      "database" : "Catalog of Fishes genus database",
      "example_id" : "CASGEN:1040",
      "name" : null,
      "fullname" : null,
      "generic_url" : "http://research.calacademy.org/research/ichthyology/catalog/fishcatsearch.html",
      "abbreviation" : "CAS_GEN",
      "datatype" : null,
      "url_example" : "http://research.calacademy.org/research/ichthyology/catalog/getname.asp?rank=Genus&id=1040",
      "url_syntax" : "http://research.calacademy.org/research/ichthyology/catalog/getname.asp?rank=Genus&id=[example_id]",
      "id" : null,
      "uri_prefix" : null,
      "object" : null
   },
   "cas" : {
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_example" : null,
      "url_syntax" : null,
      "datatype" : null,
      "abbreviation" : "CAS",
      "generic_url" : "http://www.cas.org/expertise/cascontent/registry/index.html",
      "description" : "CAS REGISTRY is the most authoritative collection of disclosed chemical substance information, containing more than 54 million organic and inorganic substances and 62 million sequences. CAS REGISTRY covers substances identified from the scientific literature from 1957 to the present, with additional substances going back to the early 1900s.",
      "fullname" : null,
      "example_id" : "CAS:58-08-2",
      "database" : "CAS Chemical Registry",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity"
   },
   "vida" : {
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_example" : null,
      "url_syntax" : null,
      "datatype" : null,
      "abbreviation" : "VIDA",
      "generic_url" : "http://www.biochem.ucl.ac.uk/bsm/virus_database/VIDA.html",
      "fullname" : null,
      "example_id" : null,
      "name" : null,
      "database" : "Virus Database at University College London",
      "entity_type" : "BET:0000000 ! entity"
   },
   "gene3d" : {
      "datatype" : null,
      "generic_url" : "http://gene3d.biochem.ucl.ac.uk/Gene3D/",
      "abbreviation" : "Gene3D",
      "url_example" : "http://gene3d.biochem.ucl.ac.uk/superfamily/?accession=G3DSA%3A3.30.390.30",
      "url_syntax" : "http://gene3d.biochem.ucl.ac.uk/superfamily/?accession=[example_id]",
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "entity_type" : "BET:0000000 ! entity",
      "name" : null,
      "example_id" : "Gene3D:G3DSA:3.30.390.30",
      "database" : "Domain Architecture Classification",
      "fullname" : null
   },
   "ecocyc" : {
      "url_example" : "http://biocyc.org/ECOLI/NEW-IMAGE?type=PATHWAY&object=P2-PWY",
      "url_syntax" : "http://biocyc.org/ECOLI/NEW-IMAGE?type=PATHWAY&object=[example_id]",
      "datatype" : null,
      "generic_url" : "http://ecocyc.org/",
      "abbreviation" : "EcoCyc",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "name" : null,
      "example_id" : "EcoCyc:P2-PWY",
      "database" : "Encyclopedia of E. coli metabolism",
      "entity_type" : "GO:0008150 ! biological_process",
      "local_id_syntax" : "EG[0-9]{5}",
      "fullname" : null
   },
   "ecocyc_ref" : {
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_example" : "http://biocyc.org/ECOLI/reference.html?type=CITATION-FRAME&object=COLISALII",
      "url_syntax" : "http://biocyc.org/ECOLI/reference.html?type=CITATION-FRAME&object=[example_id]",
      "abbreviation" : "ECOCYC_REF",
      "generic_url" : "http://ecocyc.org/",
      "datatype" : null,
      "fullname" : null,
      "database" : "Encyclopedia of E. coli metabolism",
      "name" : null,
      "example_id" : "EcoCyc_REF:COLISALII",
      "entity_type" : "BET:0000000 ! entity"
   },
   "tgd" : {
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_syntax" : null,
      "url_example" : null,
      "datatype" : null,
      "generic_url" : "http://www.ciliate.org/",
      "abbreviation" : "TGD",
      "fullname" : null,
      "example_id" : null,
      "database" : "Tetrahymena Genome Database",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity"
   },
   "geneid" : {
      "entity_type" : "SO:0000704 ! gene",
      "name" : null,
      "database" : "NCBI Gene",
      "example_id" : "NCBI_Gene:4771",
      "fullname" : null,
      "local_id_syntax" : "\\d+",
      "datatype" : null,
      "abbreviation" : "GeneID",
      "generic_url" : "http://www.ncbi.nlm.nih.gov/",
      "url_example" : "http://www.ncbi.nlm.nih.gov/sites/entrez?cmd=Retrieve&db=gene&list_uids=4771",
      "url_syntax" : "http://www.ncbi.nlm.nih.gov/sites/entrez?cmd=Retrieve&db=gene&list_uids=[example_id]",
      "id" : null,
      "object" : null,
      "uri_prefix" : null
   },
   "cacao" : {
      "url_example" : "http://gowiki.tamu.edu/wiki/index.php/MYCS2:A0QNF5",
      "url_syntax" : "http://gowiki.tamu.edu/wiki/index.php/[example_id]",
      "datatype" : null,
      "generic_url" : "http://gowiki.tamu.edu/wiki/index.php/Category:CACAO",
      "abbreviation" : "CACAO",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "example_id" : "MYCS2:A0QNF5",
      "name" : null,
      "database" : "Community Assessment of Community Annotation with Ontologies",
      "entity_type" : "BET:0000000 ! entity",
      "description" : "The Community Assessment of Community Annotation with Ontologies (CACAO) is a project to do large-scale manual community annotation of gene function using the Gene Ontology as a multi-institution student competition.",
      "fullname" : null
   },
   "intact" : {
      "entity_type" : "GO:0043234 ! protein complex",
      "name" : null,
      "example_id" : "IntAct:EBI-17086",
      "database" : "IntAct protein interaction database",
      "fullname" : null,
      "local_id_syntax" : "EBI-[0-9]+",
      "datatype" : null,
      "abbreviation" : "IntAct",
      "generic_url" : "http://www.ebi.ac.uk/intact/",
      "url_example" : "http://www.ebi.ac.uk/intact/search/do/search?searchString=EBI-17086",
      "url_syntax" : "http://www.ebi.ac.uk/intact/search/do/search?searchString=[example_id]",
      "id" : null,
      "object" : null,
      "uri_prefix" : null
   },
   "wb" : {
      "generic_url" : "http://www.wormbase.org/",
      "abbreviation" : "WB",
      "datatype" : null,
      "url_example" : "http://www.wormbase.org/db/get?class=Gene;name=WBGene00003001",
      "url_syntax" : "http://www.wormbase.org/db/gene/gene?name=[example_id]",
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "entity_type" : "PR:000000001 ! protein",
      "database" : "WormBase database of nematode biology",
      "example_id" : "WB:WBGene00003001",
      "name" : null,
      "fullname" : null,
      "local_id_syntax" : "(WP:CE[0-9]{5})|(WB(Gene|Var|RNAi|Transgene)[0-9]{8})"
   },
   "germonline" : {
      "fullname" : null,
      "example_id" : null,
      "name" : null,
      "database" : "GermOnline",
      "entity_type" : "BET:0000000 ! entity",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_syntax" : null,
      "url_example" : null,
      "datatype" : null,
      "abbreviation" : "GermOnline",
      "generic_url" : "http://www.germonline.org/"
   },
   "broad_mgg" : {
      "example_id" : "Broad_MGG:MGG_05132.5",
      "database" : "Magnaporthe grisea Database",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null,
      "description" : "Magnaporthe grisea Database at the Broad Institute",
      "url_syntax" : "http://www.broad.mit.edu/annotation/genome/magnaporthe_grisea/GeneLocus.html?sp=S[example_id]",
      "url_example" : "http://www.broad.mit.edu/annotation/genome/magnaporthe_grisea/GeneLocus.html?sp=SMGG_05132",
      "generic_url" : "http://www.broad.mit.edu/annotation/genome/magnaporthe_grisea/Home.html",
      "abbreviation" : "Broad_MGG",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null
   },
   "casgen" : {
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "generic_url" : "http://research.calacademy.org/research/ichthyology/catalog/fishcatsearch.html",
      "abbreviation" : "CASGEN",
      "url_example" : "http://research.calacademy.org/research/ichthyology/catalog/getname.asp?rank=Genus&id=1040",
      "url_syntax" : "http://research.calacademy.org/research/ichthyology/catalog/getname.asp?rank=Genus&id=[example_id]",
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "name" : null,
      "example_id" : "CASGEN:1040",
      "database" : "Catalog of Fishes genus database"
   },
   "gr_protein" : {
      "abbreviation" : "GR_protein",
      "generic_url" : "http://www.gramene.org/",
      "datatype" : null,
      "url_syntax" : "http://www.gramene.org/db/protein/protein_search?acc=[example_id]",
      "url_example" : "http://www.gramene.org/db/protein/protein_search?acc=Q6VSV0",
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "entity_type" : "PR:000000001 ! protein",
      "name" : null,
      "database" : "Gramene",
      "example_id" : "GR_PROTEIN:Q6VSV0",
      "fullname" : null,
      "local_id_syntax" : "[A-Z][0-9][A-Z0-9]{3}[0-9]"
   },
   "ma" : {
      "fullname" : null,
      "description" : "Adult Mouse Anatomical Dictionary; part of Gene Expression Database",
      "name" : null,
      "example_id" : "MA:0000003",
      "database" : "Adult Mouse Anatomical Dictionary",
      "entity_type" : "BET:0000000 ! entity",
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_example" : "http://www.informatics.jax.org/searches/AMA.cgi?id=MA:0000003",
      "url_syntax" : "http://www.informatics.jax.org/searches/AMA.cgi?id=MA:[example_id]",
      "generic_url" : "http://www.informatics.jax.org/",
      "abbreviation" : "MA",
      "datatype" : null
   },
   "syscilia_ccnet" : {
      "description" : "A systems biology approach to dissect cilia function and its disruption in human genetic disease",
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : null,
      "name" : null,
      "database" : "Syscilia",
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "abbreviation" : "SYSCILIA_CCNET",
      "generic_url" : "http://syscilia.org/",
      "url_syntax" : null,
      "url_example" : null
   },
   "gorel" : {
      "url_example" : null,
      "url_syntax" : null,
      "datatype" : null,
      "generic_url" : "http://purl.obolibrary.org/obo/ro",
      "abbreviation" : "GOREL",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "database" : "GO Extensions to OBO Relation Ontology Ontology",
      "example_id" : null,
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "description" : "Additional relations pending addition into RO",
      "fullname" : null
   },
   "dictybase_ref" : {
      "datatype" : null,
      "generic_url" : "http://dictybase.org",
      "abbreviation" : "dictyBase_REF",
      "url_syntax" : "http://dictybase.org/db/cgi-bin/dictyBase/reference/reference.pl?refNo=[example_id]",
      "url_example" : "http://dictybase.org/db/cgi-bin/dictyBase/reference/reference.pl?refNo=10157",
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "dictyBase_REF:10157",
      "name" : null,
      "database" : "dictyBase literature references",
      "fullname" : null
   },
   "cazy" : {
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "abbreviation" : "CAZY",
      "generic_url" : "http://www.cazy.org/",
      "url_example" : "http://www.cazy.org/PL11.html",
      "url_syntax" : "http://www.cazy.org/[example_id].html",
      "description" : "The CAZy database describes the families of structurally-related catalytic and carbohydrate-binding modules (or functional domains) of enzymes that degrade, modify, or create glycosidic bonds.",
      "fullname" : null,
      "local_id_syntax" : "(CE|GH|GT|PL)\\d+",
      "entity_type" : "BET:0000000 ! entity",
      "database" : "Carbohydrate Active EnZYmes",
      "example_id" : "CAZY:PL11",
      "name" : null
   },
   "po" : {
      "database" : "Plant Ontology Consortium Database",
      "example_id" : "PO:0009004",
      "name" : null,
      "entity_type" : "PO:0009012 ! plant structure development stage",
      "local_id_syntax" : "[0-9]{7}",
      "fullname" : null,
      "url_syntax" : "http://www.plantontology.org/amigo/go.cgi?action=query&view=query&search_constraint=terms&query=PO:[example_id]",
      "url_example" : "http://www.plantontology.org/amigo/go.cgi?action=query&view=query&search_constraint=terms&query=PO:0009004",
      "generic_url" : "http://www.plantontology.org/",
      "abbreviation" : "PO",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null
   },
   "ipr" : {
      "local_id_syntax" : "IPR\\d{6}",
      "fullname" : null,
      "database" : "InterPro database of protein domains and motifs",
      "example_id" : "InterPro:IPR000001",
      "name" : null,
      "entity_type" : "SO:0000839 ! polypeptide region",
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_syntax" : "http://www.ebi.ac.uk/interpro/entry/[example_id]",
      "url_example" : "http://www.ebi.ac.uk/interpro/entry/IPR015421",
      "generic_url" : "http://www.ebi.ac.uk/interpro/",
      "abbreviation" : "IPR",
      "datatype" : null
   },
   "phi" : {
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "PHI:0000055",
      "name" : null,
      "database" : "MeGO (Phage and Mobile Element Ontology)",
      "id" : null,
      "object" : null,
      "uri_prefix" : null,
      "datatype" : null,
      "generic_url" : "http://aclame.ulb.ac.be/Classification/mego.html",
      "abbreviation" : "PHI",
      "url_syntax" : null,
      "url_example" : null
   },
   "casspc" : {
      "fullname" : null,
      "database" : "Catalog of Fishes species database",
      "example_id" : null,
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_example" : "http://research.calacademy.org/research/ichthyology/catalog/getname.asp?rank=Species&id=1979",
      "url_syntax" : "http://research.calacademy.org/research/ichthyology/catalog/getname.asp?rank=Species&id=[example_id]",
      "abbreviation" : "CASSPC",
      "generic_url" : "http://research.calacademy.org/research/ichthyology/catalog/fishcatsearch.html",
      "datatype" : null
   },
   "genprotec" : {
      "fullname" : null,
      "name" : null,
      "example_id" : null,
      "database" : "GenProtEC E. coli genome and proteome database",
      "entity_type" : "BET:0000000 ! entity",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_syntax" : null,
      "url_example" : null,
      "datatype" : null,
      "generic_url" : "http://genprotec.mbl.edu/",
      "abbreviation" : "GenProtEC"
   },
   "locsvmpsi" : {
      "description" : "Subcellular localization for eukayotic proteins based on SVM and PSI-BLAST",
      "fullname" : null,
      "name" : null,
      "example_id" : null,
      "database" : "LOCSVMPSI",
      "entity_type" : "BET:0000000 ! entity",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_example" : null,
      "url_syntax" : null,
      "datatype" : null,
      "generic_url" : "http://bioinformatics.ustc.edu.cn/locsvmpsi/locsvmpsi.php",
      "abbreviation" : "LOCSVMpsi"
   },
   "fma" : {
      "database" : "Foundational Model of Anatomy",
      "example_id" : "FMA:61905",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null,
      "url_syntax" : null,
      "url_example" : null,
      "datatype" : null,
      "abbreviation" : "FMA",
      "generic_url" : "http://sig.biostr.washington.edu/projects/fm/index.html",
      "object" : null,
      "uri_prefix" : null,
      "id" : null
   },
   "wbphenotype" : {
      "example_id" : "WBPhenotype:0002117",
      "database" : "WormBase phenotype ontology",
      "name" : null,
      "entity_type" : "PATO:0000001 ! quality",
      "local_id_syntax" : "[0-9]{7}",
      "fullname" : null,
      "url_syntax" : "http://www.wormbase.org/species/c_elegans/phenotype/WBPhenotype:[example_id]",
      "url_example" : "http://www.wormbase.org/species/c_elegans/phenotype/WBPhenotype:0000154",
      "generic_url" : "http://www.wormbase.org/",
      "abbreviation" : "WBPhenotype",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null
   },
   "pamgo_gat" : {
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "PAMGO_GAT:Atu0001",
      "name" : null,
      "database" : "Genome Annotation Tool (Agrobacterium tumefaciens C58); PAMGO Interest Group",
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "generic_url" : "http://agro.vbi.vt.edu/public/",
      "abbreviation" : "PAMGO_GAT",
      "datatype" : null,
      "url_example" : "http://agro.vbi.vt.edu/public/servlet/GeneEdit?&Search=Search&level=2&genename=atu0001",
      "url_syntax" : "http://agro.vbi.vt.edu/public/servlet/GeneEdit?&Search=Search&level=2&genename=[example_id]"
   },
   "pmcid" : {
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_example" : "http://www.ncbi.nlm.nih.gov/sites/entrez?db=pmc&cmd=search&term=PMC201377",
      "url_syntax" : "http://www.ncbi.nlm.nih.gov/sites/entrez?db=pmc&cmd=search&term=[example_id]",
      "datatype" : null,
      "abbreviation" : "PMCID",
      "generic_url" : "http://www.pubmedcentral.nih.gov/",
      "fullname" : null,
      "database" : "Pubmed Central",
      "example_id" : "PMCID:PMC201377",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity"
   },
   "kegg" : {
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_example" : null,
      "url_syntax" : null,
      "abbreviation" : "KEGG",
      "generic_url" : "http://www.genome.ad.jp/kegg/",
      "datatype" : null,
      "fullname" : null,
      "example_id" : null,
      "name" : null,
      "database" : "Kyoto Encyclopedia of Genes and Genomes",
      "entity_type" : "BET:0000000 ! entity"
   },
   "psi-mi" : {
      "url_example" : null,
      "url_syntax" : null,
      "generic_url" : "http://psidev.sourceforge.net/mi/xml/doc/user/index.html",
      "abbreviation" : "PSI-MI",
      "datatype" : null,
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "example_id" : "MI:0018",
      "name" : null,
      "database" : "Proteomic Standard Initiative for Molecular Interaction",
      "entity_type" : "BET:0000000 ! entity",
      "fullname" : null
   },
   "asap" : {
      "fullname" : null,
      "database" : "A Systematic Annotation Package for Community Analysis of Genomes",
      "example_id" : "ASAP:ABE-0000008",
      "name" : null,
      "entity_type" : "SO:0000704 ! gene",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_syntax" : "https://asap.ahabs.wisc.edu/annotation/php/feature_info.php?FeatureID=[example_id]",
      "url_example" : "https://asap.ahabs.wisc.edu/annotation/php/feature_info.php?FeatureID=ABE-0000008",
      "datatype" : null,
      "generic_url" : "https://asap.ahabs.wisc.edu/annotation/php/ASAP1.htm",
      "abbreviation" : "ASAP"
   },
   "rebase" : {
      "abbreviation" : "REBASE",
      "generic_url" : "http://rebase.neb.com/rebase/rebase.html",
      "datatype" : null,
      "url_syntax" : "http://rebase.neb.com/rebase/enz/[example_id].html",
      "url_example" : "http://rebase.neb.com/rebase/enz/EcoRI.html",
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "REBASE:EcoRI",
      "database" : "REBASE restriction enzyme database",
      "name" : null,
      "fullname" : null
   },
   "ensembl_proteinid" : {
      "url_syntax" : "http://www.ensembl.org/id/[example_id]",
      "url_example" : "http://www.ensembl.org/id/ENSP00000361027",
      "datatype" : null,
      "generic_url" : "http://www.ensembl.org/",
      "abbreviation" : "ENSEMBL_ProteinID",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "example_id" : "ENSEMBL_ProteinID:ENSP00000361027",
      "database" : "Ensembl database of automatically annotated genomic data",
      "name" : null,
      "entity_type" : "PR:000000001 ! protein",
      "local_id_syntax" : "ENSP[0-9]{9,16}",
      "fullname" : null
   },
   "ena" : {
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "abbreviation" : "ENA",
      "generic_url" : "http://www.ebi.ac.uk/ena/",
      "datatype" : null,
      "url_syntax" : "http://www.ebi.ac.uk/ena/data/view/[example_id]",
      "url_example" : "http://www.ebi.ac.uk/ena/data/view/AA816246",
      "fullname" : null,
      "description" : "ENA is made up of a number of distinct databases that includes EMBL-Bank, the newly established Sequence Read Archive (SRA) and the Trace Archive. International nucleotide sequence database collaboration, comprising ENA-EBI nucleotide sequence data library (EMBL-Bank), DNA DataBank of Japan (DDBJ), and NCBI GenBank",
      "local_id_syntax" : "([A-Z]{1}[0-9]{5})|([A-Z]{2}[0-9]{6})|([A-Z]{4}[0-9]{8,9})",
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "ENA:AA816246",
      "database" : "European Nucleotide Archive",
      "name" : null
   },
   "go_ref" : {
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "generic_url" : "http://www.geneontology.org/",
      "abbreviation" : "GO_REF",
      "datatype" : null,
      "url_syntax" : "http://www.geneontology.org/cgi-bin/references.cgi#GO_REF:[example_id]",
      "url_example" : "http://www.geneontology.org/cgi-bin/references.cgi#GO_REF:0000001",
      "fullname" : null,
      "local_id_syntax" : "\\d{7}",
      "entity_type" : "BET:0000000 ! entity",
      "database" : "Gene Ontology Database references",
      "example_id" : "GO_REF:0000001",
      "name" : null
   },
   "sanger" : {
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_syntax" : null,
      "url_example" : null,
      "datatype" : null,
      "generic_url" : "http://www.sanger.ac.uk/",
      "abbreviation" : "Sanger",
      "fullname" : null,
      "example_id" : null,
      "name" : null,
      "database" : "Wellcome Trust Sanger Institute",
      "entity_type" : "BET:0000000 ! entity"
   },
   "vega" : {
      "entity_type" : "BET:0000000 ! entity",
      "name" : null,
      "example_id" : "VEGA:OTTHUMP00000000661",
      "database" : "Vertebrate Genome Annotation database",
      "fullname" : null,
      "abbreviation" : "VEGA",
      "generic_url" : "http://vega.sanger.ac.uk/index.html",
      "datatype" : null,
      "url_example" : "http://vega.sanger.ac.uk/perl/searchview?species=all&idx=All&q=OTTHUMP00000000661",
      "url_syntax" : "http://vega.sanger.ac.uk/perl/searchview?species=all&idx=All&q=[example_id]",
      "id" : null,
      "uri_prefix" : null,
      "object" : null
   },
   "modbase" : {
      "generic_url" : "http://modbase.compbio.ucsf.edu/",
      "abbreviation" : "ModBase",
      "datatype" : null,
      "url_syntax" : "http://salilab.org/modbase/searchbyid?databaseID=[example_id]",
      "url_example" : "http://salilab.org/modbase/searchbyid?databaseID=P04848",
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "entity_type" : "BET:0000000 ! entity",
      "database" : "ModBase comprehensive Database of Comparative Protein Structure Models",
      "example_id" : "ModBase:P10815",
      "name" : null,
      "fullname" : null
   },
   "ro" : {
      "description" : "A collection of relations used across OBO ontologies",
      "fullname" : null,
      "database" : "OBO Relation Ontology Ontology",
      "example_id" : "RO:0002211",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_example" : "http://purl.obolibrary.org/obo/RO_0002211",
      "url_syntax" : "http://purl.obolibrary.org/obo/RO_[example_id]",
      "datatype" : null,
      "generic_url" : "http://purl.obolibrary.org/obo/ro",
      "abbreviation" : "RO"
   },
   "imgt_hla" : {
      "fullname" : null,
      "entity_type" : "BET:0000000 ! entity",
      "example_id" : "IMGT_HLA:HLA00031",
      "name" : null,
      "database" : "IMGT/HLA human major histocompatibility complex sequence database",
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "abbreviation" : "IMGT_HLA",
      "generic_url" : "http://www.ebi.ac.uk/imgt/hla",
      "datatype" : null,
      "url_syntax" : null,
      "url_example" : null
   },
   "fb" : {
      "uri_prefix" : null,
      "object" : null,
      "id" : null,
      "url_example" : "http://flybase.org/reports/FBgn0000024.html",
      "url_syntax" : "http://flybase.org/reports/[example_id].html",
      "abbreviation" : "FB",
      "generic_url" : "http://flybase.org/",
      "datatype" : null,
      "local_id_syntax" : "FBgn[0-9]{7}",
      "fullname" : null,
      "database" : "FlyBase",
      "example_id" : "FB:FBgn0000024",
      "name" : null,
      "entity_type" : "SO:0000704 ! gene"
   },
   "geo" : {
      "abbreviation" : "GEO",
      "generic_url" : "http://www.ncbi.nlm.nih.gov/geo/",
      "datatype" : null,
      "url_syntax" : "http://www.ncbi.nlm.nih.gov/sites/GDSbrowser?acc=[example_id]",
      "url_example" : "http://www.ncbi.nlm.nih.gov/sites/GDSbrowser?acc=GDS2223",
      "id" : null,
      "uri_prefix" : null,
      "object" : null,
      "entity_type" : "BET:0000000 ! entity",
      "database" : "NCBI Gene Expression Omnibus",
      "example_id" : "GEO:GDS2223",
      "name" : null,
      "fullname" : null
   },
   "chebi" : {
      "local_id_syntax" : "[0-9]{1,6}",
      "fullname" : null,
      "example_id" : "CHEBI:17234",
      "name" : null,
      "database" : "Chemical Entities of Biological Interest",
      "entity_type" : "CHEBI:24431 ! chemical entity",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_example" : "http://www.ebi.ac.uk/chebi/searchId.do?chebiId=CHEBI:17234",
      "url_syntax" : "http://www.ebi.ac.uk/chebi/searchId.do?chebiId=CHEBI:[example_id]",
      "datatype" : null,
      "generic_url" : "http://www.ebi.ac.uk/chebi/",
      "abbreviation" : "ChEBI"
   },
   "um-bbd_enzymeid" : {
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "url_example" : "http://umbbd.msi.umn.edu/servlets/pageservlet?ptype=ep&enzymeID=e0230",
      "url_syntax" : "http://umbbd.msi.umn.edu/servlets/pageservlet?ptype=ep&enzymeID=[example_id]",
      "datatype" : null,
      "abbreviation" : "UM-BBD_enzymeID",
      "generic_url" : "http://umbbd.msi.umn.edu/",
      "fullname" : null,
      "example_id" : "UM-BBD_enzymeID:e0413",
      "name" : null,
      "database" : "University of Minnesota Biocatalysis/Biodegradation Database",
      "entity_type" : "BET:0000000 ! entity"
   },
   "kegg_enzyme" : {
      "url_example" : "http://www.genome.jp/dbget-bin/www_bget?ec:2.1.1.4",
      "url_syntax" : "http://www.genome.jp/dbget-bin/www_bget?ec:[example_id]",
      "datatype" : null,
      "generic_url" : "http://www.genome.jp/dbget-bin/www_bfind?enzyme",
      "abbreviation" : "KEGG_ENZYME",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "database" : "KEGG Enzyme Database",
      "example_id" : "KEGG_ENZYME:2.1.1.4",
      "name" : null,
      "entity_type" : "BET:0000000 ! entity",
      "local_id_syntax" : "\\d(\\.\\d{1,2}){2}\\.\\d{1,3}",
      "fullname" : null
   },
   "pr" : {
      "url_syntax" : "http://www.proconsortium.org/cgi-bin/pro/entry_pro?id=PR:[example_id]",
      "url_example" : "http://www.proconsortium.org/cgi-bin/pro/entry_pro?id=PR:000025380",
      "datatype" : null,
      "generic_url" : "http://www.proconsortium.org/pro/pro.shtml",
      "abbreviation" : "PR",
      "object" : null,
      "uri_prefix" : null,
      "id" : null,
      "database" : "Protein Ontology",
      "example_id" : "PR:000025380",
      "name" : null,
      "entity_type" : "PR:000000001 ! protein",
      "local_id_syntax" : "[0-9]{9}",
      "fullname" : null
   }
};
/* 
 * Package: dispatch.js
 * 
 * Namespace: amigo.data.dispatch
 * 
 * This package was automatically created during an AmiGO 2 installation
 * from the YAML configuration files that AmiGO pulls in.
 *
 * The mapping file for data fields and contexts to functions, often
 * used for displays. See the package <handler.js> for the API to interact
 * with this data file.
 *
 * NOTE: This file is generated dynamically at installation time.
 * Hard to work with unit tests--hope it's not too bad. You have to
 * occasionally copy back to keep the unit tests sane.
 *
 * NOTE: This file has a slightly different latout from the YAML
 * configuration file.
 */

// All of the server/instance-specific meta-data.
if ( typeof amigo == "undefined" ){ var amigo = {}; }
if ( typeof amigo.data == "undefined" ){ amigo.data = {}; }

/*
 * Variable: dispatch
 * 
 * The configuration for the data.
 * Essentially a JSONification of the YAML file.
 * This should be consumed directly by <amigo.handler>.
 */
amigo.data.dispatch = {
   "qualifier" : {
      "context" : {
         "bbop.widgets.search_pane" : "amigo.handlers.qualifiers"
      }
   },
   "annotation_extension_json" : {
      "context" : {
         "bbop.widgets.search_pane" : "amigo.handlers.owl_class_expression"
      }
   }
};
/*
 * Package: context.js
 * 
 * Namespace: amigo.data.context
 * 
 * Another context.
 */

// Module and namespace checking.
if ( typeof amigo == "undefined" ){ var amigo = {}; }
if ( typeof amigo.data == "undefined" ){ amigo.data = {}; }

/*
 * Variable: context
 * 
 * Colors are X11: http://cng.seas.rochester.edu/CNG/docs/x11color.html
 */
amigo.data.context = {
    'instance_of':
    {
	readable: 'activity',
	priority: 8,
	aliases: [
	    'activity'
	],
	color: '#FFFAFA' // snow
    },
    'BFO:0000050':
    {
	readable: 'part of',
	priority: 15,
	aliases: [
		//'http://purl.obolibrary.org/obo/BFO_0000050',
		//'http://purl.obolibrary.org/obo/part_of',
	    'BFO_0000050',
	    'part:of',
	    'part of',
	    'part_of'
	],
	color: '#add8e6' // light blue
    },
    'BFO:0000051':
    {
	readable: 'has part',
	priority: 4,
	aliases: [
		//'http://purl.obolibrary.org/obo/BFO_0000051',
	    'has:part',
	    'has part',
	    'has_part'
	],
	color: '#6495ED' // cornflower blue
    },
    'BFO:0000066':
    {
	readable: 'occurs in',
	priority: 12,
	aliases: [
		//'http://purl.obolibrary.org/obo/BFO_0000066',
		//'BFO_0000066',
	    'occurs:in',
	    'occurs in',
	    'occurs_in'
	],
	color: '#66CDAA' // medium aquamarine
    },
    'RO:0002202':
    {
	readable: 'develops from',
	priority: 0,
	aliases: [
	    'develops:from',
	    'develops from',
	    'develops_from'
	],
	color: '#A52A2A' // brown
    },
    'RO:0002211':
    {
	readable: 'regulates',
	priority: 16,
	aliases: [
		//'http://purl.obolibrary.org/obo/RO_0002211'
	    'regulates'
	],
	color: '#2F4F4F' // dark slate grey
    },
    'RO:0002212':
    {
	readable: 'negatively regulates',
	priority: 17,
	aliases: [
		//'http://purl.obolibrary.org/obo/RO_0002212'
	    'negatively:regulates',
	    'negatively regulates',
	    'negatively_regulates'
	],
	glyph: 'bar',
	color: '#FF0000' // red
    },
    'RO:0002213':
    {
	readable: 'positively regulates',
	priority: 18,
	aliases: [
		//'http://purl.obolibrary.org/obo/RO_0002213'
	    'positively:regulates',
	    'positively regulates',
	    'positively_regulates'
	],
	glyph: 'arrow',
	color: '#008000' //green
    },
    'RO:0002233':
    {
	readable: 'has input',
	priority: 14,
	aliases: [
		//'http://purl.obolibrary.org/obo/BFO_0000051',
	    'has:input',
	    'has input',
	    'has_input'
	],
	color: '#6495ED' // cornflower blue
    },
    'RO:0002234':
    {
	readable: 'has output',
	priority: 0,
	aliases: [
	    'has:output',
	    'has output',
	    'has_output'
	],
	color: '#ED6495' // ??? - random
    },
    'RO:0002330':
    {
	readable: 'genomically related to',
	priority: 0,
	aliases: [
	    'genomically related to',
	    'genomically_related_to'
	],
	color: '#9932CC' // darkorchid
    },
    'RO:0002331':
    {
	readable: 'involved in',
	priority: 3,
	aliases: [
	    'involved:in',
	    'involved in',
	    'involved_in'
	],
	color: '#E9967A' // darksalmon
    },
    'RO:0002332':
    {
	readable: 'regulates level of',
	priority: 0,
	aliases: [
	    'regulates level of',
	    'regulates_level_of'
	],
	color: '#556B2F' // darkolivegreen
    },
    'RO:0002333':
    {
	readable: 'enabled by',
	priority: 13,
	aliases: [
	    'RO_0002333',
	    'enabled:by',
	    'enabled by',
	    'enabled_by'
	],
	color: '#B8860B' // darkgoldenrod
    },
    'RO:0002334':
    {
	readable: 'regulated by',
	priority: 0,
	aliases: [
	    'RO_0002334',
	    'regulated by',
	    'regulated_by'
	],
	color: '#86B80B' // ??? - random
    },
    'RO:0002335':
    {
	readable: 'negatively regulated by',
	priority: 0,
	aliases: [
	    'RO_0002335',
	    'negatively regulated by',
	    'negatively_regulated_by'
	],
	color: '#0B86BB' // ??? - random
    },
    'RO:0002336':
    {
	readable: 'positively regulated by',
	priority: 0,
	aliases: [
	    'RO_0002336',
	    'positively regulated by',
	    'positively_regulated_by'
	],
	color: '#BB0B86' // ??? - random
    },
    'activates':
    {
	readable: 'activates',
	priority: 0,
	aliases: [
	    'http://purl.obolibrary.org/obo/activates'
	],
	//glyph: 'arrow',
	//glyph: 'diamond',
	//glyph: 'wedge',
	//glyph: 'bar',
	color: '#8FBC8F' // darkseagreen
    },
    'RO:0002404':
    {
	readable: 'causally downstream of',
	priority: 2,
	aliases: [
	    'causally_downstream_of'
	],
	color: '#FF1493' // deeppink
    },
    'RO:0002406':
    {
	readable: 'directly activates',
	priority: 20,
	aliases: [
		//'http://purl.obolibrary.org/obo/directly_activates',
	    'directly:activates',
	    'directly activates',
	    'directly_activates'
	],
	glyph: 'arrow',
	color: '#2F4F4F' // darkslategray
    },
    'upstream_of':
    {
	readable: 'upstream of',
	priority: 2,
	aliases: [
		//'http://purl.obolibrary.org/obo/upstream_of'
	    'upstream:of',
	    'upstream of',
	    'upstream_of'
	],
	color: '#FF1493' // deeppink
    },
    'RO:0002408':
    {
	readable: 'directly inhibits',
	priority: 19,
	aliases: [
		//'http://purl.obolibrary.org/obo/directly_inhibits'
	    'directly:inhibits',
	    'directly inhibits',
	    'directly_inhibits'
	],
	glyph: 'bar',
	color: '#7FFF00' // chartreuse
    },
    'RO:0002411':
    {
	readable: 'causally upstream of',
	priority: 2,
	aliases: [
	    'causally_upstream_of'
	],
	color: '#483D8B' // darkslateblue
    },
    'indirectly_disables_action_of':
    {
	readable: 'indirectly disables action of',
	priority: 0,
	aliases: [
		//'http://purl.obolibrary.org/obo/indirectly_disables_action_of'
	    'indirectly disables action of',
	    'indirectly_disables_action_of'
	],
	color: '#483D8B' // darkslateblue
    },
    'provides_input_for':
    {
	readable: 'provides input for',
	priority: 0,
	aliases: [
	    'GOREL_provides_input_for',
	    'http://purl.obolibrary.org/obo/GOREL_provides_input_for'
	],
	color: '#483D8B' // darkslateblue
    },
    'RO:0002413':
    {
	readable: 'directly provides input for',
	priority: 1,
	aliases: [
	    'directly_provides_input_for',
	    'GOREL_directly_provides_input_for',
	    'http://purl.obolibrary.org/obo/GOREL_directly_provides_input_for'
	],
	glyph: 'diamond',
	color: '#483D8B' // darkslateblue
    },
    // New ones for monarch.
    'subclass_of':
    {
	readable: 'subclass of',
	priority: 100,
	aliases: [
	    'SUBCLASS_OF'
	],
	glyph: 'diamond',
	color: '#E9967A' // darksalmon
    },
    'superclass_of':
    {
	readable: 'superclass of',
	priority: 100,
	aliases: [
	    'SUPERCLASS_OF'
	],
	glyph: 'diamond',
	color: '#556B2F' // darkolivegreen
    },
    'annotation':
    {
	readable: 'annotation',
	priority: 100,
	aliases: [
	    'ANNOTATION'
	],
	glyph: 'diamond',
	color: '#483D8B' // darkslateblue
    }
};
/*
 * Package: statistics.js
 * 
 * Namespace: amigo.data.statistics
 * 
 * This package was automatically created during an AmiGO 2 installation.
 * 
 * Purpose: Useful numbers about the current data in the store.
 * 
 * Requirements: amigo2.js for bbop.amigo namespace.
 * 
 * NOTE: This file is generated dynamically at installation time.
 *       Hard to work with unit tests--hope it's not too bad.
 *       Want to keep this real simple.
 */

// Module and namespace checking.
if ( typeof amigo == "undefined" ){ var amigo = {}; }
if ( typeof amigo.data == "undefined" ){ amigo.data = {}; }
if ( typeof amigo.data.statistics == "undefined" ){ amigo.data.statistics = {}; }

/*
 * Variable: annotation_evidence
 * 
 * TBD
 */
amigo.data.statistics.annotation_source = [["MGI", 143898], ["UniProtKB", 131680], ["ZFIN", 88093], ["WB", 68439], ["TAIR", 68319], ["SGD", 44070], ["PomBase", 38714], ["RGD", 23674], ["dictyBase", 20561], ["InterPro", 12251], ["TIGR", 11229], ["RefGenome", 7252], ["GOC", 6282], ["BHF-UCL", 4758], ["IntAct", 2036], ["HGNC", 532], ["UniPathway", 499], ["DFLAT", 311], ["PINC", 18], ["Roslin_Institute", 10], ["ENSEMBL", 5], ["Reactome", 3]];

/*
 * Variable: annotation_source
 * 
 * TBD
 */
amigo.data.statistics.annotation_evidence = [["experimental evidence", 192016], ["similarity evidence", 132787], ["curator inference", 68788], ["combinatorial evidence", 15414], ["author statement", 11503]];

/*
 * Variable: annotation_overview
 * 
 * TBD
 */
amigo.data.statistics.annotation_overview = [["Source", "similarity evidence", "experimental evidence", "curator inference", "author statement", "combinatorial evidence", "genomic context evidence", "biological system reconstruction", "imported information"], ["dictyBase", 9289, 4311, 6478, 483, 0, 0, 0, 0], ["EcoCyc", 0, 0, 0, 0, 0, 0, 0, 0], ["FlyBase", 0, 0, 0, 0, 0, 0, 0, 0], ["MGI", 53520, 55284, 32957, 2002, 135, 0, 0, 0], ["PomBase", 10204, 16257, 3661, 2286, 511, 0, 0, 0], ["RGD", 23674, 0, 0, 0, 0, 0, 0, 0], ["SGD", 3396, 33774, 4578, 2321, 1, 0, 0, 0], ["TAIR", 11078, 16661, 6626, 1663, 14752, 0, 0, 0], ["WB", 861, 33166, 60, 144, 1, 0, 0, 0], ["ZFIN", 507, 10672, 10946, 127, 0, 0, 0, 0]];
/*
 * Package: rollup.js
 * 
 * Namespace: amigo.ui.rollup
 * 
 * BBOP method to roll an information are up to save real estate.
 * This requires jQuery and an HTML format like:
 * 
 * : <div id="ID_TEXT" class="SOME_CLASS_FOR_YOUR_STYLING">
 * :  <span class="ANOTHERONE">ANCHOR_TEXT<a href="#"><img src="?" /></span></a>
 * :  <div>
 * :   ABC
 * :  </div>
 * : </div>
 * 
 * Usage would then simply be:
 * 
 * : amigo.ui.rollup(['ID_TEXT']);
 * 
 * As a note, for AmiGO 2, his is handled by the common templates
 * info_rollup_start.tmpl and info_rollup_end.tmpl in the amigo git
 * repo. Usage would be like:
 * 
 * : [% rollup_id = "ID_TEXT" %]
 * : [% rollup_anchor = "ANCHOR_TEXT" %]
 * : [% INCLUDE "common/info_rollup_start.tmpl" %]
 * : ABC
 * : [% INCLUDE "common/info_rollup_end.tmpl" %]
 * 
 * Again, this is a method, not an object constructor.
 */

// Module and namespace checking.
if ( typeof amigo == "undefined" ){ var amigo = {}; }
if ( typeof amigo.ui == "undefined" ){ amigo.ui = {}; }

/*
 * Method: rollup
 * 
 * See top-level for details.
 * 
 * Arguments:
 *  elt_ids - a list if element ids of the areas to roll up
 * 
 * Returns:
 *  n/a
 */
amigo.ui.rollup = function(elt_ids){

    var each = bbop.core.each;
    each(elt_ids,
    	 function(eltid){
	     var eheader = '#' + eltid + ' > div';
	     var earea = '#' + eltid + ' > span > a';
	     jQuery(eheader).hide();
    	     var click_elt =
		 jQuery(earea).click(function(){
					 jQuery(eheader).toggle("blind",{},250);
					 return false;
				     });
	 });
};

// If it looks like we're in an environment that supports CommonJS
// Modules 1.0, take the amigo namespace whole and export it. Otherwise
// (browser environment, etc.), take no action and depend on the
// global namespace.
if( typeof(exports) != 'undefined' ){

    // Old style--exporting separate namespace.
    exports.amigo = amigo;

    // New, better, style--assemble; these should not collide.
    bbop.core.each(amigo, function(k, v){
	exports[k] = v;
    });
}

},{"bbop":"bbop"}],"bbop":[function(require,module,exports){
/* 
 * Package: core.js
 * 
 * Namespace: bbop.core
 * 
 * BBOP language extensions to JavaScript.
 * 
 * Purpose: Helpful basic utilities and operations to fix common needs in JS.
 */

// Module and namespace checking.
if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.core == "undefined" ){ bbop.core = {}; }
//if ( typeof amigo == "undefined" ){ var amigo = {}; }

/*
 * Function: crop
 *
 * Crop a string nicely.
 * 
 * Parameters:
 *  str - the string to crop
 *  lim - the final length to crop to (optional, defaults to 10)
 *  suff - the string to add to the end (optional, defaults to '')
 * 
 * Returns: Nothing. Side-effects: throws an error if the namespace
 * defined by the strings is not currently found.
 */
bbop.core.crop = function(str, lim, suff){
    var ret = str;

    var limit = 10;
    if( lim ){ limit = lim; }

    var suffix = '';
    if( suff ){ suffix = suff; }
    
    if( str.length > limit ){
	ret = str.substring(0, (limit - suffix.length)) + suffix;
    }
    return ret;
};

/*
 * Function: fold
 *
 * Fold a pair of hashes together, using the first one as an initial
 * template--only the keys in the default hash will be defined in the
 * final hash--and the second hash getting precedence.
 * 
 * The can be quite useful when defining functions--essentially
 * allowing a limited default value system for arguments.
 * 
 * Parameters:
 *  default_hash - Template hash.
 *  arg_hash - Argument hash to match.
 * 
 * Returns: A new hash.
 * 
 * Also see: <merge>
 */
bbop.core.fold = function(default_hash, arg_hash){

    if( ! default_hash ){ default_hash = {}; }
    if( ! arg_hash ){ arg_hash = {}; }

    var ret_hash = {};
    for( var key in default_hash ){
	if( bbop.core.is_defined(arg_hash[key]) ){
	    ret_hash[key] = arg_hash[key];
	}else{
	    ret_hash[key] = default_hash[key];
	}
    }
    return ret_hash;
};

/*
 * Function: merge
 *
 * Merge a pair of hashes together, the second hash getting
 * precedence. This is a superset of the keys both hashes.
 * 
 * Parameters:
 *  older_hash - first pass
 *  newer_hash - second pass
 * 
 * Returns: A new hash.
 * 
 * Also see: <fold>
 */
bbop.core.merge = function(older_hash, newer_hash){

    if( ! older_hash ){ older_hash = {}; }
    if( ! newer_hash ){ newer_hash = {}; }

    var ret_hash = {};
    function _add (key, val){
	ret_hash[key] = val;
    }
    bbop.core.each(older_hash, _add);
    bbop.core.each(newer_hash, _add);
    return ret_hash;
};

/*
 * Function: get_keys
 *
 * Get the hash keys from a hash/object, return as an array.
 *
 * Parameters:
 *  arg_hash - the hash in question
 *
 * Returns: an array of keys
 */
bbop.core.get_keys = function (arg_hash){

    if( ! arg_hash ){ arg_hash = {}; }
    var out_keys = [];
    for (var out_key in arg_hash) {
	if (arg_hash.hasOwnProperty(out_key)) {
	    out_keys.push(out_key);
	}
    }
    
    return out_keys;
};

/*
 * Function: hashify
 *
 * Returns a hash form of the argument array/list. For example ['a',
 * 'b'] would become {'a': true, 'b': true} or [['a', '12'], ['b',
 * '21']] would become {'a': '12', 'b': '21'}. Using mixed sub-lists
 * is undefined.
 *
 * Parameters:
 *  list - the list to convert
 *
 * Returns: a hash
 */
bbop.core.hashify = function (list){
    var rethash = {};

    if( list && list[0] ){
	if( bbop.core.is_array(list[0]) ){
	    bbop.core.each(list,
			   function(item){
			       var key = item[0];
			       var val = item[1];
			       if( bbop.core.is_defined(key) ){
				   rethash[key] = val;
			       }
			   });
	}else{
	    bbop.core.each(list,
			   function(item){
			       rethash[item] = true;
			   });
	}
    }

    return rethash;
};

/*
 * Function: is_same
 *
 * Returns true if it things the two incoming arguments are value-wise
 * the same.
 * 
 * Currently only usable for simple (atomic single layer) hashes,
 * atomic lists, boolean, null, number, and string values. Will return
 * false otherwise.
 * 
 * Parameters:
 *  thing1 - thing one
 *  thing2 - thing two
 *
 * Returns: boolean
 */
bbop.core.is_same = function (thing1, thing2){

    var retval = false;

    // If is hash...steal the code from test.js.
    if( bbop.core.is_hash(thing1) && bbop.core.is_hash(thing2) ){
	
	var same_p = true;
	
	// See if the all of the keys in hash1 are defined in hash2
	// and that they have the same ==.
	for( var k1 in thing1 ){
	    if( typeof thing2[k1] === 'undefined' ||
		thing1[k1] !== thing2[k1] ){
		    same_p = false;
		    break;
		}
	}

	// If there is still no problem...
	if( same_p ){
	    
	    // Reverse of above.
	    for( var k2 in thing2 ){
		if( typeof thing1[k2] === 'undefined' ||
		    thing2[k2] !== thing1[k2] ){
			same_p = false;
			break;
		    }
	    }
	}

	retval = same_p;

    }else if( bbop.core.is_array(thing1) && bbop.core.is_array(thing2) ){
	// If it's an array convert and pass it off to the hash function.
	retval = bbop.core.is_same(bbop.core.hashify(thing1),
				   bbop.core.hashify(thing2));
    }else{
	
	// So, we're hopefully dealing with an atomic type. If they
	// are the same, let's go ahead and try.
	var t1_is = bbop.core.what_is(thing1);
	var t2_is = bbop.core.what_is(thing2);
	if( t1_is == t2_is ){
	    if( t1_is == 'null' ||
		t1_is == 'boolean' ||
		t1_is == 'null' ||
		t1_is == 'number' ||
		t1_is == 'string' ){
		    if( thing1 == thing2 ){
			retval = true;
		    }
		}
	}
    }

    return retval;
};

/*
 * Function: what_is
 *
 * Return the string best guess for what the input is, null if it
 * can't be identified. In addition to the _is_a property convention,
 * current core output strings are: 'null', 'array', 'boolean',
 * 'number', 'string', 'function', and 'object'.
 * 
 * Parameters: 
 *  in_thing - the thing in question
 *
 * Returns: a string
 */
bbop.core.what_is = function(in_thing){
    var retval = null;
    if( typeof(in_thing) != 'undefined' ){

	// If it's an object, try and guess the 'type', otherwise, let
	// typeof.
	if( in_thing == null ){
	    retval = 'null';
	}else if( typeof(in_thing) == 'object' ){
	    
	    // Look for the 'is_a' property that I should be using.
	    if( typeof(in_thing._is_a) != 'undefined' ){
		retval = in_thing._is_a;
	    }else{
		if( bbop.core.is_array(in_thing) ){
		    retval = 'array';
		}else{
		    retval = 'object';
		}		
	    }
	}else{
	    retval = typeof(in_thing);
	}
    }
    return retval;
};

/*
 * Function: is_array
 *
 * Return the best guess (true/false) for whether or not a given
 * object is being used as an array.
 *
 * Parameters: 
 *  in_thing - the thing in question
 *
 * Returns: boolean
 */
bbop.core.is_array = function(in_thing){
    var retval = false;
    if( in_thing &&
	Array.isArray(in_thing) ){
	retval = true;
    }
    return retval;
};

/*
 * Function: is_hash
 *
 * Return the best guess (true/false) for whether or not a given
 * object is being used as a hash.
 *
 * Parameters: 
 *  in_thing - the thing in question
 *
 * Returns: boolean
 */
bbop.core.is_hash = function(in_thing){
    var retval = false;
    if( in_thing &&
	typeof(in_thing) == 'object' &&
	(! bbop.core.is_array(in_thing)) ){
	retval = true;
    }
    return retval;
};

/*
 * Function: is_empty
 *
 * Return true/false on whether or not the object in question has any
 * items of interest (iterable?).
 *
 * Parameters: 
 *  in_thing - the thing in question
 *
 * Returns: boolean
 */
bbop.core.is_empty = function(in_thing){
    var retval = false;
    if( bbop.core.is_array(in_thing) ){
	if( in_thing.length == 0 ){
	    retval = true;
	}
    }else if( bbop.core.is_hash(in_thing) ){
	var in_hash_keys = bbop.core.get_keys(in_thing);
	if( in_hash_keys.length == 0 ){
	    retval = true;
	}
    }else{
	// TODO: don't know about this case yet...
	//throw new Error('unsupported type in is_empty');	
	retval = false;
    }
    return retval;
};

/*
 * Function: is_defined
 *
 * Return true/false on whether or not the passed object is defined.
 *
 * Parameters: 
 *  in_thing - the thing in question
 *
 * Returns: boolean
 */
bbop.core.is_defined = function(in_thing){
    var retval = true;
    if( typeof(in_thing) === 'undefined' ){
	retval = false;
    }
    return retval;
};

/*
 * Function: each
 *
 * Implement a simple iterator so I don't go mad.
 *  array - function(item, index)
 *  object - function(key, value)
 *
 *  TODO/BUG/WARNING?: This does not seem to work with the local
 *  function variable "arguments".
 * 
 * Parameters: 
 *  in_thing - hash or array
 *  in_function - function to apply to elements
 *
 * Returns:
 *  n/a
 */
bbop.core.each = function(in_thing, in_function){

    // Probably an not array then.
    if( typeof(in_thing) == 'undefined' ){
	// this is a nothing, to nothing....
    }else if( typeof(in_thing) != 'object' ){
	throw new Error('Unsupported type in bbop.core.each: ' +
			typeof(in_thing) );
    }else if( bbop.core.is_hash(in_thing) ){
	// Probably a hash...
	var hkeys = bbop.core.get_keys(in_thing);
	for( var ihk = 0; ihk < hkeys.length; ihk++ ){
	    var ikey = hkeys[ihk];
	    var ival = in_thing[ikey];
	    in_function(ikey, ival);
	}
    }else{
	// Otherwise likely an array.
	for( var iai = 0; iai < in_thing.length; iai++ ){
	    in_function(in_thing[iai], iai);
	}
    }
};

/*
 * Function: pare
 *
 * Take an array or hash and pare it down using a couple of functions
 * to what we want.
 * 
 * Both parameters are optional in the sense that you can set them to
 * null and they will have no function; i.e. a null filter will let
 * everything through and a null sort will let things go in whatever
 * order.
 *
 * Parameters: 
 *  in_thing - hash or array
 *  filter_function - hash (function(key, val)) or array (function(item, i)).
 *   This function must return boolean true or false.
 *  sort_function - function to apply to elements: function(a, b)
 *   This function must return an integer as the usual sort functions do.
 *
 * Returns: An array.
 */
bbop.core.pare = function(in_thing, filter_function, sort_function){

    var ret = [];
    
    // Probably an not array then.
    if( typeof(in_thing) === 'undefined' ){
	// this is a nothing, to nothing....
    }else if( typeof(in_thing) != 'object' ){
	throw new Error('Unsupported type in bbop.core.pare: ' +
			typeof(in_thing) );
    }else if( bbop.core.is_hash(in_thing) ){
	// Probably a hash; filter it if filter_function is defined.
	if( filter_function ){	
	    bbop.core.each(in_thing,
			   function(key, val){
			       if( filter_function(key, val) ){
				   // Remove matches to the filter.
			       }else{
				   ret.push(val);
			       }
			   });
	}else{
	    bbop.core.each(in_thing, function(key, val){ ret.push(val); });
	}
    }else{
	// Otherwise, probably an array; filter it if filter_function
	// is defined.
	if( filter_function ){	
	    bbop.core.each(in_thing,
			   function(item, index){
			       if( filter_function(item, index) ){
				   // filter out item if true
			       }else{
				   ret.push(item);
			       }
			   });
	}else{
	    bbop.core.each(in_thing, function(item, index){ ret.push(item); });
	}
    }

    // For both: sort if there is anything.
    if( ret.length > 0 && sort_function ){
	ret.sort(sort_function);	    
    }

    return ret;
};

/*
 * Function: clone
 *
 * Clone an object down to its atoms.
 *
 * Parameters: 
 *  thing - whatever
 *
 * Returns: a new whatever
 */
bbop.core.clone = function(thing){

    var clone = null;

    if( typeof(thing) === 'undefined' ){
	// Nothin' doin'.
	//print("looks undefined");
    }else if( typeof(thing) === 'function' ){
	// Dunno about this case...
	//print("looks like a function");
	clone = thing;
    }else if( typeof(thing) === 'boolean' ||
	      typeof(thing) === 'number' ||
	      typeof(thing) === 'string' ){
	// Atomic types can be returned as-is (i.e. assignment in
	// JS is the same as copy for atomic types).
	//print("cloning atom: " + thing);
	clone = thing;
    }else if( typeof(thing) === 'object' ){
	// Is it a null, hash, or an array?
	if( thing == null ){
	    clone = null;
	}else if( Array.isArray(thing) ){
	    // Looks like an array!
	    //print("looks like an array");
	    clone = [];
	    for(var i = 0; i < thing.length; i++){
		clone[i] = bbop.core.clone(thing[i]);
	    }
	}else{
	    // Looks like a hash!
	    //print("looks like a hash");
	    clone = {};
	    for(var h in thing){
		clone[h] = bbop.core.clone(thing[h]);
	    }
	}
    }else{
	// Then I don't know what it is--might be platform dep.
	//print("no idea what it is");
    }
    return clone;
};

/*
 * Function: to_string
 *
 * Essentially add standard 'to string' interface to the string class
 * and as a stringifier interface to other classes. More meant for
 * output--think REPL. Only atoms, arrays, and objects with a
 * to_string function are handled.
 *
 * Parameters: 
 *  in_thing - something
 *
 * Returns: string
 * 
 * Also See: <dump>
 */
bbop.core.to_string = function(in_thing){

    // First try interface, then the rest.
    if( in_thing &&
	typeof(in_thing.to_string) !== 'undefined' &&
	typeof(in_thing.to_string) == 'function' ){
	return in_thing.to_string();
    }else{
		
	var what = bbop.core.what_is(in_thing);
	if( what == 'number' ){
	    return in_thing.toString();
	}else if( what == 'string' ){
	    return in_thing;
	}else if( what == 'array' ){
	    return bbop.core.dump(in_thing);
	// }else if( what == 'object' ){
	//     return bbop.core.dump(in_thing);
	// }else{
	//     return '[unsupported]';
	}else{
	    return in_thing;
	}
    }
};

/*
 * Function: dump
 *
 * Dump an object to a string form as best as possible. More meant for
 * debugging. This is meant to be an Object walker. For a slightly
 * different take (Object identification), see <to_string>.
 *
 * Parameters: 
 *  in_thing - something
 *
 * Returns: string
 * 
 * Also See: <to_string>
 */
bbop.core.dump = function(thing){

    var retval = '';

    var what = bbop.core.what_is(thing);
    if( what == null ){
	retval = 'null';
    }else if( what == 'null' ){
	retval = 'null';
    }else if( what == 'string' ){
	retval = '"' + thing + '"';
    }else if( what == 'boolean' ){
	if( thing ){
	    retval = "true";
	}else{
	    retval = "false";
	}
    }else if( what == 'array' ){

	var astack = [];
	bbop.core.each(thing, function(item, i){
			   astack.push(bbop.core.dump(item));
		       });
	retval = '[' + astack.join(', ') + ']';

    }else if( what == 'object' ){

	var hstack = [];
	bbop.core.each(thing, function(key, val){
			   hstack.push('"'+ key + '": ' +
				       bbop.core.dump(val));
		       });
	retval = '{' + hstack.join(', ') + '}';

    }else{
	retval = thing;
    }

    return retval;
};

/*
 * Function: has_interface
 *
 * Check to see if all top-level objects in a namespace supply an
 * "interface".
 * 
 * Mostly intended for use during unit testing.
 *
 * Parameters: 
 *  iobj - the object/constructor in question
 *  interface_list - the list of interfaces (as a strings) we're looking for
 *
 * Returns: boolean
 *
 * TODO: Unit test this to make sure it catches both prototype (okay I
 * think) and uninstantiated objects (harder/impossible?).
 */
bbop.core.has_interface = function(iobj, interface_list){
    var retval = true;
    bbop.core.each(interface_list,
		   function(iface){
		       //print('|' + typeof(in_key) + ' || ' + typeof(in_val));
		       //print('|' + in_key + ' || ' + in_val);
		       if( typeof(iobj[iface]) == 'undefined' &&
			   typeof(iobj.prototype[iface]) == 'undefined' ){
			   retval = false;
			   throw new Error(bbop.core.what_is(iobj) +
					   ' breaks interface ' + 
					   iface);
                       }
		   });
    return retval;
};

/*
 * Function: get_assemble
 *
 * Assemble an object into a GET-like query. You probably want to see
 * the tests to get an idea of what this is doing.
 * 
 * The last argument of double hashes gets quoted (Solr-esque),
 * otherwise not. It will try and avoid adding additional sets of
 * quotes to strings.
 *
 * This does nothing to make the produced "URL" in any way safe.
 * 
 * WARNING: Not a hugely clean function--there are a lot of special
 * cases and it could use a good (and safe) clean-up.
 * 
 * Parameters: 
 *  qargs - hash/object
 *
 * Returns: string
 */
bbop.core.get_assemble = function(qargs){

    var mbuff = [];
    for( var qname in qargs ){
	var qval = qargs[qname];

	// null is technically an object, but we don't want to render
	// it.
	if( qval != null ){
	    if( typeof qval == 'string' || typeof qval == 'number' ){
		// Is standard name/value pair.
		var nano_buffer = [];
		nano_buffer.push(qname);
		nano_buffer.push('=');
		nano_buffer.push(qval);
		mbuff.push(nano_buffer.join(''));
	    }else if( typeof qval == 'object' ){
		if( typeof qval.length != 'undefined' ){
		    // Is array (probably).
		    // Iterate through and double on.
		    for(var qval_i = 0; qval_i < qval.length ; qval_i++){
			var nano_buff = [];
			nano_buff.push(qname);
			nano_buff.push('=');
			nano_buff.push(qval[qval_i]);
			mbuff.push(nano_buff.join(''));
		    }
		}else{
		    // // TODO: The "and" case is pretty much like
		    // // the array, the "or" case needs to be
		    // // handled carefully. In both cases, care will
		    // // be needed to show which filters are marked.
		    // Is object (probably).
		    // Special "Solr-esque" handling.
		    for( var sub_name in qval ){
			var sub_vals = qval[sub_name];
			
			// Since there might be an array down there,
			// ensure that there is an iterate over it.
			if( bbop.core.what_is(sub_vals) != 'array' ){
			    sub_vals = [sub_vals];
			}
			
			var loop = bbop.core.each;
			loop(sub_vals,
			     function(sub_val){
				 var nano_buff = [];
				 nano_buff.push(qname);
				 nano_buff.push('=');
				 nano_buff.push(sub_name);
				 nano_buff.push(':');
				 if( typeof sub_val !== 'undefined' && sub_val ){
				     // Do not double quote strings.
				     // Also, do not requote if we already
				     // have parens in place--that
				     // indicates a complicated
				     // expression. See the unit tests.
				     var val_is_a = bbop.core.what_is(sub_val);
				     if( val_is_a == 'string' &&
					 sub_val.charAt(0) == '"' &&
					 sub_val.charAt(sub_val.length -1) == '"' ){
					     nano_buff.push(sub_val);
					 }else if( val_is_a == 'string' &&
						   sub_val.charAt(0) == '(' &&
						   sub_val.charAt(sub_val.length -1) == ')' ){
						       nano_buff.push(sub_val);
						   }else{
						       nano_buff.push('"' + sub_val + '"');
						   }
				 }else{
				     nano_buff.push('""');
				 }
				 mbuff.push(nano_buff.join(''));
			     });
		    }
		}
	    }else if( typeof qval == 'undefined' ){
		// This happens in some cases where a key is tried, but no
		// value is found--likely equivalent to q="", but we'll
		// let it drop.
		// var nano_buff = [];
		// nano_buff.push(qname);
		// nano_buff.push('=');
		// mbuff.push(nano_buff.join(''));	    
	    }else{
		throw new Error("bbop.core.get_assemble: unknown type: " + 
				typeof(qval));
	    }
	}
    }
    
    return mbuff.join('&');
};

/*
 * Function: 
 *
 * Random number generator of fixed length. Return a random number
 * string of length len.
 *
 * Parameters: 
 *  len - the number of random character to return.
 *
 * Returns: string
 */
bbop.core.randomness = function(len){

    var random_base =
	['1', '2', '3', '4', '5', '6', '7', '8', '9', '0',
	 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
	 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];
    var length = len || 10;
    var cache = new Array();
    for( var ii = 0; ii < length; ii++ ){
	var rbase_index = Math.floor(Math.random() * random_base.length);
	cache.push(random_base[rbase_index]);
    }
    return cache.join('');
};

/*
 * Function: first_split
 *
 * Attempt to return a two part split on the first occurrence of a
 * character.
 *
 * Returns '' for parts not found.
 * 
 * Unit tests make the edge cases clear.
 * 
 * Parameters:
 *  character - the character to split on
 *  string - the string to split
 *
 * Returns:
 *  list of first and second parts
 */
bbop.core.first_split = function(character, string){

    var retlist = null;

    var eq_loc = string.indexOf(character);
    if( eq_loc == 0 ){
	retlist = ['', string.substr(eq_loc +1, string.length)];
    }else if( eq_loc > 0 ){
	var before = string.substr(0, eq_loc);
	var after = string.substr(eq_loc +1, string.length);
	retlist = [before, after];
    }else{
	retlist = ['', ''];
    }

    return retlist;
};

/*
 * Function: url_parameters
 *
 * Return the parameters part of a URL.
 *
 * Unit tests make the edge cases clear.
 * 
 * Parameters:
 *  url - url (or similar string)
 *
 * Returns:
 *  list of part lists
 */
bbop.core.url_parameters = function(url){

    var retlist = [];

    // Pull parameters.
    var tmp = url.split('?');
    var path = '';
    var parms = [];
    if( ! tmp[1] ){ // catch bad url--nothing before '?'
	parms = tmp[0].split('&');
    }else{ // normal structure
	path = tmp[0];
	parms = tmp[1].split('&');
    }

    // Decompose parameters.
    bbop.core.each(parms,
		  function(p){
		      var c = bbop.core.first_split('=', p);
		      if( ! c[0] && ! c[1] ){
			  retlist.push([p]);
		      }else{
			  retlist.push(c);		  
		      }
		  });
    
    return retlist;
};

/*
 * Function: resourcify
 *
 * Convert a string into something consistent for urls (getting icons,
 * etc.). Return a munged/hashed-down version of the resource.
 * Assembles, converts spaces to underscores, and all lowercases.
 * 
 * Parameters:
 *  base - base url for the resource(s)
 *  resource - the filename or whatever to be transformed
 *  extension - *[optional]* the extension of the resource
 *
 * Returns:
 *  string
 */
bbop.core.resourcify = function(base, resource, extension){

    var retval = base + '/' + resource;

    // Add the extension if it is there.
    if( extension ){
	retval += '.' + extension;	
    }

    // Spaces to underscores and all lowercase.
    return retval.replace(" ", "_", "g").toLowerCase();
};

/*
 * Function: uuid
 *
 * RFC 4122 v4 compliant UUID generator.
 * From: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523
 *
 * Parameters:
 *  n/a
 *
 * Returns:
 *  string
 */
bbop.core.uuid = function(){

    // Replace x (and y) in string.
    function replacer(c) {
	var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
	return v.toString(16);
    }
    var target_str = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
    return target_str.replace(/[xy]/g, replacer);
};

/*
 * Function: numeric_sort_ascending
 *
 * A sort function to put numbers in ascending order.
 * 
 * Useful as the argument to .sort().
 * 
 * See: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/sort
 * 
 * Parameters:
 *  a - the first number
 *  b - the second number
 *
 * Returns:
 *  number of their relative worth
 */
bbop.core.numeric_sort_ascending = function(a, b){
    return a - b;
};

/*
 * Function: numeric_sort_descending
 *
 * A sort function to put numbers in descending order.
 * 
 * Useful as the argument to .sort().
 * 
 * See: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/sort
 * 
 * Parameters:
 *  a - the first number
 *  b - the second number
 *
 * Returns:
 *  number of their relative worth
 */
bbop.core.numeric_sort_descending = function(a, b){
    return b - a;
};

/*
 * Function: dequote
 *
 * Remove the quotes from a string.
 * 
 * Parameters:
 *  str - the string to dequote
 *
 * Returns:
 *  the dequoted string (or the original string)
 */
bbop.core.dequote = function(str){
    var retstr = str;

    if( bbop.core.is_defined(str) && str.length > 2 ){
	var end = str.length -1;
	if( str.charAt(0) == '"' && str.charAt(end) == '"' ){
	    retstr = str.substr(1, end -1);
	}
    }

    return retstr;
};

/*
 * Function: ensure
 *
 * Make sure that a substring exists at the beginning or end (or both)
 * of a string.
 * 
 * Parameters:
 *  str - the string to ensure that has the property
 *  add - the string to check for (and possibly add)
 *  place - *[optional]* "front"|"back", place to ensure (defaults to both)
 *
 * Returns:
 *  a new string with the property enforced
 */
bbop.core.ensure = function(str, add, place){

    // 
    var do_front = false;
    var do_back = false;
    if( ! bbop.core.is_defined(place) ){
	do_front = true;
	do_back = true;
    }else if( place == 'front' ){
	do_front = true;
    }else if( place == 'back' ){
	do_back = true;
    }else{
	// Don't know what it is, not doing anything.
    }

    //
    var strlen = str.length;
    var addlen = add.length;
    var front_substr = str.substr(0, addlen);
    var back_substr = str.substr((strlen - addlen), (strlen -1));

    //
    var front_add = '';
    if( do_front && front_substr != add ){
	front_add = add;
    }
    var back_add = '';
    if( do_back && back_substr != add ){
	back_add = add;
    }

    // print('do_front: ' + do_front);
    // print('do_back: ' + do_back);
    // print('str.length: ' + strlen);
    // print('add.length: ' + addlen);
    // print('front_substr: ' + front_substr);
    // print('back_substr: ' + back_substr);
    // print('front_add: ' + front_add);
    // print('back_add: ' + back_add);

    return front_add + str + back_add;
};

/*
 * Function: chomp
 *
 * Trim the leading and trailing whitespace from a string.
 * Named differently so as not to confuse with JS 1.8.1's trim().
 * 
 * Parameters:
 *  str - the string to ensure that has the property
 *
 * Returns:
 *  the trimmed string
 */
bbop.core.chomp = function(str){

    var retstr = '';

    retstr = str.replace(/^\s+/,'');
    retstr = retstr.replace(/\s+$/,'');

    return retstr;
};

/*
 * Function: splode
 *
 * Break apart a string on certain delimiter.
 * 
 * Parameters:
 *  str - the string to ensure that has the property
 *  delimiter - *[optional]* either a string or a simple regexp; defaults to ws
 *
 * Returns:
 *  a list of separated substrings
 */
bbop.core.splode = function(str, delimiter){

    var retlist = null;

    if( bbop.core.is_defined(str) ){
	if( ! bbop.core.is_defined(delimiter) ){
	    delimiter = /\s+/;
	}
	
	retlist = str.split(delimiter);
    }

    return retlist;
};

// // Giving up on this for now: the general case seems too hard to work with 
// // in so many different, contradictory, and changing environments.
// /*
//  * Function: evaluate
//  * 
//  * Getting a cross-platform that can evaluate to the global namespace
//  * seems a little bit problematic. This is an attempt to wrap that all
//  * away.
//  * 
//  * This is not an easy problem--just within browsers there are a lot
//  * of issues:
//  * http://perfectionkills.com/global-eval-what-are-the-options/ After
//  * that, the server side stuff tries various ways to keep you from
//  * affecting the global namespace in certain circumstances.
//  * 
//  * Parameters:
//  *  to_eval - the string to evaluate
//  * 
//  * Returns:
//  *  A list with the following fields: retval, retval_str, okay_p, env_type.
//  */
// bbop.core.evaluate = function(to_eval){

//     var retval = null;
//     var retval_str = '';
//     var okay_p = true;
//     var env_type = 'server';

//     // Try and detect our environment.
//     try{
// 	if( bbop.core.is_defined(window) &&
// 	    bbop.core.is_defined(window.eval) &&
// 	    bbop.core.what_is(window.eval) == 'function' ){
// 		env_type = 'browser';
// 	    }
//     } catch (x) {
// 	// Probably not a browser then, right? Hopefully all the
// 	// servers that we'll run into are the same (TODO: check
// 	// nodejs).
//     }
//     print('et: ' + env_type);

//     // Now try for the execution.
//     try{
// 	// Try and generically evaluate.
// 	if( env_type == 'browser' ){
// 	    print('eval as if (browser)');
// 	    retval = window.eval(to_eval);
// 	}else{
// 	    // TODO: Does this work?
// 	    print('eval as else (server)');
// 	    //retval = this.eval(to_eval);		
// 	    retval = bbop.core.global.eval(to_eval);
// 	}
//     }catch (x){
// 	// Bad things happened.
// 	print('fail on: (' + retval +'): ' + to_eval);
// 	retval_str = '[n/a]';
// 	okay_p = false;
//     }
	
//     // Make whatever the tmp_ret is prettier for the return string.
//     if( bbop.core.is_defined(retval) ){
// 	if( bbop.core.what_is(retval) == 'string' ){
// 	    retval_str = '"' + retval + '"';
// 	}else{
// 	    retval_str = retval;
// 	}
//     }else{
// 	// Return as-is.
//     }

//     return [retval, retval_str, okay_p, env_type];
// };

/*
 * Function: extend
 * 
 * What seems to be a typical idiom for subclassing in JavaScript.
 * 
 * This attempt has been scraped together from bits here and there and
 * lucid explanations from Mozilla:
 * 
 * https://developer.mozilla.org/en-US/docs/JavaScript/Introduction_to_Object-Oriented_JavaScript
 * https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Details_of_the_Object_Model
 * https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Inheritance_Revisited
 * https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/new
 * 
 * Parameters:
 *  subclass - the subclass object
 *  superclass - the superclass object
 * 
 * Returns:
 *  n/a
 */
bbop.core.extend = function(subclass, baseclass){

    // Create a temporary nothing so that we don't fiddle the
    // baseclass's(?) with what we do to subclass later on.
    function tmp_object(){}

    // This nothings prototype gets the base class's.
    tmp_object.prototype = baseclass.prototype;

    // We instantiate the tmp_object, whose prototype is the
    // baseclass's; we make subclass's prototype this object, giving
    // us something that is very much like baseclass.
    subclass.prototype = new tmp_object; // same as: "new tmp_object();"

    // Now we go back and make the constructor of subclass actually
    // subclass again--we blew it away in the last step. Now we have a
    // subclass constructor with the protoype of baseclass.
    subclass.prototype.constructor = subclass;

    // // Create a property to allow access to the constructor of
    // // baseclass. This is useful when subclass needs access to
    // // baseclass's constructor for property setting.
    // subclass.base_constructor = baseclass;

    // // Create a property to
    // subclass.parent_class = baseclass.prototype;
};
/* 
 * Package: test.js
 * 
 * Namespace: bbop.test
 * 
 * A trivial testing framework for JS. See test.tests.js for usage.
 * 
 *  Note: this cannot depend on core.js (it tests that), so some stuff
 *  may be duped. On the other hand, we can test ourselves--see
 *  test.js.tests.
 */

// Module and namespace checking.
if ( typeof bbop == "undefined" ){ var bbop = {}; }

/*
 * Constructor: test
 * 
 * Contructor for the BBOP JS unit test system.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  BBOP test suite object
 */
bbop.test = function(){

    ///
    /// Either rhino or node, right?
    ///

    // print or console.log
    var barker = function(thing){};
    if( typeof(console) !== 'undefined' && typeof(console.log) === 'function' ){
	barker = console.log;	
    }else if( typeof(print) === 'function' ){
	barker = print;
    }
    function bark(thing){
	barker(thing);
    }

    ///
    /// Accounting and reporting.
    ///

    var test_number = 1;
    var tests_passed = 0;
    var tests_failed = 0;
    function _incr_tests(){ test_number = test_number + 1; }
    function _incr_passed(){ tests_passed = tests_passed + 1; }
    function _incr_failed(){ tests_failed = tests_failed + 1; }
    function _incr_failed(){ tests_failed = tests_failed + 1; }
    function _complete(bool, msg){
	if( bool ){
	    if( msg ){
		bark('Test ' + test_number + ' passed: ' + msg + '.');
	    }else{
		bark('Test ' + test_number + ' passed.');
	    }
	    _incr_passed();
	}else{
	    if( msg ){
		bark('FAIL: Test ' + test_number + ' failed: ' + msg + '.');
	    }else{
		bark('FAIL: Test ' + test_number + ' failed.');
	    }
	    _incr_failed();
	}
	test_number++;	
    }

    /*
     * Function: report
     *
     * Print a report about what happened during the tests.
     *
     * Parameters: 
     *  n/a
     *
     * Returns: 
     *  n/a; but prints the report as a side-effect
     */
    this.report = function(){
	if( tests_passed + 1 == test_number ){
	    bark('* All tests passed.');
	}else{
	    bark('* Tests passed: ' + tests_passed);
	    bark('* Tests failed: ' + tests_failed);
	}
    };

    ///
    /// Internal helper functions--different kinds of comparisions.
    ///

    //
    function _same_array(one, two){
	var retval = true;
	if( one.length != two.length ){
	    retval = false;
	}else{
	    for( var i = 0; i < one.length; i++ ){
		if( one[i] != two[i] ){
		    retval = false;
		    break;
		}
	    }
	}
	return retval;
    }

    // Looking at array as sets of...something.
    // DEPRECATED
    function _same_set(set1, set2){
	var h1 = {};
	var h2 = {};
	for( var h1i = 0; h1i < set1.length; h1i++ ){ h1[set1[h1i]] = 1; }
	for( var h2i = 0; h2i < set2.length; h2i++ ){ h2[set2[h2i]] = 1; }
	return _same_hash(h1, h2);
    }

    // NOTE/WARNING: This is a very shallow comparison function.
    // DEPRECATED
    function _same_hash(hash1, hash2){

	var same_p = true;
	
	// See if the all of the keys in hash1 are defined in hash2
	// and that they have the same ==.
	for( var k1 in hash1 ){
	    if( typeof hash2[k1] === 'undefined' ||
		hash1[k1] !== hash2[k1] ){
		same_p = false;
		break;
	    }
	}

	// If there is still no problem...
	if( same_p ){

	    // Reverse of above.
	    for( var k2 in hash2 ){
		if( typeof hash1[k2] === 'undefined' ||
		    hash2[k2] !== hash1[k2] ){
		    same_p = false;
		    break;
		}
	    }
	}
	
	return same_p;
    }

    // Better general comparison function.
    function _is_same(a, b){
	//bark('typeof(a, b): ' + typeof(a) + ',' + typeof(b));

	var ret = false;
	if( a == b ){ // atoms, incl. null and 'string'
	    //bark('true on equal atoms: ' + a + '<>' + b);
	    ret = true;
	}else{ // is list or obj (ignore func)
	    if( typeof(a) === 'object' && typeof(b) === 'object' ){
		//bark('...are objects');
		
		// Null is an object, but not like the others.
		if( a == null || b == null ){
		    ret = false;
		}else if( Array.isArray(a) && Array.isArray(b) ){ // array equiv
		    //bark('...are arrays');
		    
		    // Recursively check array equiv.
		    if( a.length == b.length ){
			if( a.length == 0 ){
			    //bark('true on 0 length array');
			    ret = true;
			}else{
			    ret = true; // assume true until false here
			    for( var i = 0; i < a.length; i++ ){
				if( ! _is_same(a[i], b[i]) ){
				    //bark('false on diff @ index: ' + i);
				    ret = false;
				    break;
				}
			    }
			}
		    }

		}else{ // object equiv.

		    // Get unique set of keys.
		    var a_keys = Object.keys(a);
		    var b_keys = Object.keys(b);
		    var keys = a_keys.concat(b_keys.filter(function(it){
			return a_keys.indexOf(it) < 0;
		    }));
		    
		    // Assume true until false.
		    ret = true;
		    for( var j = 0; j < keys.length; j++ ){ // no forEach - break
			var k = keys[j];
			if( ! _is_same(a[k], b[k]) ){
			    //bark('false on key: ' + k);
			    ret = false;
			    break;
			}
		    }
		}
	    }else{
		//bark('false by default');
	    }
	}
	
	return ret;
    }

    // TODO: This could probably be done better.
    function _link_comp(str1, str2){

	// Decompose links and arguments.
	var tmp1 = str1.split('?');
	var head1 = '';
	var args1 = [];
	if( ! tmp1[1] ){ // nothing before '?'
	    args1 = tmp1[0].split('&');
	}else{ // normal structure
	    head1 = tmp1[0];
	    args1 = tmp1[1].split('&');
	}
	var sorted_args1 = args1.sort();

	var tmp2 = str2.split('?');
	var head2 = '';
	var args2 = [];
	if( ! tmp2[1] ){ // nothing before '?'
	    args2 = tmp2[0].split('&');
	}else{ // normal structure
	    head2 = tmp2[0];
	    args2 = tmp2[1].split('&');
	}
	var sorted_args2 = args2.sort();

	// var tmp2 = str2.split('?');
	// var head2 = tmp2[0];
	// var args2 = tmp2[1].split('&');
	// var sorted_args2 = args2.sort();

	// Compare heads and arguments.
	var retval = false;
	if( head1 == head2 &&
	    _same_array(sorted_args1, sorted_args2) ){
	    retval = true;
	}
	return retval;
    }

    // Walk through the list and see if it's there.
    // If compareator is not defined, just to atom comparison.
    function _in_list(in_item, list, comparator){

	var retval = false;
	for(var li = 0; li < list.length; li++ ){
	    var list_item = list[li];

	    if( comparator ){
		var comp_op = comparator(in_item, list_item);
		if( comp_op && comp_op == true ){
		    retval = true;
		}
	    }else{
		if( in_item == list_item ){
		    retval = true;
		}
	    }
	}

	return retval;
    }

    // Basically asking if you can make the target string from the
    // base string with the add_str added into it somewhere. Strange,
    // but another way of looking at URL creation in some cases.
    function _is_string_embedded(target_str, base_str, add_str){

	// Walk through all of ways of splitting base_str and add
	// add_str in there to see if we get the target_str.
	var retval = false;
	for(var si = 0; si <= base_str.length; si++ ){
	    
	    var car = base_str.substr(0, si);
	    var cdr = base_str.substr(si, base_str.length);
	    //bark(car + "|" + add_str + "|" + cdr);
	    if( car + add_str + cdr == target_str){
		retval = true;
		break;
	    }
	}
	return retval;
    }

    ///
    /// End-user comparisions and assertions.
    ///

    /*
     * Function: is_same_atom
     *
     * DEPRECATED
     *
     * Test whether two atoms are the same.
     *
     * Parameters: 
     *  question - the atom to test
     *  answer - the expected atom
     *  msg - *[optional]* informational message about test
     *
     * Returns: 
     *  n/a
     */
    function _is_simple_same(question, answer, msg){
	_complete(question == answer, msg);
    }
    this.is_same_atom = _is_simple_same;

    /*
     * Function: is_different_atom
     *
     * A negative version of <is_same_atom>.
     *
     * DEPRECATED
     *
     * Parameters: 
     *  question - the atom to test
     *  answer - the unexpected atom
     *  msg - *[optional]* informational message about test
     *
     * Returns: 
     *  n/a
     */
    this.is_different_atom = function(question, answer, msg){
	_complete(question != answer, msg);
    };

    /*
     * Function: is_defined
     *
     * Test whether a value is defined.
     *
     * Parameters: 
     *  thing - the value to test for being defined
     *  msg - *[optional]* informational message about test
     *
     * Returns: 
     *  n/a
     */
    this.is_defined = function(thing, msg){
	if( thing ){
	    _complete(true, msg);
	}else{
	    _complete(false, msg);
	}
    };

    /*
     * Function: is_not_defined
     *
     * A negative version of <is_defined>.
     *
     * Parameters: 
     *  thing - the value to test for being undefined
     *  msg - *[optional]* informational message about test
     *
     * Returns: 
     *  n/a
     */
    this.is_not_defined = function(thing, msg){
	if( thing ){
	    _complete(false, msg);
	}else{
	    _complete(true, msg);
	}
    };

    /*
     * Function: is_true
     *
     * Test whether a value is true.
     *
     * Parameters: 
     *  bool - the variable to test
     *  msg - *[optional]* informational message about test
     *
     * Returns: 
     *  n/a
     */
    this.is_true = function(bool, msg){
	if( bool == true ){
	    _complete(true, msg);
	}else{
	    _complete(false, msg);
	}
    };

    /*
     * Function: is_false
     *
     * A negative version of <is_true>.
     *
     * Parameters: 
     *  bool - the variable to test
     *  msg - *[optional]* informational message about test
     *
     * Returns: 
     *  n/a
     */
    this.is_false = function(bool, msg){
	if( bool == false ){
	    _complete(true, msg);
	}else{
	    _complete(false, msg);
	}
    };

    /*
     * Function: is_x_greater_than_y
     *
     * Test whether one value is greate than another. Uses the
     * standard ">" operator.
     *
     * Parameters: 
     *  x_thing - the expected greater value
     *  y_thing - the expected lesser value
     *  msg - *[optional]* informational message about test
     *
     * Returns: 
     *  n/a
     */
    this.is_x_greater_than_y = function(x_thing, y_thing, msg){
	if( x_thing > y_thing ){
	    _complete(true, msg);
	}else{
	    _complete(false, msg);
	}
    };

    /*
     * Function: is_same_url
     *
     * Test whether two links are functionally equivalent.
     *
     * Parameters: 
     *  link1 - url
     *  link2 - url
     *  msg - *[optional]* informational message about test
     *
     * Returns: 
     *  n/a
     */
    this.is_same_url = function(link1, link2, msg){
	_complete(_link_comp(link1, link2), msg);
    };    

    /*
     * Function: is_different_url
     *
     * A negative version of <is_same_url>.
     *
     * Parameters: 
     *  link1 - url
     *  link2 - url
     *  msg - *[optional]* informational message about test
     *
     * Returns: 
     *  n/a
     */
    this.is_different_url = function(link1, link2, msg){
	_complete(! _link_comp(link1, link2), msg);
    };    

    // /*
    //  * Function: is_same_url_by_assembly
    //  *
    //  * Test whether two URLs are functionally equivalent.
    //  *
    //  * Parameters: 
    //  *  link - url
    //  *  base - string
    //  *  psuedo_assembly - hash 
    //  *  msg - *[optional]* informational message about test
    //  *
    //  * Returns: 
    //  *  n/a
    //  */
    // function _psuedo_assmble(assembly){
    // 	var retval = '';
    // 	for( var k2 in hash2 ){
    // 	return retval;
    // }
    // this.is_same_url_by_assembly = function(link, base,
    // 					    psuedo_assembly, msg){
    // 	_complete(_link_comp(link,
    // 			     base + bbop.core.get_assemble(assembly)),
    // 		  msg);
    // };    

    /*
     * Function: is_same_set
     *
     * Test whether two sets (as atomic arrays) are the same.
     *
     * DEPRECATED
     *
     * Parameters: 
     *  set1 - set (as array)
     *  set2 - set (as array)
     *  msg - *[optional]* informational message about test
     *
     * Returns: 
     *  n/a
     */
    this.is_same_set = function(set1, set2, msg){
	_complete(_same_set(set1, set2), msg);
    };

    /*
     * Function: is_different_set
     *
     * A negative version of <is_same_set>.
     *
     * DEPRECATED
     *
     * Parameters: 
     *  set1 - set (as array)
     *  set2 - set (as array)
     *  msg - *[optional]* informational message about test
     *
     * Returns: 
     *  n/a
     */
    this.is_different_set = function(set1, set2, msg){
	_complete(! _same_set(set1, set2), msg);
    };

    /*
     * Function: is_same_hash
     *
     * Test whether two simple atomic hashes are the same.
     *
     * DEPRECATED
     *
     * Parameters: 
     *  hash1 - hash
     *  hash2 - hash
     *  msg - *[optional]* informational message about test
     *
     * Returns: 
     *  n/a
     */
    this.is_same_hash = function(hash1, hash2, msg){
	_complete(_same_hash(hash1, hash2), msg);
    };

    /*
     * Function: is_different_hash
     *
     * A negative version of <is_same_hash>.
     *
     * DEPRECATED
     *
     * Parameters: 
     *  hash1 - hash
     *  hash2 - hash
     *  msg - *[optional]* informational message about test
     *
     * Returns: 
     *  n/a
     */
    this.is_different_hash = function(hash1, hash2, msg){
	_complete(! _same_hash(hash1, hash2), msg);
    };

    /*
     * Function: is_same_thing
     *
     * Test whether two things (not functions) are pretty much the
     * same. For atoms and structures of atoms and other structures.
     *
     * This is a general purpose tool that should replace all the
     * other similarity functions.
     *
     * Parameters: 
     *  thing1 - thing (not function)
     *  thing2 - thing (not function)
     *  msg - *[optional]* informational message about test
     *
     * Returns: 
     *  n/a
     */
    this.is_same_thing = function(thing1, thing2, msg){
	_complete(_is_same(thing1, thing2), msg);
    };

    /*
     * Function: is_different_thing
     *
     * A negative version of <is_same_thing>.
     *
     * This is a general purpose tool that should replace all the
     * other difference functions.
     *
     * Parameters: 
     *  thing1 - thing (not function)
     *  thing2 - thing (not function)
     *  msg - *[optional]* informational message about test
     *
     * Returns: 
     *  n/a
     */
    this.is_different_thing = function(thing1, thing2, msg){
	_complete(! _is_same(thing1, thing2), msg);
    };

    /*
     * Function: is_in_list
     *
     * Test whether an item is in a list (array).
     *
     * Parameters: 
     *  item - the value to test
     *  list - the array to test in
     *  msg - *[optional]* informational message about test
     *
     * Returns: 
     *  n/a
     */
    this.is_in_list = function(item, list, msg){
	_complete(_in_list(item, list), msg);
    };

    /*
     * Function: is_not_in_list
     *
     * A negative version of <is_in_list>.
     *
     * Parameters: 
     *  item - the value to test
     *  list - the array to test in
     *  msg - *[optional]* informational message about test
     *
     * Returns: 
     *  n/a
     */
    this.is_not_in_list = function(item, list, msg){
	_complete(! _in_list(item, list), msg);
    };

    /*
     * Function: is_in_list_diy
     *
     * A DIY version of is_in_list. In this case, you can pass your
     * own comparison function to check the item against the list.
     *
     * Parameters: 
     *  item - the value to test
     *  list - the array to test in
     *  comp - the comparison function; like: function(in_item, list_item){...}
     *  msg - *[optional]* informational message about test
     *
     * Returns: 
     *  n/a
     */
    this.is_in_list_diy = function(item, list, comp, msg){
	_complete(_in_list(item, list, comp), msg);
    };

    /*
     * Function: is_not_in_list_diy
     *
     * A negative version of <is_in_list_diy>.
     *
     * Parameters: 
     *  item - the value to test
     *  list - the array to test in
     *  comp - the comparison function; like: function(in_item, list_item){...}
     *  msg - *[optional]* informational message about test
     *
     * Returns: 
     *  n/a
     */
    this.is_not_in_list_diy = function(item, list, comp, msg){
	_complete(! _in_list(item, list, comp), msg);
    };

    /*
     * Function: is_string_embedded
     *
     * Test whether a target string (target_str) can be made by
     * embedding a string (added_str) into a base string (base_str).
     * 
     * Useful in certain cases when checking URLs.
     *
     * Parameters: 
     *  target_str - the value to test
     *  base_str - the expected value
     *  added_str - the expected value
     *  msg - *[optional]* informational message about test
     *
     * Returns: 
     *  n/a
     */
    this.is_string_embedded = function(target_str, base_str, added_str, msg){
	_complete(_is_string_embedded(target_str, base_str, added_str), msg);
    };

    /*
     * Function: is_string_not_embedded
     *
     * A negative version of <is_string_embedded>.
     *
     * Parameters: 
     *  target_str - the value to test
     *  base_str - the expected value
     *  added_str - the expected value
     *  msg - *[optional]* informational message about test
     *
     * Returns: 
     *  n/a
     */
    this.is_string_not_embedded =
	function(target_str, base_str, added_str, msg){
	    _complete(! _is_string_embedded(target_str, base_str, added_str),
		      msg);
	};

    /*
     * Function: pass
     *
     * Always return test as true--useful when testing using control
     * structures and the like.
     *
     * Parameters: 
     *  msg - *[optional]* informational message about test
     *
     * Returns: 
     *  n/a
     */
    this.pass = function(msg){
	_complete(true, msg);
    };

    /*
     * Function: fail
     *
     * Always return test as false--useful when testing using control
     * structures and the like.
     *
     * Parameters: 
     *  msg - *[optional]* informational message about test
     *
     * Returns: 
     *  n/a
     */
    this.fail = function(msg){
	_complete(false, msg);
    };
};
/* 
 * Package: version.js
 * 
 * Namespace: bbop.version
 * 
 * This package was automatically generated during the build process
 * and contains its version information--this is the release of the
 * API that you have.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.version == "undefined" ){ bbop.version = {}; }

/*
 * Variable: revision
 *
 * Partial version for this library; revision (major/minor version numbers)
 * information.
 */
bbop.version.revision = "2.3.1";

/*
 * Variable: release
 *
 * Partial version for this library: release (date-like) information.
 */
bbop.version.release = "20150423";
/*
 * Package: logger.js
 * 
 * Namespace: bbop.logger
 * 
 * BBOP JS logger object. Using .kvetch(), you can automatically log a
 * message in almost any environment you find yourself in--browser,
 * server wherever. Also, if you have jQuery available and an element
 * with the id "bbop-logger-console-textarea",
 * "bbop-logger-console-text", or "bbop-logger-console-html", the
 * logger will append to that element (with a "\n" (autoscroll), "\n",
 * or "<br />" terminator respectively) instead.
 */

// Module and namespace checking.
if ( typeof bbop == "undefined" ){ var bbop = {}; }

/*
 * Constructor: logger
 * 
 * Arguments: (optional) initial context.
 */
bbop.logger = function(initial_context){

    /*
     * Variable: DEBUG 
     * 
     * Different debugging available per object. Externally toggle
     * between true and false to switch on and off the logging.
     */
    this.DEBUG = false;

    var anchor = this;

    // Define an optional context to tag onto the front of messages.
    this._context = [];
    if( initial_context ){
	this._context = [initial_context];
    }

    /*
     * Function: reset_context
     * 
     * Define the ability to reset the contex.
     * 
     * Arguments:
     *  new_initial_context - (optional) New context to start with.
     */
    this.reset_context = function(new_initial_context){
	if( new_initial_context ){
	    this._context = [new_initial_context];
	}else{
	    this._context = [];	    
	}
    };

    /*
     * Function: push_context
     * 
     * Add an additional logging context to the stack.
     * 
     * Arguments:
     *  new_context - New context to add to the context stack.
     */
    this.push_context = function(new_context){
	this._context.push(new_context);
    };

    /*
     * Function: pop_context
     * 
     * Remove the last context if it's there.
     */
    this.pop_context = function(){
	var popped_context = null;
	if( this._context.length > 0 ){
	    popped_context = this._context.pop();
	}
	return popped_context;
    };

    // Generalizer console (or whatever) printing.
    this._console_sayer = function(){};

    // // Check for: Opera, FF, Safari, Chrome, console, etc.
    // if( typeof(jQuery) != 'undefined' &&
    // 	jQuery('#' + 'bbop-logger-console-textarea') != 'undefined' ){
    // 	    // Our own logging console takes precedence. 
    // 	    this._console_sayer = function(msg){
    // 		var area = jQuery('#'+ 'bbop-logger-console-textarea');
    // 		area.append(msg + "\n");
    // 		try{
    // 		    area.scrollTop(area[0].scrollHeight);
    // 		} catch (x) {
    // 		    // could scroll
    // 		}
    // 	    };
    // }else if( typeof(jQuery) != 'undefined' &&
    // 	jQuery('#' + 'bbop-logger-console-text') != 'undefined' &&
    // 	jQuery('#' + 'bbop-logger-console-text').length != 0 ){
    // 	    // Our own logging console takes precedence. 
    // 	    this._console_sayer = function(msg){
    // 		jQuery('#' + 'bbop-logger-console-text').append(msg + "\n");
    // 	    };
    // }else
    if( typeof(jQuery) != 'undefined' &&
	jQuery('#' + 'bbop-logger-console-html') != 'undefined' &&
	jQuery('#' + 'bbop-logger-console-html').length ){
	    // Our own logging console takes precedence. 
	    this._console_sayer = function(msg){
		var area = jQuery('#'+ 'bbop-logger-console-html');
		area.append(msg + "<br />");
		try{
    		    area.scrollTop(area[0].scrollHeight);
		} catch (x) {
		    // could scroll
		}
		//jQuery('#' + 'bbop-logger-console-html').append(msg + "<br />");
	    };
    }else if( typeof(console) != 'undefined' &&
	      typeof(console.log) == 'function' ){
	// This may be okay for Chrome and a subset of various console
	// loggers. This should now include FF's Web Console and NodeJS.
	//this._console_sayer = function(msg){ console.log(msg + "\n"); };
	// These usually seem to have "\n" incorporated now.
	this._console_sayer = function(msg){ console.log(msg); };
    }else if( typeof(opera) != 'undefined' &&
	typeof(opera.postError) == 'function' ){
	// If Opera is in there, probably Opera.
	this._console_sayer = function(msg){ opera.postError(msg + "\n"); };
    }else if( typeof(window) != 'undefined' &&
	      typeof(window.dump) == 'function' ){
	// From developer.mozilla.org: To see the dump output you have
	// to enable it by setting the preference
	// browser.dom.window.dump.enabled to true. You can set the
	// preference in about:config or in a user.js file. Note: this
	// preference is not listed in about:config by default, you
	// may need to create it (right-click the content area -> New
	// -> Boolean).
	this._console_sayer = function(msg){ dump( msg + "\n"); };
    }else if( typeof(window) != 'undefined' &&
	      typeof(window.console) != 'undefined' &&
	      typeof(window.console.log) == 'function' ){
	// From developer.apple.com: Safari's "Debug" menu allows you
	// to turn on the logging of JavaScript errors. To display the
	// debug menu in Mac OS X, open a Terminal window and type:
	// "defaults write com.apple.Safari IncludeDebugMenu 1" Need
	// the wrapper function because safari has personality
	// problems.
	this._console_sayer = function(msg){ window.console.log(msg + "\n"); };
    }else if( typeof(build) == 'function' &&
	      typeof(getpda) == 'function' &&
	      typeof(pc2line) == 'function' &&
	      typeof(print) == 'function' ){
	// This may detect SpiderMonkey on the comand line.
	this._console_sayer = function(msg){ print(msg); };
    }else if( typeof(org) != 'undefined' &&
	      typeof(org.rhino) != 'undefined' &&
	      typeof(print) == 'function' ){
	// This may detect Rhino on the comand line.
	this._console_sayer = function(msg){ print(msg); };
    }
    
    /*
     * Function: kvetch
     * 
     * Log a string to somewhere. Also return a string to (mostly for
     * the unit tests).
     * 
     * Arguments:
     *  string - The string to print out to wherever we found.
     */
    this.kvetch = function(string){
	var ret_str = null;
	if( anchor.DEBUG == true ){

	    // Make sure there is something there no matter what.
	    if( typeof(string) == 'undefined' ){ string = ''; }

	    // Redefined the string a little if we have contexts.
	    if( anchor._context.length > 0 ){
		var cstr = anchor._context.join(':');
		string = cstr + ': '+ string;
	    }

	    // Actually log to the console.
	    anchor._console_sayer(string);

	    // Bind for output.
	    ret_str = string;
	}
	return ret_str;
    };
};
/* 
 * Package: json.js
 * 
 * Namespace: bbop.json
 * 
 * JSON stringifying and parsing capabilities.  This package is a
 * small modification of json2.js (in the Public Domain from
 * https://raw.github.com/douglascrockford/JSON-js/master/json2.js and
 * http://json.org) to fit in a little more with the style of BBOP
 * JS. As well, the Date prototypes were removed. See json2.js in the
 * source directory for this package for the original.
 * 
 * As much of the original documentation and structure was kept as
 * possible while converting to Naturaldocs and the bbop namespace.
 * 
 * Purpose: Ensure that JSON parsing capabilites exist on all
 * platforms that BBOP JS runs on.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.json == "undefined" ){ bbop.json = {}; }

/*
 * Function: stringify
 * 
 * This method produces a JSON text from a JavaScript value.
 * 
 * When an object value is found, if the object contains a toJSON
 * method, its toJSON method will be called and the result will be
 * stringified. A toJSON method does not serialize: it returns the
 * value represented by the name/value pair that should be serialized,
 * or undefined if nothing should be serialized. The toJSON method
 * will be passed the key associated with the value, and this will be
 * bound to the value.

 * For example, this would serialize Dates as ISO strings.
 * 
 * : Date.prototype.toJSON = function (key) {
 * :         function f(n) {
 * :               // Format integers to have at least two digits.
 * :                    return n < 10 ? '0' + n : n;
 * :                }
 * :
 * :                return this.getUTCFullYear()   + '-' +
 * :                  f(this.getUTCMonth() + 1) + '-' +
 * :                     f(this.getUTCDate())      + 'T' +
 * :                     f(this.getUTCHours())     + ':' +
 * :                     f(this.getUTCMinutes())   + ':' +
 * :                     f(this.getUTCSeconds())   + 'Z';
 * :            };
 * 
 * You can provide an optional replacer method. It will be passed the
 * key and value of each member, with this bound to the containing
 * object. The value that is returned from your method will be
 * serialized. If your method returns undefined, then the member will
 * be excluded from the serialization.
 * 
 * If the replacer parameter is an array of strings, then it will be
 * used to select the members to be serialized. It filters the results
 * such that only members with keys listed in the replacer array are
 * stringified.
 * 
 * Values that do not have JSON representations, such as undefined or
 * functions, will not be serialized. Such values in objects will be
 * dropped; in arrays they will be replaced with null. You can use
 * a replacer function to replace those with JSON values.
 * JSON.stringify(undefined) returns undefined.
 * 
 * The optional space parameter produces a stringification of the
 * value that is filled with line breaks and indentation to make it
 * easier to read.
 * 
 * If the space parameter is a non-empty string, then that string will
 * be used for indentation. If the space parameter is a number, then
 * the indentation will be that many spaces. For example:
 * 
 * : text = JSON.stringify(['e', {pluribus: 'unum'}]);
 * : // text is '["e",{"pluribus":"unum"}]'
 * : 
 * : text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
 * : // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'
 * :
 * : text = JSON.stringify([new Date()], function (key, value) {
 * :          return this[key] instanceof Date ?
 * :                 'Date(' + this[key] + ')' : value;
 * :  });
 * :  // text is '["Date(---current time---)"]'
 *
 * Parameters:
 *  value - any JavaScript value, usually an object or array.
 *  replacer - an optional parameter that determines how object values are stringified for objects. It can be a function or an array of strings.
 *  space - an optional parameter that specifies the indentation of nested structures. If it is omitted, the text will be packed without extra whitespace. If it is a number, it will specify the number of spaces to indent at each level. If it is a string (such as '\t' or '&nbsp;'), it contains the characters used to indent at each level.
 * 
 * Returns: string
 */

/*
 * Function: parse
 * (text, reviver)
 * 
 * This method parses a JSON text to produce an object or array.
 * It can throw a SyntaxError exception.
 * 
 * The optional reviver parameter is a function that can filter and
 * transform the results. It receives each of the keys and values,
 * and its return value is used instead of the original value.
 * If it returns what it received, then the structure is not modified.
 * If it returns undefined then the member is deleted. For example:
 * 
 * : // Parse the text. Values that look like ISO date strings will
 * : // be converted to Date objects.
 * :
 * : myData = JSON.parse(text, function (key, value) {
 * :     var a;
 * :     if (typeof value === 'string') {
 * :         a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
 * :         if (a) {
 * :             return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
 * :                 +a[5], +a[6]));
 * :         }
 * :     }
 * :     return value;
 * : });
 * :
 * : myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
 * :     var d;
 * :     if (typeof value === 'string' &&
 * :             value.slice(0, 5) === 'Date(' &&
 * :             value.slice(-1) === ')') {
 * :         d = new Date(value.slice(5, -1));
 * :                   if (d) {
 * :             return d;
 * :         }
 * :     }
 * :     return value;
 * : });
 * 
 * Parameters:
 *  text - the string to parse to a JavaScript entity.
 *  reviver - *[optional]* optional transforming function for modifying results; see the documentation above for more details.
 * 
 * Returns: well, pretty much anything you put in...
 */

/*jslint evil: true, regexp: true */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/

(function () {
    //'use strict';

    // function f(n) {
    //     // Format integers to have at least two digits.
    //     return n < 10 ? '0' + n : n;
    // }

    // if (typeof Date.prototype.toJSON !== 'function') {

    //     Date.prototype.toJSON = function (key) {

    //         return isFinite(this.valueOf())
    //             ? this.getUTCFullYear()     + '-' +
    //                 f(this.getUTCMonth() + 1) + '-' +
    //                 f(this.getUTCDate())      + 'T' +
    //                 f(this.getUTCHours())     + ':' +
    //                 f(this.getUTCMinutes())   + ':' +
    //                 f(this.getUTCSeconds())   + 'Z'
    //             : null;
    //     };

    //     String.prototype.toJSON      =
    //         Number.prototype.toJSON  =
    //         Boolean.prototype.toJSON = function (key) {
    //             return this.valueOf();
    //         };
    // }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string'
                ? c
                : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0
                    ? '[]'
                    : gap
                    ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
                    : '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0
                ? '{}'
                : gap
                ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
                : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

//    if (typeof bbop.json.stringify !== 'function') {
        bbop.json.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('bbop.json.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
//    }


// If the JSON object does not yet have a parse method, give it one.

//    if (typeof bbop.json.parse !== 'function') {
        bbop.json.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function'
                    ? walk({'': j}, '')
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('bbop.json.parse: ' + text);
        };
//    }
}());
/*
 * Package: template.js
 * 
 * Namespace: bbop.template
 * 
 * BBOP JS template object/enginette.
 * 
 * Some (nonsensical) usage is like:
 * 
 * : var tt = new bbop.template("{{foo}} {{bar}} {{foo}}");
 * : 'A B A' == tt.fill({'foo': 'A', 'bar': 'B'});
 */

// Module and namespace checking.
if ( typeof bbop == "undefined" ){ var bbop = {}; }

/*
 * Constructor: template
 * 
 * Arguments:
 *  template_string - the string template to use for future fill calls
 * 
 * Returns:
 *  self
 */
bbop.template = function(template_string){
    this.is_a = 'bbop.template';

    var anchor = this;

    anchor._template_string = template_string;

    // First break the template string into ordered sections which we
    // will interleve later.
    var split_re = /\{\{[A-Za-z0-9_-]+\}\}/;
    anchor._template_split_strings =
	template_string.split(split_re);

    // Now map out which variables are at which locations.
    var var_id_re = /\{\{[A-Za-z0-9_-]+\}\}/g;
    anchor._var_id_matches =
	template_string.match(var_id_re);
    // Trim off the '{{' and '}}' from the matches.
    bbop.core.each(anchor._var_id_matches,
		  function(item, index){
		      var new_item = item.substring(2, item.length -2);
		      anchor._var_id_matches[index] = new_item;
		  });

    /*
     * Function: fill
     * 
     * Fill the template with the corresponding hash items. Undefined
     * variables are replaced with ''.
     * 
     * Arguments:
     *  fill_hash - the template with the hashed values
     * 
     * Returns:
     *  string
     */
    this.fill = function(fill_hash){
	var ret_str = '';

	bbop.core.each(anchor._template_split_strings,
		       function(str, index){

			   // Add the next bit.
			   ret_str += str;

			   // Add the replacement value if we can make
			   // sense of it.
			   if( index < anchor._var_id_matches.length ){
			       var use_str = '';
			       var varname = anchor._var_id_matches[index];
			       if( varname &&
				   bbop.core.is_defined(fill_hash[varname]) ){
				   use_str = fill_hash[varname];
			       }
			       ret_str += use_str;
			   }
		       });

	return ret_str;
    };

    /*
     * Function: variables
     * 
     * Return a hash of the variables used in the template.
     * 
     * Arguments:
     *  n/a
     * 
     * Returns:
     *  a hash like: {'foo': true, 'bar': true, ...}
     */
    this.variables = function(){
	return bbop.core.hashify(anchor._var_id_matches);
    };

};
/*
 * Package: context.js
 * 
 * Namespace: bbop.context
 * 
 * This package contains an often used set of tools to tease apart a
 * specially structured hash to get things like readable names and
 * colors.
 */

// Module and namespace checking.
if ( typeof bbop == "undefined" ){ var bbop = {}; }

/*
 * Constructor: context
 * 
 * Initial take from go-mme/js/bbop-mme-context.js
 * 
 * Arguments:
 *  entities - a hash defining all of the properties to unscramble
 * default_color - the color to use when a color cannot be found (#800800)
 * 
 * Returns:
 *  aiding object
 */

bbop.context = function(entities, default_color){
    
    // Make sure some kind of color is there.
    if( ! default_color ){
	default_color = '#808080'; // grey
    }
    
    // Compile entity aliases.
    var entity_aliases = {};
    bbop.core.each(entities,
		   function(ekey, eobj){
		       entity_aliases[ekey] = ekey; // identity
		       bbop.core.each(eobj['aliases'],
				      function(alias){
					  entity_aliases[alias] = ekey;
				      });
		   });

    // Helper fuction to go from unknown id -> alias -> data structure.
    this._dealias_data = function(id){
	
	var ret = null;
	if( id ){
	    if( entity_aliases[id] ){ // directly pull
		var tru_id = entity_aliases[id];
		ret = entities[tru_id];
	    }
	}

	return ret;
    };

    /* 
     * Function: readable
     *
     * Returns a human readable form of the inputted string.
     *
     * Parameters: 
     *  ind - incoming data id
     *
     * Returns:
     *  readable string or original string
     */
    this.readable = function(ind){
	var ret = ind;

	var data = this._dealias_data(ind);
	if( data && data['readable'] ){
	    ret = data['readable'];
	}
	
	return ret;
    };

    /* 
     * Function: color
     *
     * Return the string of a color of a rel.
     *
     * Parameters: 
     *  ind - incoming data id
     *
     * Returns:
     *  appropriate color string or 'grey'
     */
    this.color = function(ind){
	
	var ret = default_color;

	var data = this._dealias_data(ind);
	if( data && data['color'] ){
	    ret = data['color'];
	}
	
	return ret;
    };

    /* 
     * Function: relation_glyph
     *
     * Return the string indicating the glyph to use for the edge marking.
     *
     * Parameters: 
     *  ind - incoming data id
     *
     * Returns:
     *  appropriate color string or null
     */
    this.glyph = function(ind){
	
	var ret = null; // default

	var data = this._dealias_data(ind);
	if( data && data['glyph'] ){
	    ret = data['glyph'];
	}
	
	return ret;
    };

    /* 
     * Function: priority
     *
     * Return a number representing the relative priority of the
     * entity under consideration.
     *
     * Parameters: 
     *  ind - incoming data id
     *
     * Returns:
     *  appropriate integer or 0
     */
    this.priority = function(ind){
	
	var ret = 0;

	var data = this._dealias_data(ind);
	if( data && data['priority'] ){
	    ret = data['priority'];
	}
	
	return ret;
    };

    /* 
     * Function: all_entities
     *
     * Return a list of the currently known entities.
     *
     * Parameters: 
     *  n/a
     *
     * Returns:
     *  list
     */
    this.all_entities = function(){	
	var rls = bbop.core.get_keys(entities);
	return rls;
    };

    /* 
     * Function: all_known
     *
     * Return a list of the currently known entities and their aliases.
     *
     * Parameters: 
     *  n/a
     *
     * Returns:
     *  list
     */
    this.all_known = function(){	
	var rls = bbop.core.get_keys(entity_aliases);
	return rls;
    };
};
/*
 * Package: logic.js
 * 
 * Namespace: bbop.logic
 * 
 * BBOP object to try and take some of the pain out of managing the
 * boolean logic that seems to show up periodically. Right now mostly
 * aimed at dealing with Solr/GOlr.
 * 
 * Anatomy of a core data bundle.
 * 
 * : data_bundle => {op: arg}
 * : op => '__AND__', '__OR__', '__NOT__'
 * : arg => <string>, array, data_bundle
 * : array => [array_item*]
 * : array_item => <string>, data
 * 
 * Example:
 * 
 * : {and: [{or: ...}, {or: ...}, {and: ...} ]}
 * : var filters = {'and': []};
 *
 * TODO: parens between levels
 */

// Module and namespace checking.
if ( typeof bbop == "undefined" ){ var bbop = {}; }

/*
 * Constructor: logic
 * 
 * Contructor for the bbop.logic object. NOTE: during processing,
 * binary operators with a single argument cease to exist as they will
 * never make it to output.
 * 
 * Arguments:
 *  default_conjuntion - *[optional]* "and" or "or"; defaults to "and"
 * 
 * Returns:
 *  bbop logic object
 */
bbop.logic = function(default_conjunction){
    this._is_a = 'bbop.logic';

    // Add logging.
    var logger = new bbop.logger();
    //logger.DEBUG = true;
    logger.DEBUG = false;
    function ll(str){ logger.kvetch(str); }

    var logic_anchor = this;

    // // Handling conjunctions.
    // this._and = '__AND__';
    // this._or = '__OR__';
    // this._not = '__NOT__';
    // function _is_token(possible_token){
    // 	var retval = false;
    // 	if( possible_token == this._and ||
    // 	    possible_token == this._or ||
    // 	    possible_token == this._not ){
    // 	   retval = true; 
    // 	}
    // 	return retval;
    // }
    // // Convert the internal
    // function _usable

    // // Set the internal default conjunction. Default to "and".
    // if( ! default_conjunction ){
    // 	default_conjunction = this._and;
    // }else if( default_conjunction == this._or ){
    // 	default_conjunction = this._or;
    // }else{
    // 	default_conjunction = this._and;
    // }
    if( ! default_conjunction ){
    	default_conjunction = 'and';
    }
    this.default_conjunction = default_conjunction;

    // Set initial state.
    // ie: this._bundle = {'__AND__': []};
    //this._bundle = {};
    //this._bundle[this.default_conjunction] = [];
    // See documentation for empty().
    var _empty = function(){
	logic_anchor._bundle = {};
	logic_anchor._bundle[logic_anchor.default_conjunction] = [];
    };
    _empty();

    /*
     * Function: add
     * 
     * Add to the current stored logic bundle.
     * 
     * Parameters:
     *  item - string or bbop.logic object
     * 
     * Returns:
     *  n/a
     */
    //this.and = function(){
    //this.or = function(){
    //this.not = function(){
    this.add = function(item){

	// Add things a little differently if it looks like a bit of
	// logic.
	if(  bbop.core.what_is(item) == 'bbop.logic' ){
	    this._bundle[this.default_conjunction].push(item._bundle);
	}else{
	    this._bundle[this.default_conjunction].push(item);
	}
    };

    /*
     * Function: negate
     * 
     * Negate the current stored logic.
     * 
     * TODO/BUG: I think this might cause an unreleasable circular
     * reference.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  n/a
     */
    this.negate = function(){
	var nega = {};
	nega['not'] = this._bundle;
	this._bundle = nega;
    };
    
    // Walk the data structure...
    this._read_walk = function(data_bundle, in_encoder, lvl){
	
	// The encoder defaults to whatever--no transformations
	var encoder = in_encoder || function(in_out){ return in_out; };

	ll("LRW: with: " + bbop.core.dump(data_bundle));

	// If level is not defined, we just started and we're on level
	// one, the first level.
	var l_enc = '(';
	var r_enc = ')';
	if( typeof(lvl) == 'undefined' ){
	    lvl = 1;
	    l_enc = '';
	    r_enc = '';
	}	

	var read = '';
	
	// The task of walking is broken into the terminal case (a
	// string) or things that we need to operate on (arrays or
	// sub-data_bundles).
	if( bbop.core.what_is(data_bundle) == 'string' ){
	    ll("LRW: trigger string");
	    read = data_bundle;
	}else{
	    ll("LRW: trigger non-string");

	    // Always single op.
	    var op = bbop.core.get_keys(data_bundle)[0];
	    var arg = data_bundle[op];

	    // We can treat the single data_bundle/string case like a
	    // degenerate array case.
	    if( ! bbop.core.is_array(arg) ){
		arg = [arg];
	    }

	    // Recure through the array and join the results with the
	    // current op.
	    //ll('L: arg: ' + bbop.core.what_is(arg));
	    var stack = [];
	    bbop.core.each(arg, function(item, i){
			       stack.push(logic_anchor._read_walk(item,
								  encoder,
								  lvl + 1));
			   });

	    // Slightly different things depending on if it's a unary
	    // or binary op.
	    if( op == 'not' ){
		// TODO: I believe that it should no be possible
		// (i.e. policy by code) to have a 'not' with more
		// that a single argument.
		read = op + ' ' + stack.join('');
	    }else{
		read = l_enc + stack.join(' ' + op + ' ') + r_enc;
	    }
	}

	
	ll("LRW: returns: " + read);
	return read;
    };

    /*
     * Function: to_string
     * 
     * Dump the current data out to a string.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  n/a
     */
    this.to_string = function(){
	return logic_anchor._read_walk(logic_anchor._bundle);
    };

    /*
     * Function: url
     * 
     * TODO
     * 
     * Dump the current data out to a URL.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  n/a
     */
    this.url = function(){
	return logic_anchor._read_walk(logic_anchor._bundle);
    };

    /*
     * Function: empty
     * 
     * Empty/reset self.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  n/a
     */
    // Staggered declaration so I can use it above during initialization.
    this.empty = _empty;

    /*
     * Function: parse
     * 
     * TODO: I think I can grab the shunting yard algorithm for a
     * similar problem in the old AmiGO 1.x codebase.
     * 
     * Parse an incoming string into the internal data structure.
     * 
     * Parameters:
     *  in_str - the incoming string to parse
     * 
     * Returns:
     *  n/a
     */
    this.parse = function(in_str){
	return null;
    };

};
/* 
 * Package: registry.js
 * 
 * Namespace: bbop.registry
 * 
 * BBOP generic lightweight listener/callback registry system.
 */

// Module and namespace checking.
if ( typeof bbop == "undefined" ){ var bbop = {}; }

/*
 * Constructor: registry
 * 
 * Contructor for BBOP registry. Takes a list of event categories as
 * strings.
 * 
 * Arguments:
 *  evt_list - a list of strings that identify the events to be used
 * 
 * Returns:
 *  bbop registry object
 */
bbop.registry = function(evt_list){
    this._is_a = 'bbop.registry';

    var registry_anchor = this;

    // Handle the registration of call functions to get activated
    // after certain events.
    this.callback_registry = {};
    bbop.core.each(evt_list, function(item, i){
		       registry_anchor.callback_registry[item] = {};
		   });
    
    /*
     * Function: register
     *
     * Add the specified function from the registry, with an optional
     * relative priority against other callback functions.
     *
     * The in_priority value is relative to others in the category,
     * with a higher priority...getting priority.
     * 
     * Parameters: 
     *  category - string; one of the pre-defined categories
     *  function_id - string; a unique string to identify a function
     *  in_function - function
     *  in_priority - *[optional]* number
     *
     * Returns: 
     *  n/a
     * 
     * See also:
     *  <apply>
     */
    this.register = function(category, function_id, in_function, in_priority){

	// Only these categories.
	if( typeof(registry_anchor.callback_registry[category]) == 'undefined'){
	    throw new Error('cannot register, unknown category');
	}

	// The default priority is 0.
	var priority = 0;
	if( in_priority ){ priority = in_priority; }

	registry_anchor.callback_registry[category][function_id] =
	    {
		runner: in_function,
		priority: priority
	    };
    };

    /*
     * Function: is_registered
     *
     * Returns whether or not an id has already been registered to a
     * category. Will return null if the category does not exist.
     * 
     * Parameters: 
     *  category - string; one of the pre-defined categories
     *  function_id - string; a unique string to identify a function
     *
     * Returns: 
     *  true, false, or null
     */
    this.is_registered = function(category, function_id){

	var retval = null;

	var anc = registry_anchor.callback_registry;

	//
	if( typeof(anc[category]) != 'undefined'){
	    
	    retval = false;

	    if( typeof(anc[category][function_id]) != 'undefined'){
		retval = true;
	    }
	}

	return retval;
    };

    /*
     * Function: unregister
     *
     * Remove the specified function from the registry. Must specify a
     * legitimate category and the function id of the function in it.
     *
     * Parameters: 
     *  category - string
     *  function_id - string
     *
     * Returns: 
     *  boolean on whether something was unregistered
     */
    this.unregister = function(category, function_id){
	var retval = false;
	if( registry_anchor.callback_registry[category] &&
	    registry_anchor.callback_registry[category][function_id] ){
		delete registry_anchor.callback_registry[category][function_id];
		retval = true;
            }
	return retval;
    };
    
    /*
     * Function: get_callbacks
     *
     * Generic getter for callback functions, returns by priority.
     *
     * Parameters: 
     *  category - string
     *
     * Returns: 
     *  an ordered (by priority) list of function_id strings
     */
    this.get_callbacks = function(category){

	var cb_id_list =
	    bbop.core.get_keys(registry_anchor.callback_registry[category]);
	// Sort callback list according to priority.
	var ptype_registry_anchor = this;
	cb_id_list.sort(
	    function(a, b){  
		var pkg_a =
		    ptype_registry_anchor.callback_registry[category][a];
		var pkg_b =
		    ptype_registry_anchor.callback_registry[category][b];
		return pkg_b['priority'] - pkg_a['priority'];
	    });
	
	// Collect the actual stored functions by priority.
	var cb_fun_list = [];
	for( var cbi = 0; cbi < cb_id_list.length; cbi++ ){
	    var cb_id = cb_id_list[cbi];
	    var to_run =
		registry_anchor.callback_registry[category][cb_id]['runner'];
	    cb_fun_list.push(to_run);
	    // ll('callback: ' + category + ', ' + cb_id + ', ' +
	    //    this.callback_registry[category][cb_id]['priority']);
	}
	
	return cb_fun_list;
    };

    /*
     * Function: apply_callbacks
     *
     * Generic runner for prioritized callbacks with various arguments
     * and an optional change in context..
     *
     * Parameters: 
     *  category - string
     *  arg_list - a list of arguments to pass to the function in the category
     *  context - *[optional]* the context to apply the arguments in
     *
     * Returns: 
     *  n/a
     */
    this.apply_callbacks = function(category, arg_list, context){

	// Run all against registered functions.
	var callbacks = registry_anchor.get_callbacks(category);
	for( var ci = 0; ci < callbacks.length; ci++ ){
	    var run_fun = callbacks[ci];
	    //run_fun(arg_list);
	    run_fun.apply(context, arg_list);
	}
    };
};
/* 
 * Package: html.js
 * 
 * Namespace: bbop.html
 * 
 * Right now contains bbop.html.tag, but all html producing functions
 * should go in here somewhere.
 * 
 * All bbop.html implement the interface:
 *  .to_string(): returns a string of you and below
 *  .add_to(): add things between the tags
 *  .empty(): empties all things between the tags
 *  .get_id(): return the id or null if not defined
 * These are enforced during the tests.
 * 
 * For functions that take attribute hashes, there is a special
 * attribute {'generate_id': true} that will generate a somewhat
 * random id if an incoming id was not already specified. This id can
 * be retrieved using get_id().
 * 
 * This package takes all of the bbop.html.* namespace.
 */

// Module and namespace checking.
if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.html == "undefined" ){ bbop.html = {}; }
if ( typeof bbop.html.tag == "undefined" ){ bbop.html.tag = {}; }
if ( typeof bbop.html.accordion == "undefined" ){ bbop.html.accordion = {}; }
if ( typeof bbop.html.list == "undefined" ){ bbop.html.list = {}; }
if ( typeof bbop.html.input == "undefined" ){ bbop.html.input = {}; }
if ( typeof bbop.html.img == "undefined" ){ bbop.html.img = {}; }

/*
 * Namespace: bbop.html.tag
 * 
 * Constructor: tag
 * 
 * Create the fundamental tag object to work with and extend.
 * 
 * Parameters:
 *  tag - the tag name to be created
 *  attrs - *[serially optional]* the typical attributes to add
 *  below - *[optional]* a list/array of other html objects that exists "between" the tags
 * 
 * Returns:
 *  bbop.html.tag object
 */
bbop.html.tag = function(tag, attrs, below){
    this._is_a = 'bbop.html.tag';

    // Arg check--attrs should be defined as something.
    if( ! attrs ){
	attrs = {};
    }else{
	// Prevent sharing of structure.
	attrs = bbop.core.clone(attrs);
    }

    // Generate (or not) id if it was requested.
    if( ! bbop.core.is_defined(attrs['id']) &&
	bbop.core.is_defined(attrs['generate_id']) &&
	bbop.core.is_defined(attrs['generate_id']) == true ){
	    // Add a real id.
	    attrs['id'] = 'gen_id-bbop-html-'+ bbop.core.randomness(20);
	    // Remove the 'generated_id' property.
	    delete attrs['generate_id'];
	}
    this._attrs = attrs;
    
    // Arg check--below should be some kind of an array.
    if( ! below ){
	below = [];
    }else if( bbop.core.is_array(below) ){
	// do nothing
    }else{
	// hopefully a bbop.html.tag then
	below = [below];
    }

    // Accumulate the incoming attributes if there are any.
    var additional_attrs = '';
    bbop.core.each(this._attrs, function(in_key, in_val){
		       additional_attrs = additional_attrs + ' ' +
			   in_key + '="' + in_val + '"';
		   });

    this._car = '<' + tag + additional_attrs + '>';
    this._cdr = '</' + tag + '>';
    this._contents = below;
    this._singleton = '<' + tag + additional_attrs + ' />';
};

/*
 * Function: to_string
 * 
 * Convert a tag object into a html-ized string.
 * 
 * Parameters: n/a
 * 
 * Returns:
 *  string
 */
bbop.html.tag.prototype.to_string = function(){
    var acc = '';
    bbop.core.each(this._contents,
		   function(item, i){
		       // if( typeof(item) == 'string' ){
		       // 	   acc = acc + item;
		       // }else if( typeof(item['to_string']) == 'function' ){
		       // 	   acc = acc + item.to_string();
		       // }else{
		       // 	   throw new Error('No to_string for (' +
		       // 			   bbop.core.what_is(item) +
		       // 			   ') ' + item);
		       // }
		       acc = acc + bbop.core.to_string(item);
		   });
    
    // Special return case if there are no children (to prevent
    // weirdness for things like br and input).
    var output = this._singleton;
    if( acc != '' ){ output = this._car + acc + this._cdr; }

    return output;
};

/*
 * Function: add_to
 * 
 * Add content between the tags. Order of addition is order of output.
 * 
 * Parameters:
 *  bbop_html_tag_or_string - another tag object or a string (html or otherwise)
 * 
 * Returns: n/a
 */
bbop.html.tag.prototype.add_to = function(bbop_html_tag_or_string){
    this._contents.push(bbop_html_tag_or_string);
};

/*
 * Function: empty
 * 
 * Remove all content between the tags.
 * 
 * Parameters: n/a
 * 
 * Returns: n/a
 */
bbop.html.tag.prototype.empty = function(){
    this._contents = [];
};

/*
 * Function: get_id
 * 
 * Return the id if extant, null otherwise.
 * 
 * Parameters: n/a
 * 
 * Returns: string or null
 */
bbop.html.tag.prototype.get_id = function(){
    var retval = null;
    if( bbop.core.is_defined(this._attrs['id']) ){
	retval = this._attrs['id'];
    }
    return retval;
};

/*
 * Namespace: bbop.html.accordion
 * 
 * Constructor: accordion
 * 
 * Create the a frame for the functional part of a jQuery accordion
 * structure.
 * 
 * :Input:
 * : [[title, string/*.to_string()], ...]
 * :
 * :Output:
 * : <div id="accordion">
 * :  <h3><a href="#">Section 1</a></h3>
 * :  <div>
 * :   <p>
 * :    foo
 * :   </p>
 * :  </div>
 * :  ...
 * : </div>
 * 
 * Parameters:
 *  in_list - accordion frame headers: [[title, string/*.to_string()], ...]
 *  attrs - *[serially optional]* attributes to apply to the new top-level div
 *  add_id_p - *[optional]* true or false; add a random id to each section
 * 
 * Returns:
 *  bbop.html.accordion object
 * 
 * Also see: <tag>
 */
bbop.html.accordion = function(in_list, attrs, add_id_p){
    this._is_a = 'bbop.html.accordion';

    //
    if( typeof(add_id_p) == 'undefined' ){ add_id_p = false; }

    // Arg check--attrs should be defined as something.
    this._attrs = attrs || {};

    // Internal stack always starts with a div.
    this._div_stack = new bbop.html.tag('div', this._attrs);

    this._section_id_to_content_id = {};

    // Iterate over the incoming argument list.
    var accordion_this = this;
    bbop.core.each(in_list, function(item){
		       var sect_title = item[0];
		       var content = item[1];
		       accordion_this.add_to(sect_title, content, add_id_p);
		   });
};

/*
 * Function: to_string
 * 
 * Convert the accordion object into a html-ized string.
 * 
 * Parameters: n/a
 * 
 * Returns:
 *  string
 */
bbop.html.accordion.prototype.to_string = function(){
    return this._div_stack.to_string();
};

/*
 * Function: add_to
 * 
 * Add a contect section to the accordion.
 * 
 * Parameters:
 *  section_info - a string or a hash with 'id', 'label', and 'description'
 *  content_blob - string or bbop.html object to put in a section
 *  add_id_p - *[optional]* true or false; add a random id to the section
 * 
 * Returns: n/a
 */
bbop.html.accordion.prototype.add_to =
    function(section_info, content_blob, add_id_p){

    // If section_info isn't an object, assume it is a string and use
    // it for everything.
    var section_id = null;
    var section_label = null;
    var section_desc = null;
    if(typeof section_info != 'object' ){
	section_id = section_info;
	section_label = section_info;
    }else{
	if( section_info['id'] ){ section_id = section_info['id']; }
	if( section_info['label'] ){ section_label = section_info['label']; }
	if( section_info['description'] ){
	    section_desc = section_info['description'];
	}
    }

    // Add header section.
    //var h3 = new bbop.html.tag('h3', {title: section_desc});
    var h3 = new bbop.html.tag('h3');
    var anc = null;
    if( section_desc ){
	// anc = new bbop.html.tag('a', {href: '#'}, section_label);
	anc = new bbop.html.tag('a', {href: '#', title: section_desc},
				section_label);
    }else{
	anc = new bbop.html.tag('a', {href: '#'}, section_label);
    }
    h3.add_to(anc);
    this._div_stack.add_to(h3);

    var div = null;

    // Generate random id for the div.
    if( typeof(add_id_p) == 'undefined' ){ add_id_p = false; }
    if( add_id_p ){
	var rid = 'accordion-' + section_id + '-' + bbop.core.randomness(20);
	this._section_id_to_content_id[section_id] = rid;    
	div = new bbop.html.tag('div', {'id': rid});	
    }else{
	div = new bbop.html.tag('div');	
    }

    // Add add content stub to section.
   var p = new bbop.html.tag('p', {}, bbop.core.to_string(content_blob));
    div.add_to(p);
    this._div_stack.add_to(div);
};

// // Add a section to the accordion.
// bbop.html.accordion.prototype.add_to_section = function(sect_id, content){
//     var cdiv = this._section_id_to_content_div[sect_id];
//     if( ! cdiv ){
// 	throw new Error('Cannot add to undefined section.');
//     }
// };

/*
 * Function: empty
 * 
 * Empty all sections from the accordion.
 * 
 * Parameters: n/a
 * 
 * Returns: n/a
 */
bbop.html.accordion.prototype.empty = function(){
    this._div_stack = new bbop.html.tag('div', this._attrs);
    this._section_id_to_content_id = {};
};

/*
 * Function: get_id
 * 
 * Return the id if extant, null otherwise.
 * 
 * Parameters: n/a
 * 
 * Returns: string or null
 */
bbop.html.accordion.prototype.get_id = function(){
    return this._div_stack.get_id();
};

/*
 * Function: get_section_id
 * 
 * Get the "real" section id by way of the "convenience" section id?
 * 
 * Parameters:
 *  sect_id - TODO ???
 * 
 * Returns: TODO ???
 */
bbop.html.accordion.prototype.get_section_id = function(sect_id){
	return this._section_id_to_content_id[sect_id];    
};


// // TODO: just empty the contents from an ided section.
// bbop.html.accordion.prototype.empty_section = function(sect_id){
//     var div = this._section_id_to_content_div[sect_id];
//     div.empty();
// };

/*
 * Namespace: bbop.html.list
 * 
 * Constructor: list
 * 
 * Create the a frame for an unordered list object.
 * 
 * :Input:
 * : [string/*.to_string(), ...]
 * :
 * :Output:
 * : <ul id="list">
 * :  <li>foo</li>
 * :   ...
 * : </ul>
 * 
 * Parameters:
 *  in_list - list of strings/bbop.html objects to be li separated
 *  attrs - *[optional]* attributes to apply to the new top-level ul
 * 
 * Returns:
 *  bbop.html.list object
 * 
 * Also see: <tag>
 */
bbop.html.list = function(in_list, attrs){
    this._is_a = 'bbop.html.list';
    
    // Arg check--attrs should be defined as something.
    if( ! attrs ){ attrs = {}; }
    this._attrs = attrs;

    // Internal stack always starts with a ul.
    this._ul_stack = new bbop.html.tag('ul', this._attrs);

    var list_this = this;
    bbop.core.each(in_list, function(item){ list_this.add_to(item); });
};

/*
 * Function: to_string
 * 
 * Convert a list object into a html-ized string.
 * 
 * Parameters: n/a
 * 
 * Returns:
 *  string
 */
bbop.html.list.prototype.to_string = function(){
    return this._ul_stack.to_string();
};

/*
 * Function: add_to
 * 
 * Add a new li section to a list.
 * 
 * Optionally, it can take multiple arguments and will add each of
 * them to the new li tag in turn.
 * 
 * Parameters:
 *  item1 - another tag object or a string (html or otherwise)
 *  item2 - *[optional]* ...on forever
 * 
 * Returns: n/a
 */
bbop.html.list.prototype.add_to = function(){

    // Convert anonymous arguments into an Array.
    var args = Array.prototype.slice.call(arguments); 

    // Cycle through and add them to the accumulator for the new li.
    var li_acc = [];
    bbop.core.each(args,
		   function(arg){
		       li_acc.push(bbop.core.to_string(arg));
		   });

    // Join them and add them to the stack of the encompassing ul.
    var li = new bbop.html.tag('li', {}, li_acc.join(" "));
    this._ul_stack.add_to(li);
};

/*
 * Function: empty
 * 
 * Remove all content (li's) from the list.
 * 
 * Parameters: n/a
 * 
 * Returns: n/a
 */
bbop.html.list.prototype.empty = function(){
    this._ul_stack = new bbop.html.tag('ul', this._attrs);
};

/*
 * Function: get_id
 * 
 * Return the id if extant, null otherwise.
 * 
 * Parameters: n/a
 * 
 * Returns: string or null
 */
bbop.html.list.prototype.get_id = function(){
    return this._ul_stack.get_id();
};

/*
 * Namespace: bbop.html.input
 * 
 * Constructor: input
 * 
 * Create a form input.
 * 
 * Parameters:
 *  attrs - *[optional]* the typical attributes to add
 * 
 * Returns:
 *  bbop.html.input object
 */
bbop.html.input = function(attrs){
    this._is_a = 'bbop.html.input';
    
    // Arg check--attrs should be defined as something.
    if( ! attrs ){ attrs = {}; }
    this._attrs = attrs;

    // Internal stack always starts with a ul.
    this._input_stack = new bbop.html.tag('input', this._attrs);
};

/*
 * Function: to_string
 * 
 * Convert an input into a html-ized string.
 * 
 * Parameters: n/a
 * 
 * Returns:
 *  string
 */
bbop.html.input.prototype.to_string = function(){
    return this._input_stack.to_string();
};

/*
 * Function: add_to
 * 
 * Add content between the input tags.
 * 
 * Parameters:
 *  item - another tag object or a string (html or otherwise)
 * 
 * Returns: n/a
 */
bbop.html.input.prototype.add_to = function(item){
    this._input_stack.add_to(bbop.core.to_string(item));
};

/*
 * Function: empty
 * 
 * Reset/remove all children.
 * 
 * Parameters: n/a
 * 
 * Returns: n/a
 */
bbop.html.input.prototype.empty = function(){
    this._input_stack = new bbop.html.tag('input', this._attrs);
};

/*
 * Function: get_id
 * 
 * Return the id if extant, null otherwise.
 * 
 * Parameters: n/a
 * 
 * Returns: string or null
 */
bbop.html.input.prototype.get_id = function(){
    return this._input_stack.get_id();
};

/*
 * Namespace: bbop.html.anchor
 * 
 * Constructor: anchor
 * 
 * Create an anchor object. Note: href, title, etc. go through
 * in_attrs.
 * 
 * Parameters:
 *  in_cont - the contents between the "a" tags
 *  in_attrs - *[optional]* the typical attributes to add
 * 
 * Returns:
 *  bbop.html.anchor object
 */
bbop.html.anchor = function(in_cont, in_attrs){
    this._is_a = 'bbop.html.anchor';
    
    // Arg check--attrs should be defined as something.
    this._attrs = in_attrs || {};

    // Internal stack always starts with a ul.
    this._anchor_stack = new bbop.html.tag('a', this._attrs, in_cont);
};

/*
 * Function: to_string
 * 
 * Convert an anchor object into a html-ized string.
 * 
 * Parameters: n/a
 * 
 * Returns:
 *  string
 */
bbop.html.anchor.prototype.to_string = function(){
    return this._anchor_stack.to_string();
};

/*
 * Function: add_to
 * 
 * Add content between the tags. Order of addition is order of output.
 * 
 * Parameters:
 *  item - another tag object or a string (html or otherwise)
 * 
 * Returns: n/a
 */
bbop.html.anchor.prototype.add_to = function(item){
    this._anchor_stack.add_to(item);
};

/*
 * Function: empty
 * 
 * Remove all content between the tags.
 * 
 * Parameters: n/a
 * 
 * Returns: n/a
 */
bbop.html.anchor.prototype.empty = function(){
    this._anchor_stack.empty();
};

/*
 * Function: get_id
 * 
 * Return the id if extant, null otherwise.
 * 
 * Parameters: n/a
 * 
 * Returns: string or null
 */
bbop.html.anchor.prototype.get_id = function(){
    return this._anchor_stack.get_id();
};

/*
 * Namespace: bbop.html.image
 * 
 * Constructor: image
 * 
 * Create an image (img) object. Note: alt, title, etc. go through
 * in_attrs.
 * 
 * Parameters:
 *  in_attrs - *[optional]* the typical attributes to add
 * 
 * Returns:
 *  bbop.html.image object
 */
bbop.html.image = function(in_attrs){
    this._is_a = 'bbop.html.image';
    
    // Arg check--attrs should be defined as something.
    this._attrs = in_attrs || {};

    // Internal stack always starts with a ul.
    this._image_stack = new bbop.html.tag('img', this._attrs);
};

/*
 * Function: to_string
 * 
 * Convert an image object into a html-ized string.
 * 
 * Parameters: n/a
 * 
 * Returns:
 *  string
 */
bbop.html.image.prototype.to_string = function(){
    return this._image_stack.to_string();
};

/*
 * Function: add_to
 * 
 * Add content between the tags. Order of addition is order of output.
 * 
 * Parameters:
 *  item - another tag object or a string (html or otherwise)
 * 
 * Returns: n/a
 */
bbop.html.image.prototype.add_to = function(item){
    this._image_stack.add_to(item);
};

/*
 * Function: empty
 * 
 * Remove all content between the tags.
 * 
 * Parameters: n/a
 * 
 * Returns: n/a
 */
bbop.html.image.prototype.empty = function(){
    this._image_stack.empty();
};

/*
 * Function: get_id
 * 
 * Return the id if extant, null otherwise.
 * 
 * Parameters: n/a
 * 
 * Returns: string or null
 */
bbop.html.image.prototype.get_id = function(){
    return this._image_stack.get_id();
};

/*
 * Namespace: bbop.html.table
 * 
 * Constructor: table
 * 
 * Create a simple table structure.
 * in_headers is necessary, but can be empty.
 * in_entries is necessary, but can be empty.
 * 
 * Parameters:
 *  in_headers - ordered list of headers
 *  in_entries - lists of lists of entry items
 *  in_attrs - *[optional]* the typical attributes to add to the table
 * 
 * Returns:
 *  bbop.html.table object
 */
bbop.html.table = function(in_headers, in_entries, in_attrs){
    this._is_a = 'bbop.html.table';
    
    // Arg check--attrs should be defined as something.
    var headers = in_headers || [];
    var entries = in_entries || [];
    this._attrs = in_attrs || {};

    // Row class count.
    this._count = 0;

    // Internal stack always starts with a table.
    this._table_stack = new bbop.html.tag('table', this._attrs);

    // Only add headers if they exist.
    if( ! bbop.core.is_empty(headers) ){
	var head_row = new bbop.html.tag('tr');
	bbop.core.each(headers,
		       function(header){
			   var th = new bbop.html.tag('th');
			   th.add_to(header);
			   head_row.add_to(th);
		       });
	var head_stack = new bbop.html.tag('thead');
	head_stack.add_to(head_row);
	this._table_stack.add_to(head_stack);
    }

    // Add incoming rows to the body. Keep the body stack around for
    // bookkeeping.
    this._body_stack = new bbop.html.tag('tbody');
    this._table_stack.add_to(this._body_stack);

    var this_table = this;
    bbop.core.each(entries, function(item){ this_table.add_to(item); });
};

/*
 * Function: to_string
 * 
 * Convert a table object into a html-ized string.
 * 
 * Parameters: n/a
 * 
 * Returns:
 *  string
 */
bbop.html.table.prototype.to_string = function(){
    return this._table_stack.to_string();
};

/*
 * Function: add_to
 * 
 * Add data row. The entries argument is coerced into an array of tds.
 * 
 * Parameters:
 *  entries - lists of lists of entry items
 * 
 * Returns: n/a
 */
bbop.html.table.prototype.add_to = function(entries){
    
    //this._body_stack = new bbop.html.tag('tbody');

    // Get the class for the row.
    var row_class = 'odd_row';
    if( this._count % 2 == 0 ){ row_class = 'even_row'; }
    this._count = this._count + 1;

    var tr = new bbop.html.tag('tr', {'class': row_class});

    // Array or not, add everything as tds.
    if( ! bbop.core.is_array(entries) ){ entries = [entries]; }
    bbop.core.each(entries,
		   function(entry){
		       var td = new bbop.html.tag('td');
		       td.add_to(entry);
		       tr.add_to(td);
		   });
    this._body_stack.add_to(tr);
};

/*
 * Function: empty
 * 
 * Headers do not get wiped, just the data rows in the tbody.
 * 
 * Parameters: n/a
 * 
 * Returns: n/a
 */
bbop.html.table.prototype.empty = function(){
    this._count = 0;
    this._body_stack.empty();
};

/*
 * Function: get_id
 * 
 * Return the id if extant, null otherwise.
 * 
 * Parameters: n/a
 * 
 * Returns: string or null
 */
bbop.html.table.prototype.get_id = function(){
    return this._table_stack.get_id();
};

/*
 * Namespace: bbop.html.button
 * 
 * Constructor: button
 * 
 * Create a button object.
 * For after-the-fact decoration, take a look at:
 * <https://jquery-ui.googlecode.com/svn/tags/1.6rc5/tests/static/icons.html>
 * 
 * Parameters:
 *  in_label - label
 *  in_attrs - *[optional]* the typical attributes to add
 * 
 * Returns:
 *  bbop.html.button object
 */
bbop.html.button = function(in_label, in_attrs){
    this._is_a = 'bbop.html.button';
    
    // Arg check--attrs should be defined as something.
    this._attrs = in_attrs || {};

    // Internal stack is just the top-level button.
    this._button_stack = new bbop.html.tag('button', this._attrs, in_label);
};

/*
 * Function: to_string
 * 
 * Convert a button object into a html-ized string.
 * 
 * Parameters: n/a
 * 
 * Returns:
 *  string
 */
bbop.html.button.prototype.to_string = function(){
    return this._button_stack.to_string();
};

/*
 * Function: add_to
 * 
 * Add content between the tags. Order of addition is order of output.
 * Not really worth much as it just equates to changing the label.
 * 
 * Parameters:
 *  item - another tag object or a string (html or otherwise)
 * 
 * Returns: n/a
 */
bbop.html.button.prototype.add_to = function(item){
    this._button_stack.add_to(item);
};

/*
 * Function: empty
 * 
 * Remove all content between the tags. This equates to removing the
 * label.
 * 
 * Parameters: n/a
 * 
 * Returns: n/a
 */
bbop.html.button.prototype.empty = function(){
    this._button_stack.empty();
};

/*
 * Function: get_id
 * 
 * Return the id if extant, null otherwise.
 * 
 * Parameters: n/a
 * 
 * Returns: string or null
 */
bbop.html.button.prototype.get_id = function(){
    return this._button_stack.get_id();
};

/*
 * Namespace: bbop.html.span
 * 
 * Constructor: span
 * 
 * Create a span object.
 * Fun for calling live bits after the fact.
 * 
 * Parameters:
 *  in_label - label
 *  in_attrs - *[optional]* the typical attributes to add
 * 
 * Returns:
 *  bbop.html.span object
 */
bbop.html.span = function(in_label, in_attrs){
    this._is_a = 'bbop.html.span';
    
    // Arg check--attrs should be defined as something.
    this._attrs = in_attrs || {};

    // Internal stack is just the top-level span.
    this._span_stack = new bbop.html.tag('span', this._attrs, in_label);
};

/*
 * Function: to_string
 * 
 * Convert a span object into a html-ized string.
 * 
 * Parameters: n/a
 * 
 * Returns:
 *  string
 */
bbop.html.span.prototype.to_string = function(){
    return this._span_stack.to_string();
};

/*
 * Function: add_to
 * 
 * Add content between the tags. Order of addition is order of output.
 * Not really worth much as it just equates to changing the label.
 * 
 * Parameters:
 *  item - another tag object or a string (html or otherwise)
 * 
 * Returns: n/a
 */
bbop.html.span.prototype.add_to = function(item){
    this._span_stack.add_to(item);
};

/*
 * Function: empty
 * 
 * Remove all content between the tags. This equates to removing the
 * label.
 * 
 * Parameters: n/a
 * 
 * Returns: n/a
 */
bbop.html.span.prototype.empty = function(){
    this._span_stack.empty();
};

/*
 * Function: get_id
 * 
 * Return the id if extant, null otherwise.
 * 
 * Parameters: n/a
 * 
 * Returns: string or null
 */
bbop.html.span.prototype.get_id = function(){
    return this._span_stack.get_id();
};
/* 
 * Package: collapsible.js
 * 
 * Namespace: bbop.html.collapsible
 * 
 * Implement the Bootstrap 3 collapse JS widget.
 * http://getbootstrap.com/javascript/#collapse
 * 
 * See also:
 *  <bbop.html>
 */

// Module and namespace checking.
if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.html == "undefined" ){ bbop.html = {}; }

/*
 * Namespace: bbop.html.collapsible
 * 
 * Constructor: collapsible
 * 
 * Create the a frame for the functional part of a jQuery collapsible
 * structure.
 * 
 * :Input:
 * : [[title, string/*.to_string()], ...]
 * :
 * :Output:
 * :<div class="panel-group" id="accordion">
 * : <div class="panel panel-default">
 * :  <div class="panel-heading">
 * :   <h4 class="panel-title">
 * :    <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne">
 * :     ...
 * :    </a>
 * :   </h4>
 * :  </div>
 * :  <div id="collapseOne" class="panel-collapse collapse in">
 * :   <div class="panel-body">
 * :    ...
 * :   </div>
 * :  </div>
 * : </div>
 * : ...
 * 
 * Parameters:
 *  in_list - collapsible frame headers: [[title, string/*.to_string()], ...]
 *  attrs - *[serially optional]* attributes to apply to the new top-level div
 * 
 * Returns:
 *  bbop.html.collapsible object
 * 
 * Also see: <tag>
 */
bbop.html.collapsible = function(in_list, attrs){
    this._is_a = 'bbop.html.collapsible';

    // Arg check--attrs should be defined as something.
    this._attrs = attrs || {};

    // We must add 'panel-group' to the class list.
    if( this._attrs['class'] ){
	this._attrs['class'] = this._attrs['class'] + ' panel-group';
    }else{
	this._attrs['class'] = 'panel-group';
    }

    // An id is necessary, and needs to be generated up front for
    // reference.
    this._cid = null;
    if( ! this._attrs['id'] ){
	this._attrs['id'] = 'gen_id-bbop-html-clps-' + bbop.core.randomness(20);
    }
    this._cid = this._attrs['id'];

    // Internal stack always starts with a div.
    this._div_stack = new bbop.html.tag('div', this._attrs);

    this._section_id_to_content_id = {};

    // Iterate over the incoming argument list.
    var collapsible_this = this;
    bbop.core.each(in_list, function(item){
		       var sect_title = item[0];
		       var content = item[1];
		       collapsible_this.add_to(sect_title, content);
		   });
};

/*
 * Function: to_string
 * 
 * Convert the collapsible object into a html-ized string.
 * 
 * Parameters: n/a
 * 
 * Returns:
 *  string
 */
bbop.html.collapsible.prototype.to_string = function(){
    return this._div_stack.to_string();
};

/*
 * Function: add_to
 * 
 * Add a contect section to the collapsible.
 * 
 * Parameters:
 *  section_info - a string or a hash with 'id', 'label', and 'description'
 *  content_blob - string or bbop.html object to put in a section
 * 
 * Returns: n/a
 */
bbop.html.collapsible.prototype.add_to = function(section_info,
						  content_blob){
	
    // If section_info isn't an object, assume it is a string and
    // use it for everything.
    var section_id = null;
    var section_label = null;
    var section_desc = null;
    if(typeof section_info != 'object' ){ // is a string
	section_id = section_info;
	section_label = section_info;
    }else{
	if( section_info['id'] ){ section_id = section_info['id']; }
	if( section_info['label'] ){ section_label = section_info['label']; }
	if( section_info['description'] ){
	    section_desc = section_info['description'];
	}
    }

    // Section ID and bookkeeping.
    var coll_id = 'collapsible-' + section_id + '-' + bbop.core.randomness(20);
    var cont_id = 'content-' + section_id + '-' + bbop.core.randomness(20);
    this._section_id_to_content_id[section_id] = cont_id;    

    // Inner-most header structure: label.
    //    <a data-toggle="collapse" data-parent="#this._cid" href="#cont_id">
    var title_a_attrs = {
    	'data-toggle': 'collapse',
    	'data-parent': '#' + this._cid,
    	'href': '#' + coll_id
    };
    // Cannot be null in assembly.
    if( section_desc ){	title_a_attrs['title'] = section_desc; }
    var title_a = new bbop.html.tag('a', title_a_attrs, section_label);
    
    //   <h4 class="panel-title">
    var h4_attrs = {
    	'class': 'panel-title'
    };
    var h4 = new bbop.html.tag('h4', h4_attrs, title_a);

    // Complete the panel heading.
    //  <div class="panel-heading">
    var divh_attrs = {
    	'class': 'panel-heading'
    };
    var divh = new bbop.html.tag('div', divh_attrs, h4);
    
    // Add the panel body.
    //    <div class="panel-body">
    var body_attrs = {
    	'class': 'panel-body',
	'style': 'overflow-x: auto;', // emergency overflow scrolling
    	'id': cont_id
    };
    var body = new bbop.html.tag('div', body_attrs, content_blob);

    // Add the collapsing frame around the panel body.
    //  <div id="collapseOne" class="panel-collapse collapse in">
    var divb_attrs = {
    	'class': 'panel-collapse collapse',
    	'id': coll_id
    };
    var divb = new bbop.html.tag('div', divb_attrs, body);

    // Add both to the local panel container.
    // <div class="panel panel-default">
    var divp_attrs = {
    	'class': 'panel panel-default'
    };
    var divp = new bbop.html.tag('div', divp_attrs, [divh, divb]);
    
    //
    this._div_stack.add_to(divp);
};

/*
 * Function: empty
 * 
 * Empty all sections from the collapsible.
 * 
 * Parameters: n/a
 * 
 * Returns: n/a
 */
bbop.html.collapsible.prototype.empty = function(){
    this._div_stack = new bbop.html.tag('div', this._attrs);
    this._section_id_to_content_id = {};
};

/*
 * Function: get_id
 * 
 * Return the id if extant, null otherwise.
 * 
 * Parameters: n/a
 * 
 * Returns: string or null
 */
bbop.html.collapsible.prototype.get_id = function(){
    return this._div_stack.get_id();
};

/*
 * Function: get_section_id
 * 
 * Get the "real" section id by way of the "convenience" section id?
 * 
 * Parameters:
 *  sect_id - TODO ???
 * 
 * Returns: TODO ???
 */
bbop.html.collapsible.prototype.get_section_id = function(sect_id){
	return this._section_id_to_content_id[sect_id];    
};
/* 
 * Package: handler.js
 * 
 * Namespace: bbop.handler
 * 
 * This package contains a "useable", but utterly worthless reference
 * implementation of a handler.
 */

// Module and namespace checking.
if ( typeof bbop == "undefined" ){ var bbop = {}; }

/*
 * Constructor: handler
 *
 * Partial version for this library; revision (major/minor version numbers)
 * information.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  n/a
 */
bbop.handler = function(){
    this._is_a = 'bbop.handler';
};

/*
 * Function: url
 * 
 * Return a url string.
 * 
 * Arguments:
 *  data - the incoming thing to be handled
 *  name - the field name to be processed
 *  context - *[optional]* a string to add extra context to the call
 *  fallback - *[optional]* a fallback function to call in case nothing is found
 * 
 * Returns:
 *  null
 */
bbop.handler.prototype.dispatch = function(data, name, context, fallback){
    return null;
};
/* 
 * Package: linker.js
 * 
 * Namespace: bbop.linker
 * 
 * This package contains a "useable", but utterly worthless reference
 * implementation of a linker.
 */

// Module and namespace checking.
if ( typeof bbop == "undefined" ){ var bbop = {}; }

/*
 * Constructor: linker
 *
 * Partial version for this library; revision (major/minor version numbers)
 * information.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  n/a
 */
bbop.linker = function(){
    this._is_a = 'bbop.linker';
};

/*
 * Function: url
 * 
 * Return a url string.
 * 
 * Arguments:
 *  args - id
 *  xid - *[optional]* an internal transformation id (context)
 * 
 * Returns:
 *  null -- always "fails""
 */
bbop.linker.prototype.url = function(id, xid){
    return null;
};

/*
 * Function: anchor
 * 
 * Return an html anchor string.
 * 
 * Arguments:
 *  args - id
 *  xid - *[optional]* an internal transformation id (context)
 * 
 * Returns:
 *  null -- always "fails""
 */
bbop.linker.prototype.anchor = function(id, xid){
    return null;
};
/* 
 * Package: model.js
 * 
 * Namespace: bbop.model
 * 
 * Purpose: Basic edged graph and operations.
 * 
 * NOTE: A model instance may not be the whole graph, just a
 * subgraph--this is the difference between nodes and
 * named_nodes. nodes are real things, while named_nodes are things
 * referenced by edges.
 * 
 * Check TODOs, we would like everything as linear as possible.
 * 
 * TODO: memoize everything but add_*. Functional enough that it
 * should work if we just empty the caches after every add_* op.
 * 
 * Required: bbop.core (<core.js>)
 */

// Module and namespace checking.
if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.model == "undefined" ){ bbop.model = {}; }

/*
 * Variable: default_predicate
 * 
 * The predicate we'll use when none other is defined. You can
 * probably safely ignore this if all of the edges in your graph are
 * the same.
 */
bbop.model.default_predicate = 'points_at';

///
///  Node sub-object.
///

/*
 * Namespace: bbop.model.node
 * 
 * Constructor: node
 * 
 * Contructor for a BBOP graph model node.
 * 
 * Arguments:
 *  new_id - a unique id for the node
 *  new_label - *[optional]* a user-friendly description of the node
 * 
 * Returns:
 *  bbop model node
 */
bbop.model.node = function(new_id, new_label){
    this._is_a = 'bbop.model.node';
    this._id = new_id || undefined;
    this._label = new_label || undefined;

    // Only have a real type if the constructor went properly.
    this._type = 'node';
    if( ! new_id ){
	this._type = undefined;	
    }

    this._metadata = undefined;
};

/*
 * Function: id
 *
 * Getter/setter for node id.
 *
 * Parameters: 
 *  value - *[optional]* new value for this property to take
 *
 * Returns: 
 *  string
 */
bbop.model.node.prototype.id = function(value){
    if(value) this._id = value; return this._id; };

/*
 * Function: type
 *
 * Getter/setter for node type.
 *
 * Parameters: 
 *  value - *[optional]* new value for this property to take
 *
 * Returns: 
 *  string
 */
bbop.model.node.prototype.type = function(value){
    if(value) this._type = value; return this._type; };

/*
 * Function: label
 *
 * Getter/setter for node label.
 *
 * Parameters: 
 *  value - *[optional]* new value for this property to take
 *
 * Returns: 
 *  string
 */
bbop.model.node.prototype.label = function(value){
    if(value) this._label = value; return this._label; };

/*
 * Function: metadata
 *
 * Getter/setter for node metadata.
 * 
 * The metadata value does not necessarily have to be an atomic type.
 *
 * Parameters: 
 *  value - *[optional]* new value for this property to take
 *
 * Returns: 
 *  value
 */
bbop.model.node.prototype.metadata = function(value){
    if(value) this._metadata = value; return this._metadata; };

/*
 * Function: clone
 *
 * Get a fresh new copy of the current node (using bbop.core.clone for
 * metadata object).
 *
 * Parameters:
 *  n/a
 *
 * Returns: 
 *  string
 */
bbop.model.node.prototype.clone = function(){
    var tmp_clone = new bbop.model.node(this.id());
    tmp_clone.type(this.type());
    tmp_clone.label(this.label());
    tmp_clone.metadata(bbop.core.clone(this.metadata()));
    return tmp_clone;
};


///
///  Edge sub-object.
///

/*
 * Namespace: bbop.model.edge
 * 
 * Constructor: edge
 * 
 * Contructor for a BBOP graph model edge.
 * 
 * If no predicate is given, <default_predicate> is used.
 * Predicates are currently treated as raw strings.
 * 
 * Arguments:
 *  subject - node id string or node
 *  object - node id string or node
 *  predicate - *[optional]* a user-friendly description of the node
 * 
 * Returns:
 *  bbop model edge
 */
bbop.model.edge = function(subject, object, predicate){
    this._is_a = 'bbop.model.edge';

    // Either a string or a node.
    if( ! subject ){
	this._subject_id = undefined;
    }else if( typeof subject == 'string' ){
	this._subject_id = subject;	
    }else{
	this._subject_id = subject.id();
    }
    // Either a string or a node.
    if( ! object ){
	this._object_id = undefined;
    }else if( typeof object == 'string' ){
	this._object_id = object;	
    }else{
	this._object_id = object.id();
    }
    // Predicate default or incoming.
    this._predicate_id = bbop.model.default_predicate;
    if( predicate ){
	this._predicate_id = predicate;
    }

    // Only have a real type if the constructor went properly.
    this._type = 'edge';
    if( ! subject || ! object ){
	this._type = undefined;	
    }

    //
    this._metadata = undefined;
};

/*
 * Function: subject_id
 *
 * Getter/setter for edge subject id.
 *
 * Parameters: 
 *  value - *[optional]* new value for this property to take
 *
 * Returns: 
 *  string
 */
bbop.model.edge.prototype.subject_id = function(){
    return this._subject_id; };

/*
 * Function: object_id
 *
 * Getter/setter for edge object id.
 *
 * Parameters: 
 *  value - *[optional]* new value for this property to take
 *
 * Returns: 
 *  string
 */
bbop.model.edge.prototype.object_id = function(){
    return this._object_id; };

/*
 * Function: predicate_id
 *
 * Getter/setter for edge predicate id.
 *
 * Parameters: 
 *  value - *[optional]* new value for this property to take
 *
 * Returns: 
 *  string
 */
bbop.model.edge.prototype.predicate_id = function(){
    return this._predicate_id; };

/*
 * Function: type
 *
 * Getter/setter for edge type.
 *
 * Parameters: 
 *  value - *[optional]* new value for this property to take
 *
 * Returns: 
 *  string
 */
bbop.model.edge.prototype.type = function(value){
    if(value) this._type = value; return this._type; };

/*
 * Function: metadata
 *
 * Getter/setter for edge metadata.
 *
 * The metadata value does not necessarily have to be an atomic type.
 * 
 * Parameters: 
 *  value - *[optional]* new value for this property to take
 *
 * Returns: 
 *  value
 */
bbop.model.edge.prototype.metadata = function(value){
    if(value) this._metadata = value; return this._metadata; };

/*
 * Function: clone
 *
 * Get a fresh new copy of the current edge (using bbop.core.clone for
 * metadata object).
 *
 * Parameters:
 *  n/a
 *
 * Returns: 
 *  string
 */
bbop.model.edge.prototype.clone = function(){
    var tmp_clone = new bbop.model.edge(this.subject_id(),
					this.object_id(),
					this.predicate_id());
    // Metadata kind of needs to be duped separately.
    tmp_clone.metadata(bbop.core.clone(this.metadata()));
    return tmp_clone;
};

///
///  Graph sub-object.
///

/*
 * Namespace: bbop.model.graph
 * 
 * Constructor: graph
 * 
 * Contructor for a BBOP graph model graph.
 * 
 * TODO: make compilation piecewise with every added node and edge.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  bbop model node
 */
//
bbop.model.graph = function(){
    this._is_a = 'bbop.model.graph';

    this._id = undefined;

    // A per-graph logger.
    this._logger = new bbop.logger(this._is_a);
    this._logger.DEBUG = true;
    //this._logger.DEBUG = false;
    //function ll(str){ anchor._logger.kvetch(str); }

    // For bbop.model.node and bbop.model.edge (hash not possible for
    // edges--only relation, not "real").
    this._nodes = { array: new Array, hash: {} };
    this._edges = { array: new Array };
    this._predicates = { array: new Array, hash: {} };

    // All things that are referenced by edges (which may not include
    // actual node ids--dangling links).
    this._named_nodes = { array: new Array, hash: {} };

    // Useful forthings like leaves, roots, and singletons.
    this._subjects = { array: new Array, hash: {} };
    this._objects = { array: new Array, hash: {} };     

    // Table structures for quick lookups of relations.
    //this._predicate_subject_table = {};    // [pred][sub] -> bbop.model.edge.
    //this._subject_predicate_table = {};    // [sub][pred] -> bbop.model.edge.
    //this._predicate_object_table = {};     // [pred][obj] -> sub data struct.
    //this._object_predicate_table = {};     // [obj][pred] -> sub data struct.

    // New parallel structures to for our simplified graph.
    this._so_table = {}; // true/undef
    this._os_table = {}; // true/undef
    this._sop_table = {}; // {'rel1': true, 'rel2': true}

    // Table structures for quick lookups of node properties.
    this._is_a_singleton_lookup = {}; // [nid] -> bbop.model.node.    
};


/*
 * Function: id
 *
 * Getter/setter for the graph id.
 *
 * Parameters: 
 *  value - *[optional]* new value for this property to take
 *
 * Returns: 
 *  string
 */
bbop.model.graph.prototype.id = function(value){
    if( value ) this._id = value; return this._id;
};

/*
 * Function: add_node
 *
 * Add a node to the graph.
 *
 * Parameters: 
 *  node - <node> to add to the graph
 *
 * Returns: 
 *  n/a
 */
bbop.model.graph.prototype.add_node = function(node){

    // Check for for anything funny.
    if( ! node.id() ||
	this._nodes.hash[ node.id() ] ||
	this._nodes.hash[ node.id() ] ){
	    //alert("tried to add same node: " + node.id());
	    //throw new Error("tried to add same node: " + node.id());
	}else{

	    var nid = node.id();
	    
	    // Add it to all the concerned recall data structures.
	    this._nodes.hash[ nid ] = node;
	    this._nodes.array.push(node);
	    this._named_nodes.hash[ nid ] = node;
	    this._named_nodes.array.push(node);

	    // If this does not belong to any relation so far, then it is a
	    // singleton.
	    if( ! this._subjects.hash[ nid ] && ! this._objects.hash[ nid ] ){
		this._is_a_singleton_lookup[ nid ] = true;
	    }
	}
};


/*
 * Function: add_edge
 *
 * Add an edge to the graph.
 *
 * Parameters: 
 *  edge - <edge> to add to the graph
 *
 * Returns: 
 *  n/a
 */
bbop.model.graph.prototype.add_edge = function(edge){

    //
    var sub_id = edge.subject_id();
    var obj_id = edge.object_id();
    var pred_id = edge.predicate_id();

    // Subject -> object.
    if( ! this._so_table[ sub_id ] ){ this._so_table[ sub_id ] = {}; }
    this._so_table[ sub_id ][ obj_id ] = true;
    // Object -> subject.
    if( ! this._os_table[ obj_id ] ){ this._os_table[ obj_id ] = {}; }
    this._os_table[ obj_id ][ sub_id ] = true;
    // Their relationships (defined by SOP).
    if( ! this._sop_table[ sub_id ] ){
	this._sop_table[ sub_id ] = {}; }
    if( ! this._sop_table[ sub_id ][ obj_id ] ){
	this._sop_table[ sub_id ][obj_id] = {}; }
    //this._sop_table[ sub_id ][ obj_id ][ pred_id ] = true;
    this._sop_table[ sub_id ][ obj_id ][ pred_id ] = edge;

    // If this is a new predicate add it to all of the necessary data
    // structures.
    if( ! this._predicates.hash[ pred_id ] ){
	this._predicates.hash[ pred_id ] = true; 
	this._predicates.array.push(pred_id); 
    }

    // 
    if( ! this._subjects.hash[ sub_id ] ){
	this._subjects.hash[ sub_id ] = true; 
	this._subjects.array.push(sub_id); 
	//this._subject_predicate_table[ sub_id ] = {};
    }
    if( ! this._objects.hash[ obj_id ] ){
	this._objects.hash[ obj_id ] = true; 
	this._objects.array.push(obj_id); 
	//this._object_predicate_table[ obj_id ] = {};
    }

    // Remove the edge's subject and object from the singleton table.
    if( this._is_a_singleton_lookup[ sub_id ] ){
	delete this._is_a_singleton_lookup[ sub_id ]; }
    if( this._is_a_singleton_lookup[ obj_id ] ){
	delete this._is_a_singleton_lookup[ obj_id ]; }

    // Onto the array and subject and object into named bodies.
    this._edges.array.push(edge);
    if( ! this._named_nodes.hash[ sub_id ] ){
	this._named_nodes.array.push(sub_id); }
    this._named_nodes.hash[ sub_id ] = edge;
    if( ! this._named_nodes.hash[ obj_id ] ){
	this._named_nodes.array.push(obj_id); }
    this._named_nodes.hash[ obj_id ] = edge;
};

/*
 * Function: all_nodes
 *
 * Returns an /original/ list of all added nodes.
 *
 * Parameters:
 *  n/a
 *
 * Returns: 
 *  array of nodes
 */
bbop.model.graph.prototype.all_nodes = function(){
    return this._nodes.array;
};

/*
 * Function: all_edges
 *
 * Returns an /original/ list of all added edges.
 *
 * Parameters:
 *  n/a
 *
 * Returns: 
 *  array of edges
 */
bbop.model.graph.prototype.all_edges = function(){
    return this._edges.array;
};

/*
 * Function: all_predicates
 *
 * Returns an /original/ list of all added predicates.
 *
 * Parameters:
 *  n/a
 *
 * Returns: 
 *  array of predicates (strings)
 */
bbop.model.graph.prototype.all_predicates = function(){
    return this._predicates.array;
};

/*
 * Function: all_dangling
 *
 * List all external nodes by referenced id.
 *
 * Parameters:
 *  n/a
 *
 * Returns: 
 *  array of extrnal nodes by id
 */
bbop.model.graph.prototype.all_dangling = function(){
    // Disjoint of named and extant.
    var unnamed = new Array();
    for( var named_id in this._named_nodes.hash ){
	if( ! this._nodes.hash[named_id] ){
	    unnamed.push(named_id);
	}
    }
    return unnamed;
};

/*
 * Function: is_complete
 *
 * Any bad parts in graph? Essentially, make sure that there are no
 * weird references and nothing is dangling.
 *
 * Parameters:
 * n/a
 *
 * Returns: 
 *  boolean
 */
bbop.model.graph.prototype.is_complete = function(){
    var retval = true;
    if( this.all_dangling().length > 0 ){
	retval = false;
    }
    return retval;
};

/*
 * Function: get_node
 *
 * Return a /copy/ of a node by id (not the original) if extant.
 *
 * Parameters:
 *  nid - the id of the node we're looking for
 *
 * Returns: 
 *  <bbop.model.node>
 */
bbop.model.graph.prototype.get_node = function(nid){
    var retnode = null;
    if( this._nodes.hash[ nid ] ){
	var tmp_node = this._nodes.hash[ nid ];
	retnode = tmp_node.clone();
    }
    return retnode;
};

/*
 * Function: get_edge
 *
 * Return a /copy/ of an edge by ids (not the original) if extant.
 *
 * Parameters:
 *  sub_id - the subject_id of the edge we're looking for
 *  obj_id - the object_id of the edge we're looking for
 *  pred - *[optional]* the predicate of the edge we're looking for
 *
 * Returns: 
 *  <bbop.model.edge>
 */
bbop.model.graph.prototype.get_edge = function(sub_id, obj_id, pred){	

    if( ! pred ){ pred = bbop.model.default_predicate; }

    var ret_edge = null;
    if( this._sop_table[sub_id] &&
	this._sop_table[sub_id][obj_id] &&
	this._sop_table[sub_id][obj_id][pred] ){
	    var tmp_edge = this._sop_table[sub_id][obj_id][pred];
	    ret_edge = tmp_edge.clone();
	}
    return ret_edge; 
};

/*
 * Function: get_edges
 *
 * Return all edges (copies) of given subject and object ids. Returns
 * entirely new edges.
 *
 * Parameters:
 *  sub_id - the subject_id of the edge we're looking for
 *  obj_id - the object_id of the edge we're looking for
 *
 * Returns: 
 *  list of <bbop.model.edge>
 */
bbop.model.graph.prototype.get_edges = function(sub_id, obj_id){
    var retlist = new Array();
    if( this._sop_table[sub_id] &&
	this._sop_table[sub_id][obj_id] ){
	    for( var pred in this._sop_table[sub_id][obj_id] ){
		var found_edge = this._sop_table[sub_id][obj_id][pred];
		var tmp_edge = found_edge.clone();
		retlist.push(tmp_edge);
	    }
	}		
    return retlist;
};


/*
 * Function: get_predicates
 *
 * Return all predicates of given subject and object ids.
 *
 * Parameters:
 *  sub_id - the subject_id of the edge we're looking for
 *  obj_id - the object_id of the edge we're looking for
 *
 * Returns: 
 *  list of predicate ids (as strings)
 */
bbop.model.graph.prototype.get_predicates = function(sub_id, obj_id){
    var retlist = [];
    if( this._sop_table[sub_id] &&
	this._sop_table[sub_id][obj_id] ){
	    for( var pred in this._sop_table[sub_id][obj_id] ){
		retlist.push(pred);
	    }
	}
    return retlist;
};


/*
 * Function: edges_to_nodes
 *
 * Translate an edge array into extant (node) bodies, switching on
 * either 'subject' or 'object'.
 * 
 * This will return the /original/ nodes.
 *
 * This will throw an error on any world issues that crop up.
 * 
 * Parameters: 
 *  in_edges - the edges we want the subjects or objects of
 *  target - 'subject' or 'object'
 *
 * Returns: 
 *  array of <bbop.model.node>
 */
bbop.model.graph.prototype.edges_to_nodes = function(in_edges, target){
    
    // Double check.
    if( target != 'subject' && target != 'object'){
	throw new Error('Bad target for edges to bodies.');
    }

    // 
    var results = new Array();
    for( var i = 0; i < in_edges.length; i++ ){ 
	var in_e = in_edges[i];

	// Switch between subject and object.
	var target_id = null;
	if( target == 'subject' ){
	    target_id = in_e.subject_id();
	}else{
	    target_id = in_e.object_id();
	}
	
	//
	if( target_id && this._nodes.hash[ target_id ] ){
	    results.push(this._nodes.hash[ target_id ]);
	}else{
	    throw new Error(target + ' world issue');
	}
    }
    return results;
};

/*
 * Function: is_root_node
 *
 * Roots are defined as nodes who are the subject of nothing,
 * independent of predicate.
 *
 * Parameters: 
 *  nb_id - id of the node to check
 *
 * Returns: 
 *  boolean
 */
bbop.model.graph.prototype.is_root_node = function(nb_id){
    var result = false;	
    if( this._nodes.hash[ nb_id ] &&
	! this._subjects.hash[ nb_id ] ){	    
	    result = true;
	}
    return result;
};


/*
 * Function: get_root_nodes
 *
 * Return a list of /copies/ of the root nodes.
 * 
 * BUG/TODO: Could I speed this up by my moving some of the
 * calculation into the add_node and add_edge methods? O(|#nodes|)
 * 
 * Parameters:
 *  n/a 
 *
 * Returns:
 *  array of <bbop.model.node>
 */
bbop.model.graph.prototype.get_root_nodes = function(){
    var results = new Array();
    for( var nb_id in this._nodes.hash ){
	if( this.is_root_node(nb_id) ){
	    results.push( this.get_node(nb_id).clone() );
	}
    }
    return results;
};


/*
 * Function: is_leaf_node
 *
 * Leaves are defined as nodes who are the object of nothing,
 * independent of predicate.
 * 
 * Parameters: 
 *  nb_id - id of the node to check
 *
 * Returns: 
 *  boolean
 */
bbop.model.graph.prototype.is_leaf_node = function(nb_id){

    var result = false;
    if( this._nodes.hash[ nb_id ] &&
	! this._objects.hash[ nb_id ] ){	    
	    result = true;
	}
    return result;
};

/*
 * Function: get_leaf_nodes
 *
 * Return a list of /copies/ of the leaf nodes.
 * 
 * BUG/TODO: Could I speed this up by my moving some of the
 * calculation into the add_node and add_edge methods? O(|#nodes|)
 * 
 * Parameters:
 *  n/a 
 *
 * Returns:
 *  array of <bbop.model.node>
 */
bbop.model.graph.prototype.get_leaf_nodes = function(){
    var results = new Array();
    for( var nb_id in this._nodes.hash ){
	if( this.is_leaf_node(nb_id) ){
	    results.push( this.get_node(nb_id).clone() );
	}
    }
    return results;
};

/*
 * Function: get_singleton_nodes
 *
 * Find nodes that are roots and leaves over all relations. This
 * returns the /original/ node.
 * 
 * Throws an error if there is a world issue.
 *
 * Parameters:
 *  n/a 
 *
 * Returns: 
 *  array of <bbop.model.node>
 */
bbop.model.graph.prototype.get_singleton_nodes = function(){
    // Translate array into array extant bodies.
    var singleton_array = new Array();
    for( var singleton_id in this._is_a_singleton_lookup ){
	if( this._nodes.hash[ singleton_id ] ){
	    singleton_array.push( this._nodes.hash[ singleton_id ] );
	}else{
	    throw new Error("world issue in get_singletons: "+singleton_id);
	}
    }
    return singleton_array;
};

/*
 * Function: get_parent_edges
 *
 * Return all parent edges; the /originals/. If no predicate is given,
 * use the default one.
 * 
 * TODO: it might be nice to memoize this since others depend on it.
 *
 * Parameters: 
 *  nb_id - the node to consider
 *  in_pred - *[optional]* over this predicate
 *
 * Returns: 
 *  array of <bbop.model.edge>
 */
bbop.model.graph.prototype.get_parent_edges = function(nb_id, in_pred){

    var results = new Array();

    // Get all parents, or just parents from a specific relation.
    var preds_to_use = new Array();
    if( in_pred ){
	preds_to_use.push(in_pred);
    }else{
	preds_to_use = this._predicates.array;
    }

    // Try all of our desired predicates.
    for( var j = 0; j < preds_to_use.length; j++ ){
	var pred = preds_to_use[j];

	// Scan the table for goodies; there really shouldn't be a
	// lot here.
	if( this._so_table[ nb_id ] ){		
	    for( var obj_id in this._so_table[nb_id] ){
		// If it looks like something is there, try to see
		// if there is an edge for our current pred.
		var tmp_edge = this.get_edge(nb_id, obj_id, pred);
		if( tmp_edge ){
		    results.push( tmp_edge );
		}
	    }
	}
    }
    return results;
};

/*
 * Function: get_parent_nodes
 *
 * Return all parent nodes; the /originals/. If no predicate is given,
 * use the default one.
 * 
 * Parameters: 
 *  nb_id - the node to consider
 *  in_pred - *[optional]* over this predicate
 *
 * Returns: 
 *  array of <bbop.model.node>
 */
bbop.model.graph.prototype.get_parent_nodes = function(nb_id, in_pred){

    var results = new Array();
    var edges = this.get_parent_edges(nb_id, in_pred);
    for( var i = 0; i < edges.length; i++ ){
	// Make sure that any found edges are in our
	// world.
	var obj_id = edges[i].object_id();
	var tmp_node = this.get_node(obj_id);
	if( tmp_node ){
	    results.push( this.get_node(obj_id) );
	}
    }
    return results;
};

/*
 * Function: get_child_nodes
 *
 * Return all child nodes; the /originals/. If no predicate is given,
 * use the default one.
 * 
 * Parameters: 
 *  nb_id - the node to consider
 *  in_pred - *[optional]* over this predicate
 *
 * Returns: 
 *  array of <bbop.model.node>
 */
bbop.model.graph.prototype.get_child_nodes = function(nb_id, in_pred){

    var results = new Array();

    // Get all children, or just children from a specific relation.
    var preds_to_use = new Array();
    if( in_pred ){
	preds_to_use.push(in_pred);
    }else{
	preds_to_use = this._predicates.array;
    }

    // Try all of our desired predicates.
    for( var j = 0; j < preds_to_use.length; j++ ){
	var pred = preds_to_use[j];

	// Scan the table for goodies; there really shouldn't be a
	// lot here.
	if( this._os_table[ nb_id ] ){		
	    for( var sub_id in this._os_table[nb_id] ){
		// If it looks like something is there, try to see
		// if there is an edge for our current pred.
		if( this.get_edge(sub_id, nb_id, pred) ){
		    // Make sure that any found edges are in our
		    // world.
		    var tmp_node = this.get_node(sub_id);
		    if( tmp_node ){
			results.push( this.get_node(sub_id) );
		    }
		}
	    }
	}
    }
    return results;
};

/*
 * Function: get_ancestor_subgraph
 *
 * Return new ancestors subgraph. Single id or id list as first
 * argument. Predicate string/id as optional second.
 *
 * Parameters: 
 *  nb_id_or_list - the node id(s) to consider
 *  pid - *[optional]* over this predicate
 *
 * Returns: 
 *  <bbop.model.graph>
 */
bbop.model.graph.prototype.get_ancestor_subgraph = function(nb_id_or_list, pid){

    // Shared data structure to trim multiple paths.
    // Nodes: color to get through the graph quickly and w/o cycles.
    var seen_node_hash = {};
    // Edges: just listed--hashing would be essentially the same
    // as a call to graph.add_edge (I think--benchmark?).
    var seen_edge_list = [];
    var anchor = this;

    // Define recursive ascent.
    function rec_up(nid){

	//print('rec_up on: ' + nid);

    	var results = new Array();
    	var new_parent_edges = anchor.get_parent_edges(nid, pid);

	// Capture edge list for later adding.
	for( var e = 0; e < new_parent_edges.length; e++ ){
	    seen_edge_list.push(new_parent_edges[e]);
	}

	// Pull extant nodes from edges. NOTE: This is a retread
	// of what happens in get_parent_nodes to avoid another
	// call to get_parent_edges (as all this is now
	// implemented).
	var new_parents = new Array();
	for( var n = 0; n < new_parent_edges.length; n++ ){
	    // Make sure that any found edges are in our
	    // world.
	    var obj_id = new_parent_edges[n].object_id();
	    var temp_node = anchor.get_node(obj_id);
	    if( temp_node ){
		new_parents.push( temp_node );
	    }
	}

	// Make sure we're in there too.
	var tmp_node = anchor.get_node(nid);
	if( tmp_node ){
	    new_parents.push( tmp_node );
	}

	// Recur on unseen things and mark the current as seen.
    	if( new_parents.length != 0 ){
    	    for( var i = 0; i < new_parents.length; i++ ){
    		// Only do things we haven't ever seen before.
    		var new_anc = new_parents[i];
    		var new_anc_id = new_anc.id();
    		if( ! seen_node_hash[ new_anc_id ] ){
    		    seen_node_hash[ new_anc_id ] = new_anc;
    		    rec_up(new_anc_id);	
    		}
    	    }
    	}
    	return results;
    }
    
    // Recursive call and collect data from search. Make multiple
    // ids possible.
    //if( nb_id_or_list.length && nb_id_or_list.index ){
    if( bbop.core.is_array(nb_id_or_list) ){ // verify listy-ness
	for( var l = 0; l < nb_id_or_list.length; l++ ){	    
	    rec_up(nb_id_or_list[l]);
	}
    }else{
    	rec_up(nb_id_or_list);
    }
    
    // Build new graph using data.
    var new_graph = new bbop.model.graph();
    for( var k in seen_node_hash ){
	new_graph.add_node(seen_node_hash[k]);
    }
    for( var x = 0; x < seen_edge_list.length; x++ ){	    
	new_graph.add_edge(seen_edge_list[x]);
    }

    return new_graph;
};

/*
 * Function: merge_in
 * 
 * Add a graph to the current graph, without sharing any of the merged
 * in graph's structure.
 * 
 * TODO: a work in progress 'type' not currently imported (just as
 * not exported)
 * 
 * Parameters:
 *  bbop.model.graph
 * 
 * Returns:
 *  true; side-effects: more graph
 */
bbop.model.graph.prototype.merge_in = function(in_graph){

    var anchor = this;

    // First, load nodes; scrape out what we can.
    bbop.core.each(in_graph.all_nodes(),
		   function(in_node){
		       var new_node = in_node.clone();
		       anchor.add_node(new_node);
		   });

    // Now try to load edges; scrape out what we can.
    bbop.core.each(in_graph.all_edges(),
		   function(in_edge){
		       var new_edge = in_edge.clone();
		       anchor.add_edge(new_edge);
		   });

    return true;
};

/*
 * Function: load_json
 * 
 * Load the graph from the specified JSON object (not string).
 * 
 * TODO: a work in progress 'type' not currently imported (just as
 * not exported)
 * 
 * Parameters:
 *  JSON object
 * 
 * Returns:
 *  true; side-effects: creates the graph internally
 */
bbop.model.graph.prototype.load_json = function(json_object){

    var anchor = this;

    // First, load nodes; scrape out what we can.
    if( json_object.nodes ){
	bbop.core.each(json_object.nodes,
		       function(node_raw){
			   var nid = node_raw.id;
			   var nlabel = node_raw.lbl;
			   var n = new bbop.model.node(nid, nlabel);
			   if(node_raw.meta){ n.metadata(node_raw.meta); }
			   anchor.add_node(n);
		       });
    }

    // Now try to load edges; scrape out what we can.
    if( json_object.edges ){
	bbop.core.each(json_object.edges,
		       function(edge_raw){
			   var e = new bbop.model.edge(edge_raw.sub,
						       edge_raw.obj,
						       edge_raw.pred);
			   // Copy out meta.
			   if(edge_raw.meta){ e.metadata(edge_raw.meta); } 
			   
			   anchor.add_edge(e);
		      });
    }

    return true;
};

/*
 * Function: to_json
 * 
 * Dump out the graph into a JSON-able object.
 * 
 * TODO: a work in progress; 'type' not currently exported (just as
 * not imported)
 * 
 * Parameters:
 *  n/a
 * 
 * Returns:
 *  An object that can be converted to a JSON string by dumping.
 */
bbop.model.graph.prototype.to_json = function(){

    var anchor = this;

    // Copy
    var nset = [];
    bbop.core.each(anchor.all_nodes(),
		   function(raw_node){

		       var node = bbop.core.clone(raw_node);
		       var ncopy = {};

		       var nid = node.id();
		       if(nid){ ncopy['id'] = nid; }

		       // var nt = node.type();
		       // if(nt){ ncopy['type'] = nt; }

		       var nlabel = node.label();
		       if(nlabel){ ncopy['lbl'] = nlabel; }

		       var nmeta = node.metadata();
		       if(nmeta){ ncopy['meta'] = nmeta; }

		       nset.push(ncopy);
		   });

    var eset = [];
    var ecopy = bbop.core.clone(anchor._edges['array']);
    bbop.core.each(anchor.all_edges(),
		   function(node){
		       var ecopy = {};

		       var s = node.subject_id();
		       if(s){ ecopy['sub'] = s; }

		       var o = node.object_id();
		       if(o){ ecopy['obj'] = o; }

		       var p = node.predicate_id();
		       if(p){ ecopy['pred'] = p; }

		       eset.push(ecopy);
		   });

    // New exportable.
    var ret_obj = {'nodes': nset, 'edges': eset};

    return ret_obj;
};
/* 
 * Package: tree.js
 * 
 * Namespace: bbop.model.tree
 * 
 * Purpose: Extend <bbop.model> in <model.js> to be handy for a (phylo)tree.
 * 
 * TODO: /Much/ better documentation. I have no idea what's going on
 * in there anymore...
 * 
 * TODO: Subtree calculation during bracket_down.
 */

// Module and namespace checking.
if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.model == "undefined" ){ bbop.model = {}; }
if ( typeof bbop.model.tree == "undefined" ){ bbop.model.tree = {}; }

/*
 * Namespace: bbop.model.tree.node
 * 
 * Constructor: node
 * 
 * Same as parent, but just takes id in constructor.
 * 
 * Arguments:
 *  new_id - a unique id for the node
 */
bbop.model.tree.node = function(new_id){
    bbop.model.node.call(this, new_id);
    this._is_a = 'bbop.model.tree.node';
};
bbop.core.extend(bbop.model.tree.node, bbop.model.node);

/*
 * Namespace: bbop.model.tree.edge
 * 
 * Constructor: edge
 * 
 * Same as parent class, but optionally adds distance as an argument.
 */
bbop.model.tree.edge = function(parent, child, distance){
    bbop.model.edge.call(this, child, parent, '');
    this._is_a = 'bbop.model.tree.edge';
    this._distance = distance || 0.0;
};
bbop.core.extend(bbop.model.tree.edge, bbop.model.edge);

/*
 * Function: distance
 *
 * Return an edge's "distance".
 *
 * Parameters:
 *  value - *[optional]* new number for this property to take
 *
 * Returns: 
 *  number
 */
bbop.model.tree.edge.prototype.distance = function(d){
    if(d){ this._distance = d; }
    return this._distance;
};

/*
 * Function: clone
 *
 * Make sure that clone gets distance as well.
 *
 * Parameters: 
 *  n/a
 *
 * Returns: 
 *  <bbop.model.tree.edge>
 */
bbop.model.tree.edge.prototype.clone = function(){
    var tmp_clone = new bbop.model.tree.edge(this.object_id(),
					     this.subject_id(),
					     this.distance());
    tmp_clone.metadata(bbop.core.clone(this.metadata()));
    return tmp_clone;
};

/*
 * Namespace: bbop.model.tree.graph
 * 
 * Constructor: graph
 * 
 * Same as parent.
 * Needs some more functionality...
 */
bbop.model.tree.graph = function(){
    bbop.model.graph.call(this);
    this._is_a = 'bbop.model.tree.graph';

    // Useful for making sure that certain recursive functions keep
    // the desired notion of "this"ness.
    var anchor = this;

    /*
     * Function: default_sort
     *
     * The default comparator function for ordering the
     * brackets. Alphabetical down.
     * 
     * Parameters: 
     *  a - a bracket item
     *  b - a bracket item
     *
     * Returns: 
     *  string
     */
    this.default_sort = function(a, b){
	var sort_val = 0;
	if( a.id < b.id ){
	    sort_val = - 1;
	}else if( a.id > b.id ){
	    sort_val = 1;
	}
	//_kvetch('sort: ' + a.id + ' <?> ' + b.id + ' = ' + sort_val);
	return sort_val;
    };

    // Get information on kids, relations, and distances working our
    // way up from the leaves.
    var max_dist = 0.0;
    var all_dists_parent = {};
    var all_dists_child = {};
    var node_list = new Array();
    var node_hash = {};
    var edge_list = new Array();
    var edge_hash = {};
    function info_up(node_id){
	
	var nid = node_id;
	//_kvetch("info_up: working on: " + nid);

	// Node bookkeeping.
	if( ! node_hash[nid] ){
	    node_hash[nid] = true;
	    node_list.push(nid);
	}

	// Can only have at most one parent.
	var node_parent = anchor.get_parent_nodes(nid);
	if( node_parent && node_parent.length ){
	    node_parent = node_parent[0];
	    var pid = node_parent.id();

	    // Edge bookkeeping.
	    var edge_uid = pid + '_!muNge!_' + node_id;
	    if( ! edge_hash[edge_uid] ){
		edge_hash[edge_uid] = true;
		edge_list.push([pid, node_id]);
		//_kvetch('info_up: indexing: ' + edge_uid);
	    }

	    // Add new data to globals.
	    //_kvetch(" info_up: seems to have parent: " + pid);
	    if( ! all_dists_parent[pid]){
		all_dists_parent[pid] = {};
	    }
	    if( ! all_dists_child[nid]){
		all_dists_child[nid] = {};
	    }

	    if( ! all_dists_parent[pid][nid] ){
		// 
		var dist = anchor.get_edge(nid,pid).distance();
		all_dists_parent[pid][nid] = dist;
		all_dists_child[nid][pid] = dist;
		// Look a little for max.
		if( dist > max_dist ){
		    max_dist = dist;
		}
	    }

	    // Get any data you can from your kids.
	    for( var k_id in all_dists_parent[nid] ){

		var increment = all_dists_parent[pid][nid] +
		    all_dists_parent[nid][k_id];
		all_dists_parent[pid][k_id] = increment;
		all_dists_child[k_id][pid] = increment;

		// Look a little for max.
		if( increment > max_dist ){
		    max_dist = increment;
		}
	    }

	    // Recur on parent.
	    info_up(pid);
	}
    }

    // Recursive comb down (give partitioned ordering).
    // A bracket looks like: "[{id:a, brackets: [...]}, ...]".
    // TODO: subtree calculation during.
    var brackets = new Array();
    var max_depth = 0;
    function bracket_down(in_node, lvl, parent_node_id){
	    
	// Bootstrap lvl to 1.
	if( ! lvl ){ lvl = 1; }
	if( ! parent_node_id ){ parent_node_id = null; }

	var in_node_id = in_node.id();
	//_kvetch(' bracket_down: ' + in_node_id);

	// 
	var child_bracket = new Array();
	var child_nodes = anchor.get_child_nodes(in_node_id);
	for( var cb = 0; cb < child_nodes.length; cb++ ){
	    var child_node = child_nodes[cb];
	    var child_node_id = child_node.id();
	    //_kvetch('  bracket_down: pushing: ' + child_node_id);
	    child_bracket.push(bracket_down(child_node, lvl + 1, in_node_id));
	}

	// Sort the children.
	child_bracket.sort(anchor.default_sort);

	// Grab max depth.
	if( lvl > max_depth ){ max_depth = lvl;	}

	//
	//_kvetch(' bracket_down: found kids: ' + child_bracket.length);
	return {
	    id: in_node_id,
	    routing_node: false,
	    level: lvl,
	    parent_id: parent_node_id,
	    brackets: child_bracket
	};
    }

    // Return a layout that can be trivially rendered
    // by...something...
    var max_width = 0;
    var cohort_list = new Array(); // will reinit

    /*
     * Function: layout
     *
     * With the current graph, produce a usable layout object.
     * 
     * TODO: layout should take bracket ordering func
     *
     * Parameters:
     *  n/a
     *
     * Returns: 
     *  a rather complicated layout object
     */
    this.layout = function (){

	// Refresh scope on new layout call.
	brackets = new Array();
	node_list = new Array();
	node_hash = {};
	edge_list = new Array();
	edge_hash = {};
	cohort_list = new Array(); // token--now also reset and sized below

	// Pass one:
	// Collect all of our bracketing information, also order the
	// brackets to some function.
	var base_nodes = anchor.get_root_nodes();
	for( var bb = 0; bb < base_nodes.length; bb++ ){
	    //_kvetch('bracket_down: start: ' + base_nodes[bb].id());
	    brackets.push(bracket_down(base_nodes[bb]));
	}
	// The children are ordered--make the top-level one ordered as
	// well.
	brackets.sort(anchor.default_sort);

	// Pass one:
	// Essentially walk the brackets, find brackets that end early
	// (above max_depth) and add routing nodes down.
	function dangle_routing(in_item){
	    if( in_item.level < max_depth ){
		in_item.brackets.push({id: in_item.id,
				       routing_node: true,
				       level: in_item.level + 1,
				       parent_id: in_item.id,
				       brackets: []
				      });
		dangle_routing(in_item.brackets[0]);
	    }
	    return in_item;
	}
	function add_routing(in_brackets){

	    //
	    for( var i = 0; i < in_brackets.length; i++ ){
		var item = in_brackets[i];

		//
		if( item.brackets.length == 0 && item.level < max_depth ){
		    //_kvetch(' add_routing: dangle: ' + item.id);
		    dangle_routing(item);
		}else if( item.brackets.length != 0 ){
		    //_kvetch(' add_routing: descend: ' + item.id);
		    add_routing(item.brackets);
		}
	    }
	}
	add_routing(brackets);

	// Pass three:
	// Collect global cohort information into a matrix (cohort_list).
	cohort_list = new Array(max_depth);
	for( var cli = 0; cli < cohort_list.length; cli++ ){
	    cohort_list[cli] = new Array();
	}
	// Walk down and stack up.
	function order_cohort(in_brackets){	    
	    // Push into global cohort list list.
	    for( var i = 0; i < in_brackets.length; i++ ){
		var bracket_item = in_brackets[i];
		//
		//_kvetch(' order_cohort: i: ' + i);
		//_kvetch(' order_cohort: lvl: ' + bracket_item.level);
		cohort_list[bracket_item.level - 1].push(bracket_item);
		// Drill down.
		if( bracket_item.brackets.length > 0 ){
		    //_kvetch(' order_cohort: down: ' +
		    //        bracket_item.brackets.length);
		    order_cohort(bracket_item.brackets);
		}
	    }
	}
	order_cohort(brackets);

	// Gather distance info up from leaves.
	var base_info_nodes = anchor.get_leaf_nodes();
	max_width = base_info_nodes.length; // by def, leaves are widest
	for( var bi = 0; bi < base_info_nodes.length; bi++ ){
	    info_up(base_info_nodes[bi].id());
	}

	///
	/// Decide relative y positions by walking backwards through
	/// the cohorts.
	///


	// Walk backwards through the cohorts to find a base Y position. for
	// the final cohort.
	var position_y = {};
	var final_cohort = cohort_list[(max_depth - 1)];
	//_kvetch('look at final cohort: ' + (max_depth - 1));
	for( var j = 0; j < final_cohort.length; j++ ){
	    var f_item = final_cohort[j];
	    //var local_shift = j + 1.0; // correct, but shifts too far down
	    var local_shift = j + 0.0;
	    position_y[f_item.id] = local_shift;
	    //_kvetch('position_y: ' + f_item.id + ', ' + local_shift);
	}
	// Walk backwards through the remaining cohorts to find the best Y
	// positions.
	for( var i = cohort_list.length - 1; i > 0; i-- ){
	    //
	    var cohort = cohort_list[i - 1];
	    //_kvetch('look at cohort: ' + (i - 1));
	    for( var k = 0; k < cohort.length; k++ ){
		var item = cohort[k];

		// Deeper placements always take precedence.
		if( position_y[item.id] != undefined ){
		    //_kvetch('position_y (old): '+ item.id);
		}else{

		    // If you have one parent, they have the same Y as you.
		    // This generalizes to: the parent has the average Y of
		    // it's children. This is easy then, once we
		    // start, but how to get the initial leaf
		    // placement? Get item's children and take their
		    // average (by definition, they must already be in
		    // the placed list (even if it was just a routing
		    // node)).
		    var c_nodes = anchor.get_child_nodes(item.id);
		    var position_acc = 0.0;
		    for( var ci = 0; ci < c_nodes.length; ci++ ){
			var node = c_nodes[ci];
			position_acc = position_acc + position_y[node.id()];
		    }
		    // _kvetch(' position_acc: ' + position_acc);
		    // _kvetch(' c_nodes: ' + c_nodes);
		    // _kvetch(' c_nodes.length: ' + c_nodes.length);
		    var avg = position_acc / (c_nodes.length * 1.0);
		    position_y[item.id] = avg;
		    //_kvetch('position_y (new): '+ item.id +', '+ avg);
		}
	    }
	}
 
	//
	var x_offset = 0.0;
	var position_x = {};
	var roots = anchor.get_root_nodes();
	for( var r = 0; r < roots.length; r++ ){

	    var root_id = roots[r].id();
	    position_x[root_id] = x_offset;
	    //_kvetch('position_x:: ' + root_id + ', ' + position_x[root_id]);
    
	    if( item.routing_node == false ){
		// Get kids and their x distance (for placement).
		for( var nid in all_dists_parent[root_id] ){
		    var dist = all_dists_parent[root_id][nid] + x_offset;
		    position_x[nid] = dist;
		    //_kvetch('position_x:: ' + nid + ', ' + dist);
		}
	    }
	}

	//
	return {
	    parent_distances: all_dists_parent,
	    child_distances: all_dists_child,
	    max_distance: max_dist,
	    max_depth: max_depth,
	    max_width: max_width,
	    cohorts: cohort_list,
	    //routing: routing_list,
	    brackets: brackets,
	    node_list: node_list,
	    edge_list: edge_list,
	    position_x: position_x,
	    position_y: position_y
	};
    };

    /*
     * Function: dump_cohorts
     *
     * Dump the cohorts; for debugging?
     *
     * Parameters:
     *  n/a
     *
     * Returns: 
     *  n/a
     */
    this.dump_cohorts = function(){
    	for( var i = 0; i < cohort_list.length; i++ ){
    	    for( var j = 0; j < cohort_list[i].length; j++ ){
    		var item = cohort_list[i][j];
    		//_kvetch(item.id + ' ' + i +':'+ j + ', ' + item.routing_node);
    	    }
    	}
    };

    /*
     * Function: dump_dist
     *
     * Dump distances; for debugging?
     *
     * Parameters: 
     *  in_arg - string; 'child'/'parent'?
     *
     * Returns: 
     *  n/a
     */
    this.dump_dist = function(in_arg){

	//_kvetch(' in ');

	// Argument selection.
	var dists = all_dists_parent;
	if( in_arg == "child" ){
	    dists = all_dists_child;
	}

	// Dump selected dist.
	for( var n_id in dists ){
	    for( var k_id in dists[n_id] ){
		//_kvetch(n_id +' : '+ k_id +' => '+ dists[n_id][k_id]);
	    }
	}
    };

    /*
     * Function: dump_brackets
     *
     * Dump brackets; for debugging?
     *
     * Parameters: 
     *  brack - *[optional]* ???
     *
     * Returns: 
     *  n/a
     */
    this.dump_brackets = function(brack){

	// Bootstrap if just starting.
	if( ! brack ){ brack = brackets; }
	//if( ! lvl ){ lvl = 1; }

	// Printer.
	for( var i = 0; i < brack.length; i++ ){

	    var pid = '(null)';
	    if( brack[i].parent_id ){ pid = brack[i].parent_id; }

	    // _kvetch('id: ' + brack[i].id +
	    // 		     ', parent: ' + pid +
	    // 		     ', level: ' + brack[i].level);
	    this.dump_brackets(brack[i].brackets);
	}
    };

};
bbop.core.extend(bbop.model.tree.graph, bbop.model.graph);
// Overload add_node to add label information to new object.
/* 
 * Package: bracket.js
 * 
 * Namespace: bbop.model.bracket.graph
 * 
 * Purpose: An extension of <bbop.model.graph> to produce a bracketed
 * layout (like the neighborhood view in AmiGO 1.8).
 * 
 * TODO: A work in progress...
 */

// Module and namespace checking.
if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.model == "undefined" ){ bbop.model = {}; }
if ( typeof bbop.model.bracket == "undefined" ){ bbop.model.bracket = {}; }
//if ( typeof bbop.model.bracket.graph == "undefined" ){ bbop.model.bracket.graph = {}; }

/*
 * Namespace: bbop.model.bracket.graph
 * 
 * Constructor: bracket
 * 
 * Extension of <bbop.model.graph>
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  this
 */
bbop.model.bracket.graph = function(){
    bbop.model.graph.call(this);
    this._is_a = 'bbop.model.bracket.graph';

    var anchor = this;
    var each = bbop.core.each;
    anchor._logger.DEBUG = true;
    function ll(str){ anchor._logger.kvetch(str); }

    /*
     * Function: bracket_layout
     *
     * Largely borrowed from ChewableGraph.pm from the perl section on
     * AmiGO 2.
     * 
     * Produces a simple bracketed layout based on the maximum
     * distance from the node-of-interest to all other nodes. It also
     * includes direct children as the last row. Useful in some layout
     * contexts.
     *
     * Any node in a properly made graph should be fine, but for the
     * usual end case, see <rich_bracket_layout>.
     * 
     * Parameters: 
     *  term_acc - node of interest
     *
     * Returns: 
     *  list of lists or id strings [[id1, id2], ...]
     */
    this.bracket_layout = function(term_acc){
	
	// // This is the actual path climbing agent.
	// function max_info_climber(in_curr_term, in_curr_term_dist,
	// 			  in_max_hist, in_enc_hist){

	//     // We either bootstrap (first run) or pull them in.
	//     var curr_term = in_curr_term || term_acc;
	//     var curr_term_distance = in_curr_term_dist || 0;
	//     var max_hist = in_max_hist || {};
	//     var encounter_hist = in_enc_hist || {};

	//     // ll('looking at: ' + curr_term + ' at ' + curr_term_distance);

	//     // Only recur if our encounter history sez that either
	//     // this node is new or if we have a higher distance count
	//     // (in which case we add it and continue on our merry
	//     // way).
	//     if( ! bbop.core.is_defined(encounter_hist[curr_term]) ){
	// 	// ll(curr_term + ' is a new encounter at distance ' +
	// 	//    curr_term_distance);

	// 	// Note that we have encountered this node before.
	// 	encounter_hist[curr_term] = 1;

	// 	// Our first distance is the current one!
	// 	max_hist[curr_term] = curr_term_distance;

	// 	// Increment our distance.
	// 	curr_term_distance++;

	// 	// Take a look at all the parents of our current term.
	// 	each(anchor.get_parent_nodes(curr_term),
	// 	     function(p){
	// 		 // Since this is a new node encounter, let's
	// 		 // see what else is out there to discover.
	// 		 max_info_climber(p.id(), curr_term_distance,
	// 				  max_hist, encounter_hist);
	// 	     });

	//     }else if( encounter_hist[curr_term] ){
	// 	// ll(curr_term + ' has been seen before');

	// 	// If we're seeing this node again, but with a
	// 	// separate history, we'll add the length or our
	// 	// history to the current, but will not recur in any
	// 	// case (we've been here before).
	// 	if( max_hist[curr_term] < curr_term_distance ){
	// 	    // ll(curr_term +' has a new max of '+ curr_term_distance);
	// 	    max_hist[curr_term] = curr_term_distance;
	// 	}
	//     }

	//     // Return the collected histories.
	//     return max_hist;
	// }

	// This is the actual path climbing agent.
	function max_info_climber(in_curr_list, in_curr_term_dist,
				  in_max_hist, in_enc_hist){

	    // We either bootstrap (first run) or pull them in.
	    var curr_list = in_curr_list || [];
	    // curr_list must be a list.
	    if( ! bbop.core.is_array(curr_list) ){ curr_list = [curr_list]; }
	    var curr_term_distance = in_curr_term_dist || 0;
	    var max_hist = in_max_hist || {};
	    var encounter_hist = in_enc_hist || {};

	    function update_info_for(update_item, update_distance){
		if( ! encounter_hist[update_item] ){
		    // ll('first time encountering: ' +
		    //    update_item + ', @:' + update_distance);
		    // Note that we have encountered this node before.
		    encounter_hist[update_item] = 1;
		    // Our first distance is the current one!
		    max_hist[update_item] = update_distance;
		}else{
		    // ll('have seen before: ' + update_item + '...' +
		    //    max_hist[update_item] + '/' + update_distance);
		    // If we're seeing this node again, but with a
		    // separate history, we'll add the length or our
		    // history to the current, but will not recur in
		    // any case (we've been here before).
		    if( max_hist[update_item] < update_distance ){
			// ll('   new high at current: ' + update_distance);
			max_hist[update_item] = update_distance;
		    }else{
			// ll('   keeping current: ' + max_hist[update_item]);
		    }
		}
	    }

	    // //
	    // ll('new set @' + curr_term_distance + ' looks like: ' +
	    //    bbop.core.dump(curr_list));

	    // Only work if we have things in our list.
	    if( curr_list && curr_list.length > 0 ){

		// Process everything in the list.
		each(curr_list,
		     function(item){
			 update_info_for(item, curr_term_distance);
		     });

		// Collect the parents of everything in the list.
		var next_round = {};
		each(curr_list,
		     function(item){
			 each(anchor.get_parent_nodes(item),
			      function(p){
				  var pid = p.id();
				  next_round[pid] = true;
			      });
		     });
		var next_list = bbop.core.get_keys(next_round);

		// Increment our distance.
		curr_term_distance++;

		// //
		// ll('future @' + curr_term_distance + ' looks like: ' +
		//    bbop.core.dump(next_list));

		// Recur on new parent list.
		max_info_climber(next_list, curr_term_distance,
				 max_hist, encounter_hist);
	    }

	    // Return the collected histories.
	    return max_hist;
	}

	// A hash of the maximum distance from the node-in-question to
	// the roots.
	var max_node_dist_from_root = max_info_climber(term_acc);
	// ll('max_node_dist_from_root: ' +
	//    bbop.core.dump(max_node_dist_from_root));

	///
	/// Convert this into something like brackets.
	///

	// First, invert hash.
	// E.g. from {x: 1, y: 1, z: 2} to {1: [x, y], 2: [z]} 
	var lvl_lists = {};
	each(max_node_dist_from_root,
	    function(node_id, lvl){
		// Make sure that level is defined before we push.
		if( ! bbop.core.is_defined(lvl_lists[lvl]) ){
		    lvl_lists[lvl] = [];
		}

		lvl_lists[lvl].push(node_id);
	    });
	// ll('lvl_lists: ' + bbop.core.dump(lvl_lists));

	// Now convert the level-keyed hash into an array of arrays.
	// E.g. from {1: [x, y], 2: [z]} to [[x, y], [z]]
	var bracket_list = [];
	var levels = bbop.core.get_keys(lvl_lists);
	levels.sort(bbop.core.numeric_sort_ascending);
	// ll('levels: ' + bbop.core.dump(levels));
	each(levels,
	    function(level){
		var bracket = [];
		each(lvl_lists[level],
		     function(item){
			 bracket.push(item);
		     });
		bracket_list.push(bracket);
	    });
	bracket_list.reverse(); // ...but I want the opposite
	// ll('bracket_list: ' + bbop.core.dump(bracket_list));

	// Well, that takes care of the parents, now lets do the
	// trivial task of adding all of the kids (if any).
	var c_nodes = anchor.get_child_nodes(term_acc);
	// Only add another level when there are actually kids.
	if( c_nodes && ! bbop.core.is_empty(c_nodes) ){ 
	    var kid_bracket = [];
	    each(c_nodes,
		 function(c){
		     kid_bracket.push(c.id());
		 });
	    bracket_list.push(kid_bracket);
	}

	return bracket_list;
    };

    /*
     * Function: relation_weight
     *
     * A GO-specific take on the relative importance of relations in a
     * graph.
     * 
     * Parameters: 
     *  predicate_acc - as string
     *  default_weight - *[optional]* as numbrt
     *
     * Returns: 
     *  relative weight of predicate as number; defaults to 0
     */
    this.relation_weight = function(predicate_acc, default_weight){

	var rel = predicate_acc || '';
	var dflt = default_weight || 0;
	var order = {
	    'is_a': 1,
	    'is a': 1,
	    'has_part': 2,
	    'has part': 2,
	    'part_of': 3,
	    'part of': 3,
	    'regulates': 4,
	    'negatively_regulates': 5,
	    'negatively regulates': 5,
	    'positively_regulates': 6,
	    'positively regulates': 6,
	    'occurs_in': 7,
	    'occurs in': 7
	};

	var ret_weight = dflt;
	if( bbop.core.is_defined(rel) &&
	    rel &&
	    bbop.core.is_defined(order[rel]) ){
	    ret_weight = order[rel];
	}

	return ret_weight;
    };

    /*
     * Function: dominant_relationship
     *
     * Given a bunch of relationships, return the one that is more
     * "dominant".
     * 
     * A GO-specific take on the relative importance of relations in a
     * graph.
     * 
     * Parameters: 
     *  whatever - predicate acc, or lists of lists them...whatever
     *
     * Returns: 
     *  string acc of the dominant relationship or null
     * 
     * See also:
     *  <relationship_weight>
     */
    this.dominant_relationship = function(){

	// Collect all of the relations, recursively unwinding as
	// necessary to get to the end of the arguments/lists of
	// predicate accs.
	// WARNING: Do /not/ try to refactor this for loop--see the
	// documentation for each for the reason.
	var all_rels = [];
	for( var dri = 0; dri < arguments.length; dri++ ){
	    var arg = arguments[dri];
	    //ll('ARG: ' + arg);
	    if( bbop.core.what_is(arg) === 'array' ){
		// This funny thing is actually "dereferencing" the
		// array one step for the recursion.
		all_rels.push(this.dominant_relationship.apply(this, arg));
	    }else{
		all_rels.push(arg);
	    }
	}
	
	// Sort all of the remaining predicate accs according to
	// relation_weight.
	all_rels.sort(function(a, b){
			  return anchor.relation_weight(b) -
			      anchor.relation_weight(a);
		      });

	// Choose the top if it's there, null otherwise.
	var retval = null;
	if( all_rels.length ){
	    retval = all_rels[0];
	}

	return retval;
    };

    /*
     * Function: rich_bracket_layout
     *
     * Very similar to <bracket_layout>, except that instead of the
     * node id, there is a list of [node_id, node_label, predicate].
     * 
     * This is only reliably producable if the following two condition
     * is met: the transitivity graph is the one made for the node of
     * interest by the GOlr loading engine. This is easy to meet if
     * using GOlr, but probably better to roll your own if you're not.
     * 
     * Also, the relative weight of the relations used is very
     * GO-specific--see <relation_weight>.
     * 
     * Again, heavy borrowing from ChewableGraph.pm from the perl
     * section in AmiGO 2.
     * 
     * Parameters: 
     *  term_acc - node of interest
     *  transitivity_graph - the <bbop.model.graph> for the relations
     *
     * Returns: 
     *  list of lists of lists: [[[id, label, predicate], ...], ...]
     */
    this.rich_bracket_layout = function(term_acc, transitivity_graph){
	
	// First, lets just get our base bracket layout.
	var layout = anchor.bracket_layout(term_acc);

	// So, let's go through all the rows, looking on the
	// transitivity graph to see if we can find the predicates.
	var bracket_list = [];
	each(layout, function(layout_level){
	    var bracket = [];
	    each(layout_level, function(layout_item){
		
		// The defaults for what we'll pass back out.
		var curr_acc = layout_item;
		//var pred_id = 'is_a';
		// BUG/TODO: This is the temporary workaround for
		// incomplete transitivity graphs in some cases:
		// https://github.com/kltm/bbop-js/wiki/TransitivityGraph#troubleshooting-caveats-and-fail-modes
		var pred_id = 'related_to';
		var curr_node = anchor.get_node(curr_acc);
		var label = curr_node.label() || layout_item;
		
		// Now we just have to determine predicates. If we're
		// the one, we'll just use the defaults.
		if( curr_acc == term_acc ){
		    // Default.
		}else{
		    // Since the transitivity graph only stores
		    // ancestors, we can also use it to passively test
		    // if these are children we should be looking for.
		    var trels =
			transitivity_graph.get_predicates(term_acc, curr_acc);
		    if( ! bbop.core.is_empty(trels) ){
			// Not children, so decide which of
			// the returned edges is the best.
			pred_id = anchor.dominant_relationship(trels);
		    }else{
			// Probably children, so go ahead and try and
			// pull the direct parent/child relation.
			var drels = anchor.get_predicates(curr_acc, term_acc);
			if( ! bbop.core.is_empty(drels) ){
			    pred_id = anchor.dominant_relationship(drels);
			}
		    }
		}
		
		// Turn our old layout item into a new-info
		// rich list.
		bracket.push([curr_acc, label, pred_id]);
	    });
	    // Sort alphanum and then re-add to list.
	    bracket.sort(function(a, b){
		if( a[1] < b[1] ){
		    return -1;
		}else if( a[1] > b[1] ){
		    return 1;
		}else{
		    return 0;
		}
	    });
	    bracket_list.push(bracket);
	});
	
	return bracket_list;
    };
};
bbop.core.extend(bbop.model.bracket.graph, bbop.model.graph);
/* 
 * Package: sugiyama.js
 * 
 * Namespace: bbop.layout.sugiyama
 * 
 * Purpose: Sugiyama system.
 * 
 * TODO: /Much/ better documentation. I have no idea what's going on
 * in there anymore...will try to recover what I can.
 * 
 * TODO: Matrix implementation and partition->matrix step need to be
 * tightened.
 *
 * TODO: Switch strange for-loops to bbop.core.each.
 *
 * BUG: need to check if there are no edges.
 * 
 * Actually, maybe there should be a separate render section, as this
 * is just a normal graph really?
 */

// Module and namespace checking.
if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.layout == "undefined" ){ bbop.layout = {}; }
if ( typeof bbop.layout.sugiyama == "undefined" ){ bbop.layout.sugiyama = {}; }

// Speciality variables in the namespace.
//bbop.layout.sugiyama.DEBUG = true;
bbop.layout.sugiyama.DEBUG = false;
bbop.layout.sugiyama.iterations = 10;

///
/// Defined some special in-house objects for helping figure out
/// the layout.
///

// Id, level, and whether it is real or not.
bbop.layout.sugiyama.simple_vertex = function(in_id, is_virtual){

    var vid = in_id;
    this.is_virtual = false;
    this.level = null;
    
    if( is_virtual ){
	this.is_virtual = true;
    }
    
    this.id = function(){
	return vid;
    };  
};

// An edge. A pair of ids and virtual_p.
bbop.layout.sugiyama.simple_edge = function( sub, obj, is_virtual ){

    var subject = sub;
    var object = obj;
    this.is_virtual = false;
    //var predicate = pred;
    
    //var is_virtual = false;
    //if( in_type ){
    //  is_virtual = true; }
    
    if( is_virtual ){
	this.is_virtual = true;
    }
    
    this.subject = function(){
	return subject;
    };
    
    this.object = function(){
	return object;
    };
    
    this.id = function(){
	return subject + '^' + object;
    };
    
    //this.predicate = function(){
    //  return predicate; };
};

/*
 * Wrapper for the recursive partitioner and partition object.
 * 
 * Partitions the graph into a layer cake of nodes, adds in the
 * necessary virtual nodes to make path routing work.
 */
bbop.layout.sugiyama.partitioner = function(graph){
    //bbop.layout.sugiyama.partitioner = function(graph, rel){
    
    // Internal logger.
    var logger = new bbop.logger("Partitioner");
    logger.DEBUG = bbop.layout.sugiyama.DEBUG;
    function ll(str){ logger.kvetch(str); }
    // Warning logger.
    var yikes = new bbop.logger("Partitioner WARNING");
    function warn_me(str){ yikes.kvetch(str); }


    // Aliases.
    var each = bbop.core.each;

    // Make use lexical scoping.
    var first_seen_reference = {};
    var last_seen_reference = {};
    var vertex_set = {};
    var edge_set = {};
    var vertex_partition_set = {};
    var edge_partition_set = {};
    var logical_paths = [];
    var maximum_partition_width = 0;
    var number_of_partitions = 0;

    // Dump partition.
    this.dump = function(){

	// Dump vertex partitions.
	var num_parts = 0;
	for( var key in vertex_partition_set ){
	    num_parts++;
	}
	for( var i = 0; i < num_parts; i++ ){
	    ll('Vertex Partition ' + i + ':');

	    var curr_part = vertex_partition_set[ i ];
	    var out = [];
	    for( var j = 0; j < curr_part.length; j++ ){
		out.push('[' + curr_part[j].id() + ']');
	    }
	    ll(out.join(''));
	}

	// Dump edge partitions.
	num_parts = 0;
	for( var key in edge_partition_set ){
	    num_parts++;
	}
	for( var i = 0; i < num_parts; i++ ){
	    ll('Edge Partition ' + i + ':');
	    var curr_part = edge_partition_set[ i ];
	    var out = [];
	    for( var j = 0; j < curr_part.length; j++ ){
		out.push('[' + curr_part[j].id() + ']');
	    }
	    ll(out.join(''));
	}

	// Dump paths list.
	for( var i = 0; i < logical_paths.length; i++ ){
	    ll('Path ' + i + ':');
	    var out = [];
	    for( var l = 0; l < logical_paths[i].length; l++ ){
		out.push( logical_paths[i][l] );
	    }
	    ll(out.join(', '));
	}
    };

    //
    this.max_partition_width = function(){
	return maximum_partition_width;
    };

    // Return the number of partitions.
    this.number_of_vertex_partitions = function(){
	return number_of_partitions;
    };

    // Return a partition.
    this.get_vertex_partition = function(integer){
	return vertex_partition_set[ integer ];
    };

    // Return the number of partitions.
    this.number_of_edge_partitions = function(){
	var i = 0;
	for( var key in edge_partition_set ){ i++; }
	return i;
    };

    // Return a partition.
    this.get_edge_partition = function(integer){
	return edge_partition_set[ integer ];
    };

    // Return the number of paths.
    this.number_of_logical_paths = function(){
	return logical_paths.length;
    };

    // Return the paths list.
    //this.get_logical_paths = function(integer){
    this.get_logical_paths = function(integer){
	return logical_paths;
    };

    // // Define the partitioner. Recursively walk the graph. BFS.
    // //function recursivePartitioner(graph, node, relation, level){
    // function recursivePartitioner(graph, node, level){
	
    // 	var curr_level = level;
    // 	var next_level = level +1;

    // 	ll("Saw " + node.id() + " at level " + level + "!");

    // 	// Have we seen it before or is it new?
    // 	var was_seen = false;
    // 	if( ! vertex_set[ node.id() ] ){

    // 	    // Create new vertex and add to set.
    // 	    var new_vertex = new bbop.layout.sugiyama.simple_vertex(node.id());
    // 	    new_vertex.level = level;
    // 	    vertex_set[ new_vertex.id() ] = new_vertex;

    // 	    // Check the node in to the 'seen' references.
    // 	    first_seen_reference[ new_vertex.id() ] = level;
    // 	    last_seen_reference[ new_vertex.id() ] = level;

    // 	}else{

    // 	    if( first_seen_reference[ node.id() ] > level ){
    // 		first_seen_reference[ node.id() ] = level;
    // 	    }
    // 	    if( last_seen_reference[ node.id() ] < level ){
    // 		last_seen_reference[ node.id() ] = level;
    // 	    }

    // 	    was_seen = true;
    // 	}
	
    // 	// Get all the child nodes and down we go!
    // 	//var child_nodes = graph.getExtantChildren(node.id(), relation);
    // 	var child_nodes = graph.get_child_nodes(node.id());
    // 	// TODO: Better way?
    // 	//var child_nodes = graph.getChildren(node.id(), relation);
    // 	for( var i = 0; i < child_nodes.length; i++ ){
    // 	    // Add edge and descend.
    // 	    var new_edge =
    // 		new bbop.layout.sugiyama.simple_edge(child_nodes[i].id(),
    // 						    node.id());
    // 	    edge_set[ new_edge.id() ] = new_edge;

    // 	    // Do not recur on seen nodes.
    // 	    if( ! was_seen ){
    // 		//recursivePartitioner(graph, child_nodes[i], relation, level +1);
    // 		recursivePartitioner(graph, child_nodes[i], level +1);
    // 	    }
    // 	}
    // }
    
    // Detect a cycle by seeing if the ID in question appears in the
    // search history stack.
    // TODO/BUG: make this less hyper-dumb and/or slow.
    function _cycle_p(node, stack){
	var ret = false;

	var id = node.id();
	each(stack,
	     function(item){
		 if( item == id ){
		     ret = true;
		 }
	     });

	return ret;
    }

    // Add a new node to the global variables.
    function _new_node_at(bnode, level){

	ll("adding " + bnode.id() + " at level " + level + "!");

	// Create new vertex and add to set.
	var new_vertex = new bbop.layout.sugiyama.simple_vertex(bnode.id());
	new_vertex.level = level;
	vertex_set[ new_vertex.id() ] = new_vertex;
	
	// Check the node in to the 'seen' references.
	first_seen_reference[ new_vertex.id() ] = level;
	last_seen_reference[ new_vertex.id() ] = level;		 
    }

    // Define the partitioner. Recursively walk the graph. BFS.
    //function recursivePartitioner(graph, node, relation, level){
    function recursivePartitioner(graph, node, call_stack){
	
	var curr_level = call_stack.length -1;
	var next_level = curr_level +1;

	ll("recur on " + node.id() + " at level " + curr_level);

	// Get children and see where there are.
	//var child_nodes = graph.get_child_nodes(node.id(), relation);
	var child_nodes = graph.get_child_nodes(node.id());
	ll(node.id() + " has " + (child_nodes.length || 'no' ) + ' child(ren)');
	for( var i = 0; i < child_nodes.length; i++ ){
	    var cnode = child_nodes[i];

	    ll("looking at " + cnode.id());

	    if( _cycle_p(cnode, call_stack) ){
		ll('no update to ' + cnode.id() + ': cycle');
	    }else{

		// Add edges--safe since they're definition-based and will
		// clobber if they're already in.
		var new_edge =
		    new bbop.layout.sugiyama.simple_edge(cnode.id(), node.id());
		edge_set[ new_edge.id() ] = new_edge;

		// Nodes we have to be a little more careful with since
		// they're what we're using for traversal.
		if( ! vertex_set[ cnode.id() ] ){
		
		    // Create new vertex and add to set.
		    _new_node_at(cnode, next_level);
		    
		    // Since it is a new node, we traverse it.
		    ll('cs (a): ' + call_stack);
		    var new_cs = bbop.core.clone(call_stack);
		    ll('cs (b): ' + new_cs);
		    new_cs.push(cnode.id());
		    ll('cs (c): ' + new_cs);
		    recursivePartitioner(graph, cnode, new_cs);
		    
		}else{
		    
		    ll('to update ' + cnode.id() + ' level to ' + next_level +
		       '; fsr: '+ first_seen_reference[ cnode.id() ] +
		       '; lsr: '+ last_seen_reference[ cnode.id() ]);
		    
		    // Otherwise, just update the levels that we've seen
		    // the child at--do not descend.
		    if( first_seen_reference[ cnode.id() ] > next_level ){
			first_seen_reference[ cnode.id() ] = next_level;
		    }
		    if( last_seen_reference[ cnode.id() ] < next_level ){
			last_seen_reference[ cnode.id() ] = next_level;
			// LSR is also the level that things will
			// appear at, so update.
			// I believe node and simple node IDs are the same?
			vertex_set[ cnode.id() ].level = next_level;

			// Recur if the LSR has change--we need to
			// update all of the nodes below.
			ll('cs (a): ' + call_stack);
			var new_cs = bbop.core.clone(call_stack);
			ll('cs (b): ' + new_cs);
			new_cs.push(cnode.id());
			ll('cs (c): ' + new_cs);
			recursivePartitioner(graph, cnode, new_cs);
		    }

		    // ll('updated ' + cnode.id() + ' level to ' + next_level +
		    //    '; fsr: '+ first_seen_reference[ cnode.id() ] +
		    //    '; lsr: '+ last_seen_reference[ cnode.id() ]);
		}
	    }
	}
    }
    
    // Run the partitioner after getting the root values (or whatever)
    // bootstrapped in.
    //var roots = graph.get_root_nodes(rel);
    var roots = graph.get_root_nodes();
    if( roots.length > 0 ){
	//partitionerBootstrap(roots);
	for( var i = 0; i < roots.length; i++ ){
	    _new_node_at(roots[i], 0);
	    recursivePartitioner(graph, roots[i], [roots[i].id()]);
	}
    }else{
    	// If there is no root (think of a "top-level" cycle),
    	// a node should be picked randomly.
    	// TODO: Test this.
    	var a_node = graph.all_nodes()[0] || null;
    	if( ! a_node ){
    	    ll('warning: apparently the graph is empty');
    	    //throw new Error('apparently the graph is empty--stop it!');
    	}else{
	    _new_node_at(a_node, 0);
    	    recursivePartitioner(graph, a_node, [a_node.id()]);
    	}
    }

    // Now we have a listing of the first and last level that a node
    // appears at. We'll go through and make a proper ordering. We know
    // that the last seen reference is where the actual node will
    // appear. If there is a difference with the listing in the first
    // node reference, the difference will be made in virtual nodes.
    var v_id = 0;
    for( var key in edge_set ){
	var edge = edge_set[ key ];

	var difference = vertex_set[ edge.subject() ].level -
	    vertex_set[ edge.object() ].level;
	ll('diff for '+edge.subject()+' -> '+edge.object()+' = '+ difference);
	ll('   ' + vertex_set[ edge.subject() ].level + '-' +
	   vertex_set[ edge.object() ].level);

	// If there is a difference, create virtual nodes and
	// paths. Deleted used edges.
	var new_path = [];
	if( difference > 1 ){
	    
	    // Create a new chain of virtual nodes.
	    var current_subject = edge.object();
	    var current_object = null;
	    var current_level = vertex_set[ edge.object() ].level; 
	    new_path.push(edge.object());
	    for( var i = 1; i <= difference; i++ ){

		current_object = current_subject;
		current_level++;

		if( i != difference ){
		    // Make a virtual node.
		    var v_node_id = '_VN_' + v_id + '_';
		    v_id++;	
		    var new_v_node =
			new bbop.layout.sugiyama.simple_vertex(v_node_id, true);
		    new_v_node.level = current_level;
		    vertex_set[ new_v_node.id() ] = new_v_node;
		    current_subject = new_v_node.id();
		    new_path.push(new_v_node.id());
		}else{
		    // Last link and path step.
		    current_subject = edge.subject();
		    new_path.push(edge.subject());
		}

		// Make edge to virtual node.
		var new_edge =
		    new bbop.layout.sugiyama.simple_edge(current_subject,
							current_object, true);
		edge_set[ new_edge.id() ] = new_edge;	
	    }

	    // Since the node generator goes in reverse order.
	    new_path.reverse();

	    // Finally, delete the edge connecting these two--no longer needed.
	    delete( edge_set[ key ] );

	}else{
	    // Add the trival path.
	    new_path.push(edge.subject());
	    new_path.push(edge.object());
	}
	// Add our new path to the group.
	logical_paths.push(new_path);
    }

    // Sort the vertices into different partitions and count them.
    for( var key in vertex_set ){
	var vert = vertex_set[ key ];
	var lvl = vert.level;
	if( ! vertex_partition_set[ lvl ] ){
	    vertex_partition_set[ lvl ] = [];
	    number_of_partitions++; // Count the number of partitions.
	}
	vertex_partition_set[ lvl ].push(vert);
	// Count max width.
	if( vertex_partition_set[ lvl ].length > maximum_partition_width ){
	    maximum_partition_width = vertex_partition_set[ lvl ].length;
	}
    }

    // Sort the edges into different partitions. Made easier since the
    // vertices have already been sorted.
    for( var key in edge_set ){

	var edge = edge_set[ key ];
	var lvl = vertex_set[ edge.object() ].level;
	ll('l:' +lvl);
	if( ! edge_partition_set[ lvl ] ){
	    edge_partition_set[ lvl ] = [];
	}
	edge_partition_set[ lvl ].push(edge);
    }
};

// Takes arrays of vertices and edges as an argument. Edges must have
// the methods '.object()' and '.subject()' and Vertices must have
// method '.id()'.
bbop.layout.sugiyama.bmatrix = function(object_vertex_partition,
					subject_vertex_partition,
					edge_partition){
    
    // Internal logger.
    var logger = new bbop.logger("BMatrix");
    logger.DEBUG = bbop.layout.sugiyama.DEBUG;
    function ll(str){ logger.kvetch(str); }
    // Warning logger.
    var yikes = new bbop.logger("BMatrix WARNING");
    function warn_me(str){ yikes.kvetch(str); }

    var relation_matrix = {};
    // var object_vector = object_vertex_partition;
    // var subject_vector = subject_vertex_partition;
    var object_vector = object_vertex_partition || [];
    var subject_vector = subject_vertex_partition || [];
    // Still warn that there is an issue.
    if( ! object_vector || ! subject_vector ){
	warn_me('WARNING: We found an instance of: https://github.com/kltm/bbop-js/issues/23; using a workaround.');
    }

    for( var i = 0; i < edge_partition.length; i++ ){

	var obj_id = edge_partition[i].object();
	var sub_id = edge_partition[i].subject();

	//
	if( ! relation_matrix[ obj_id ] ){
	    relation_matrix[ obj_id ] = {}; }
	//if( ! relation_matrix[ sub_id ] ){
	//  relation_matrix[ sub_id ] = {}; }

	relation_matrix[ obj_id ][ sub_id ] = true;
	//relation_matrix[ sub_id ][ obj_id ] = false;
    }

    // DEBUG relation matrix:
    // BUG: subject _vector occasionally undefined
    for( var m = 0; m <= object_vector.length -1; m++ ){
	ll("obj: <<o: " + object_vector[m].id() + ">>"); }
    for( var n = 0; n <= subject_vector.length -1; n++ ){
	ll("sub: <<o: " + subject_vector[n].id() + ">>"); }
    for( ob in relation_matrix ){
	for( su in relation_matrix[ ob ] ){
	    ll("edge: <<o: " + ob + ", s: " + su + ">>");
	}
    }

    //
    function getObjectBarycenter(object){
	var weighted_number_of_edges = 0;
	var number_of_edges = 0;
	for( var s = 1; s <= subject_vector.length; s++ ){
	    if( relation_matrix[object.id()] &&
		relation_matrix[object.id()][subject_vector[s -1].id()]){
		weighted_number_of_edges += s;
		number_of_edges++;
	    }
	}
	// The '-1' is to offset the indexing.
	return ( weighted_number_of_edges / number_of_edges ) -1;
    };

    // Gets barycenter for column s.
    function getSubjectBarycenter(subject){

	var weighted_number_of_edges = 0;
	var number_of_edges = 0;
	for( var o = 1; o <= object_vector.length; o++ ){
	    if( relation_matrix[object_vector[o -1].id()] &&
		relation_matrix[object_vector[o -1].id()][subject.id()]){
		weighted_number_of_edges += o;
		number_of_edges++;
	    }
	}
	// The '-1' is to offset the indexing.
	return ( weighted_number_of_edges / number_of_edges ) -1;
    };

    // BUG: These damn things seem to reoder on equal--want no reorder
    // on equal. Reorder objects given B1 <= B2, where Bi is the
    // barycenter weight.
    this.barycentricObjectReorder = function(){  
	object_vector.sort(
	    function(a,b){
		return getObjectBarycenter(a)
		    - getObjectBarycenter(b);
	    });
    };

    // BUG: These damn things seem to reoder on equal--want no reorder
    // on equal. Reorder subjects given B1 <= B2, where Bi is the
    // barycenter weight.
    this.barycentricSubjectReorder = function(){
	subject_vector.sort(
	    function(a,b){
		return getSubjectBarycenter(a)
		    - getSubjectBarycenter(b);
	    });
    };
    
    // Display the stored matrix.
    this.dump = function(){
	
	var queue = [];
	var string = null;

	//ll('o:' + object_vector);
	//ll('s:' + subject_vector);

	// Print top row.
	for( var i = 0; i < subject_vector.length; i++ ){
	    queue.push(subject_vector[i].id());
	}
	string = queue.join('\t');
	ll('o\\s\t' + string );

	// Print remainder.
	for( var j = 0; j < object_vector.length; j++ ){
	    queue = [];
	    queue.push(object_vector[j].id());
	    //ll("_(o: " + object_vector[j].id() + ")");
	    for( var k = 0; k < subject_vector.length; k++ ){
		//ll("_(o: "+object_vector[j].id() +", s: "+subject_vector[k].id()+")");
		//ll("(j: " + j + " k: " + k + ")");
		if( relation_matrix[object_vector[j].id()] &&
		    relation_matrix[object_vector[j].id()][subject_vector[k].id()] ){
			queue.push('(1)');
		    }else{
			queue.push('(0)');
		    }
	    }
	    ll(queue.join('\t'));
	}
    };
};

// Takes a graph.
// Can be queried for the position of every node and edge.
// GraphLayout = {};
// GraphLayout.Sugiyama = function
bbop.layout.sugiyama.render = function(){
    //bbop.layout.graph.call(this);
    this._is_a = 'bbop.layout.sugiyama.render';

    // Get a good self-reference point.
    var anchor = this;

    // Internal logger.
    var logger = new bbop.logger("SuGR");
    logger.DEBUG = bbop.layout.sugiyama.DEBUG;
    function ll(str){ logger.kvetch(str); }
    // Warning logger.
    var yikes = new bbop.logger("SuGR WARNING");
    function warn_me(str){ yikes.kvetch(str); }

    //
    //this.layout = function(graph_in, rel){
    this.layout = function(graph_in){
    //this.layout = function(){
	
	///
	/// Step I: Make a proper hierarchy; partition the graph over
	/// 'is_a'.
	///
	
	//var partitions = new bbop.layout.sugiyama.partitioner(g, 'is_a');
	//var partitions = new bbop.layout.sugiyama.partitioner(graph_in, rel);
	var partitions = new bbop.layout.sugiyama.partitioner(graph_in);
	//var partitions = new bbop.layout.sugiyama.partitioner(anchor);

	// DEBUG:
	ll('Dump paritions:');
	partitions.dump();
	ll('');

	///
	/// Step II: Reduce number of crossings by vertex permutation.
	///

	var edge_partitions = [];
	var vertex_partitions = [];

	// BUG: Need to catch num_partitions < 2 Create an instatiation of
	// all of the matrix representations of the partitions.
	for( var i = 0; i < partitions.number_of_edge_partitions(); i++ ){
	    var epart = partitions.get_edge_partition(i);
	    if( ! epart ){
	    	throw new Error('null edge partition at level: ' + i);
	    }else{
		edge_partitions.push(epart);
	    }
	}

	//
	for( var i = 0; i < partitions.number_of_vertex_partitions(); i++ ){
	    var vpart = partitions.get_vertex_partition(i);
	    if( ! vpart ){
	    	throw new Error('null vertex partition at level: ' + i);
	    }else{
		vertex_partitions.push(vpart);
	    }
	}  
	
	//
	for( var i = 0; i < edge_partitions.length; i++ ){
	    var m = new bbop.layout.sugiyama.bmatrix(vertex_partitions[i],
						     vertex_partitions[i +1],
						     edge_partitions[i]);
	    
	    ll('Matrix: ' + i);
	    m.dump();
	    ll('');
	    
	    // TODO: Can increase the number of iterations--the paper doesn't
	    // really explain this.
	    for( var k = 0; k < bbop.layout.sugiyama.iterations; k++ ){
		m.barycentricObjectReorder();
		m.barycentricSubjectReorder();
	    }

	    ll('Matrix: ' + i);
	    m.dump();
	    ll('');
	}

	///
	/// Step III: give proper integer X and Y positions: suspend
	/// them in a matrix.
	///

	// Create matrix for calculating layout.
	var layout_matrix = [];
	for( var i = 0; i < vertex_partitions.length; i++ ){
	    layout_matrix.push(new Array(partitions.max_partition_width()));
	}
	
	// Populate matrix and register final locations of nodes for later.
	// TODO: Sugiyama method. Temporarily did naive method.
	var real_vertex_locations = [];
	var vertex_registry = {};
	var virtual_vertex_locations = []; // 
	var m = partitions.max_partition_width();
	for( var i = 0; i < vertex_partitions.length; i++ ){
	    var l = vertex_partitions[i].length;
	    for( var v = 0; v < l; v++ ){
		var locale = Math.floor( (v+1) * (m/l/2) );
		while( layout_matrix[i][locale] ){
		    locale++;
		}
		var vid = vertex_partitions[i][v].id();
		layout_matrix[i][locale] = vid;
		vertex_registry[ vid ] = {x: locale, y: i};
		if( ! vertex_partitions[i][v].is_virtual ){
		    real_vertex_locations.push({x: locale, y: i, id: vid});
		}else{
		    virtual_vertex_locations.push({x: locale, y: i, id: vid});
		}
		ll( vid + ', x:' + locale + ' y:' + i);
	    }
	}
	
	// Convert logical paths to actual paths.
	var logical_paths = partitions.get_logical_paths();
	var described_paths = [];
	for( var i = 0; i < logical_paths.length; i++ ){
	    var node_trans = [];
	    var waypoints = [];
	    for( var j = 0; j < logical_paths[i].length; j++ ){
		var cursor = logical_paths[i][j];
		node_trans.push(cursor);
		waypoints.push({x: vertex_registry[cursor].x,
				y: vertex_registry[cursor].y });
	    }
	    described_paths.push({'nodes': node_trans,
				  'waypoints': waypoints});
	}
	
	// Create a return array 
	// DEBUG:
	//   ll('Layout:');
	//   for( var i = 0; i < layout_matrix.length; i++ ){
	//     var out = [];
	//     for( var j = 0; j < layout_matrix[i].length; j++ ){
	//       out.push(layout_matrix[i][j]);
	//     }
	//     ll(out.join('\t'));
	//   }
	//   ll('');
	
	// Return this baddy to the world.
	return { nodes: real_vertex_locations,
		 virtual_nodes: virtual_vertex_locations,
		 paths: described_paths,
		 height: partitions.max_partition_width(),
		 width: partitions.number_of_vertex_partitions()};
    };
};
//bbop.core.extend(bbop.model.sugiyama.graph, bbop.model.graph);
/* 
 * Package: response.js
 * 
 * Namespace: bbop.rest.response
 * 
 * Generic BBOP handler for dealing with the gross parsing of
 * responses from a REST server. This is just an example pass-thru
 * handler that needs to be overridden (see subclasses).
 * 
 * You may note that things like status and status codes are not part
 * of the base response. The reason is is that not all methods of REST
 * in the environments that we use support them. For example: readURL
 * in rhino. For this reason, the "health" of the response is left to
 * the simple okay() function--just enought to be able to choose
 * between "success" and "failure" in the managers. To give a bit more
 * information in case of early error, there is message and
 * message_type.
 * 
 * Similarly, there are no toeholds in the returned data except
 * raw(). All data views and operations are implemented in the
 * subclasses.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.rest == "undefined" ){ bbop.rest = {}; }

/*
 * Constructor: response
 * 
 * Contructor for a REST query response object.
 * 
 * The constructor argument is an object, not a string.
 * 
 * Arguments:
 *  in_data - the string returned from a request
 * 
 * Returns:
 *  rest response object
 */
bbop.rest.response = function(in_data){
    this._is_a = 'bbop.rest.response';

    // The raw incoming document.
    this._raw = in_data;

    // Cache for repeated calls to okay().
    this._okay = null;
    this._message = null;
    this._message_type = null;
};

/*
 * Function: raw
 * 
 * Returns the initial response object, whatever it was.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  object
 */
bbop.rest.response.prototype.raw = function(){
    return this._raw;
};

/*
 * Function: okay
 * 
 * Simple return verification of sane response from server.
 * 
 * This okay() caches its return value, so harder probes don't need to
 * be performed more than once.
 * 
 * Arguments:
 *  okay_p - *[optional]* setter for okay
 * 
 * Returns:
 *  boolean
 */
bbop.rest.response.prototype.okay = function(okay_p){

    // Optionally set from the outside.
    if( bbop.core.is_defined(okay_p) ){
	this._okay = okay_p;
    }

    //print('a: ' + this._okay);
    if( this._okay == null ){ // only go if answer not cached
	//print('b: ' + this._raw);
	if( ! this._raw || this._raw == '' ){
	    //print('c: if');
	    this._okay = false;
	}else{
	    //print('c: else');
	    this._okay = true;
	}
    }
    
    return this._okay;
};

/*
 * Function: message
 * 
 * A message that the response wants to let you know about its
 * creation.
 * 
 * Arguments:
 *  message - *[optional]* setter for message
 * 
 * Returns:
 *  message string
 */
bbop.rest.response.prototype.message = function(message){
    if( bbop.core.is_defined(message) ){
	this._message = message;
    }
    return this._message;
};

/*
 * Function: message_type
 * 
 * A message about the message (a string classifier) that the response
 * wants to let you know about its message.
 * 
 * Arguments:
 *  message_type - *[optional]* setter for message_type
 * 
 * Returns:
 *  message type string
 */
bbop.rest.response.prototype.message_type = function(message_type){
    if( bbop.core.is_defined(message_type) ){
	this._message_type = message_type;
    }
    return this._message_type;
};
/* 
 * Package: json.js
 * 
 * Namespace: bbop.rest.response.json
 * 
 * Generic BBOP handler for dealing with the gross parsing of
 * responses from a REST JSON server.
 * 
 * It will detect if the incoming response is a string, and if so, try
 * to parse it to JSON. Otherwise, if the raw return is already an
 * Object, we assume that somebody got to it before us (e.g. jQuery's
 * handling).
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.rest == "undefined" ){ bbop.rest = {}; }
if ( typeof bbop.rest.response == "undefined" ){ bbop.rest.response = {}; }

/*
 * Constructor: json
 * 
 * Contructor for a REST JSON response object.
 * 
 * The constructor argument is an object, not a string.
 * 
 * Arguments:
 *  json_data - the JSON object as a string (as returned from a request)
 * 
 * Returns:
 *  rest response object
 */
bbop.rest.response.json = function(json_data){
    bbop.rest.response.call(this);
    this._is_a = 'bbop.rest.response.json';

    // The raw incoming document.
    //this._raw_string = json_data_str;
    this._raw_string = null;
    this._okay = null;

    if( json_data ){

	if( bbop.core.what_is(json_data) == 'string' ){

	    // Try and parse out strings.
	    try {
		this._raw = bbop.json.parse(json_data);
		this._okay = true;
	    }catch(e){
		// Didn't make it, but still a string.
		this._raw = json_data;
		this._okay = false;
	    }

	}else if( bbop.core.what_is(json_data) == 'object' ||
		  bbop.core.what_is(json_data) == 'array' ){

	    // Looks like somebody else got here first.
	    this._raw = json_data;
	    this._okay = true;
	    
	}else{

	    // No idea what this thing is...
	    this._raw = null;
	    this._okay = null;
	}
    }
};
bbop.core.extend(bbop.rest.response.json, bbop.rest.response);

// /*
//  * Function: string
//  * 
//  * returns a string of the incoming response
//  * 
//  * Arguments:
//  *  n/a
//  * 
//  * Returns:
//  *  raw response string
//  */
// bbop.rest.response.json.prototype.string = function(){
//     return this._raw_string;
// };
/* 
 * Package: mmm.js
 * 
 * Namespace: bbop.rest.response.mmm
 * 
 * Generic BBOP handler for dealing with the gross parsing of
 * responses from the GO Molecular Model Manager REST server JSON
 * responses.
 * 
 * It will detect if the incoming response is structured correctly and
 * give safe access to fields and properties.
 * 
 * It is not meant to be a model for the parts in the data section.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.rest == "undefined" ){ bbop.rest = {}; }
if ( typeof bbop.rest.response == "undefined" ){ bbop.rest.response = {}; }

/*
 * Constructor: mmm
 * 
 * Contructor for a GO MMM REST JSON response object.
 * 
 * The constructor argument is an object or a string.
 * 
 * Arguments:
 *  raw_data - the JSON object as a string or object
 * 
 * Returns:
 *  response object
 */
bbop.rest.response.mmm = function(raw_data){
    bbop.rest.response.call(this);
    this._is_a = 'bbop.rest.response.mmm';

    // Add the required commentary, inconsistency, and data.
    this._commentary = null;
    this._data = null;

    // Start with the assumption that the response is bad, try and
    // prove otherwise.
    this.okay(false);

    // Raw will only be provided in that cases that it makes sense.
    this._raw = null;
    
    // If we have data coming in...
    if( ! raw_data ){
	
	this.message('empty response in handler');
	this.message_type('error');

    }else{

	// And it looks like something we might be able to deal with...
	var itsa = bbop.core.what_is(raw_data);
	if( itsa != 'string' && itsa != 'object' ){
	    
	    // No idea what this thing is...
	    this.message('bad argument type in handler');
	    this.message_type('error');

	}else{
	    
	    // Try to make the string an object.
	    if( itsa == 'string' ){
		try {
		    this._raw = bbop.json.parse(raw_data);
		}catch(e){
		    // Didn't make it--chuck it to create a signal.
		    this._raw = null;
		    this.message('handler could not parse string response');
		    this.message_type('error');
		}
	    }else{
		// Looks like somebody else got here first.
		this._raw = raw_data;
	    }

	    // If we managed to define some kind of raw incoming data
	    // that is, or has been parsed to, a model, probe it to
	    // see if it is structured correctly.
	    if( this._raw ){

		// Check required fields.
		var data = this._raw;
		// These must always be defined.
		if( data && data['message_type'] && data['message'] ){

		    var odata = data['data'] || null;
		    var cdata = data['commentary'] || null;

		    // If data, object or array.
		    if( odata && bbop.core.what_is(odata) != 'object' &&
			bbop.core.what_is(odata) != 'array' ){
			this.message('data not object');
			this.message_type('error');
		    }else{
			// If commentary, object.
			if( cdata && bbop.core.what_is(cdata) != 'object' ){
			    this.message('commentary not object');
			    this.message_type('error');
			}else{
			    // Looks fine then I guess.
			    this.okay(true);
			    this.message_type(data['message_type']);
			    this.message(data['message']);

			    // Add any additional fields.
			    if( cdata ){ this._commentary = cdata; }
			    if( odata ){ this._data = odata; }
			}
		    }
		}
	    }
	}
    }
};
bbop.core.extend(bbop.rest.response.mmm, bbop.rest.response);

/*
 * Function: commentary
 * 
 * Returns the commentary object (whatever that might be in any given
 * case).
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  copy of commentary object or null
 */
bbop.rest.response.mmm.prototype.commentary = function(){
    var ret = null;
    if( this._commentary ){
	ret = bbop.core.clone(this._commentary);
    }
    return ret;
};

/*
 * Function: data
 * 
 * Returns the data object (whatever that might be in any given
 * case). This grossly returns all response data, if any.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  copy of data object or null
 */
bbop.rest.response.mmm.prototype.data = function(){
    var ret = null;
    if( this._data ){
	ret = bbop.core.clone(this._data);
    }
    return ret;
};

/*
 * Function: model_id
 * 
 * Returns the model id of the response.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  string or null
 */
bbop.rest.response.mmm.prototype.model_id = function(){
    var ret = null;
    if( this._data && this._data['id'] ){
	ret = this._data['id'];
    }
    return ret;
};

/*
 * Function: inconsistent_p
 * 
 * Returns true or false on whether or not the returned model is
 * thought to be inconsistent. Starting assumption is that it is not.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  true or false
 */
bbop.rest.response.mmm.prototype.inconsistent_p = function(){
    var ret = false;
    if( this._data &&
	typeof(this._data['inconsistent_p']) !== 'undefined' &&
	this._data['inconsistent_p'] == true ){
	ret = true;
    }
    return ret;
};

/*
 * Function: facts
 * 
 * Returns a list of the facts in the response. Empty list if none.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  list
 */
bbop.rest.response.mmm.prototype.facts = function(){
    var ret = [];
    if( this._data && this._data['facts'] && 
	bbop.core.is_array(this._data['facts']) ){
	ret = this._data['facts'];
    }
    return ret;
};

/*
 * Function: properties
 * 
 * Returns a list of the properties in the response. Empty list if none.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  list
 */
bbop.rest.response.mmm.prototype.properties = function(){
    var ret = [];
    if( this._data && this._data['properties'] && 
	bbop.core.is_array(this._data['properties']) ){
	ret = this._data['properties'];
    }
    return ret;
};

/*
 * Function: individuals
 * 
 * Returns a list of the individuals in the response. Empty list if none.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  list
 */
bbop.rest.response.mmm.prototype.individuals = function(){
    var ret = [];
    if( this._data && this._data['individuals'] && 
	bbop.core.is_array(this._data['individuals']) ){
	ret = this._data['individuals'];
    }
    return ret;
};

/*
 * Function: relations
 * 
 * Returns a list of the relations found in the response. Likely not
 * to be there, so check the return.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  list
 */
bbop.rest.response.mmm.prototype.relations = function(){
    var ret = [];
    if( this._data && this._data['relations'] && 
	bbop.core.is_array(this._data['relations']) ){
	ret = this._data['relations'];
    }
    return ret;
};
/* 
 * Package: manager.js
 * 
 * Namespace: bbop.rest.manager
 * 
 * Generic BBOP manager for dealing with basic generic REST calls.
 * This specific one is designed to be overridden by its subclasses.
 * This one pretty much just uses its incoming resource string as the data.
 * Mostly for testing purposes.
 * 
 * Both a <bbop.rest.response> (or clean error data) and the manager
 * itself (this as anchor) should be passed to the callbacks.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.rest == "undefined" ){ bbop.rest = {}; }

/*
 * Constructor: manager
 * 
 * Contructor for the REST manager
 * 
 * Arguments:
 *  response_parser - the response handler class to use for each call
 * 
 * Returns:
 *  rest manager object
 * 
 * See also:
 *  <bbop.registry>
 */
bbop.rest.manager = function(response_handler){
    bbop.registry.call(this, ['success', 'error']);
    this._is_a = 'bbop.rest.manager';

    // Get a good self-reference point.
    var anchor = this;

    // Per-manager logger.
    this._logger = new bbop.logger(this._is_a);
    //this._logger.DEBUG = true;
    this._logger.DEBUG = false;
    function ll(str){ anchor._logger.kvetch(str); }

    // Handler instance.
    this._response_handler = response_handler;

    // The URL to query.
    this._qurl = null;

    // The argument payload to deliver to the URL.
    this._qpayload = {};

    // The way to do the above.
    this._qmethod = null;

    // Whether or not to prevent ajax events from going.
    // This may not be usable, or applicable, to all backends.
    this._safety = false;

    /*
     * Function: debug
     * 
     * Turn on or off the verbose messages. Uses <bbop.logger>, so
     * they should come out everywhere.
     * 
     * Parameters: 
     *  p - *[optional]* true or false for debugging
     *
     * Returns: 
     *  boolean; the current state of debugging
     */
    this.debug = function(p){
	if( p == true || p == false ){
	    this._logger.DEBUG = p;
	    // TODO: add debug parameter a la include_highlighting
	}
	return this._logger.DEBUG;
    };

    // The main callback function called after a successful AJAX call in
    // the update function.
    this._run_success_callbacks = function(in_data){
	ll('run success callbacks...');
	//var response = anchor.(in_data);
	var response = new anchor._response_handler(in_data);
	anchor.apply_callbacks('success', [response, anchor]);
    };

    // This set is called when we run into a problem.
    this._run_error_callbacks = function(in_data){
	ll('run error callbacks...');
	var response = new anchor._response_handler(in_data);
	anchor.apply_callbacks('error', [response, anchor]);
    };

    /*
     * Function: resource
     *
     * The base target URL for our operations.
     * 
     * Parameters:
     *  url - *[optional]* update resource target with string
     *
     * Returns:
     *  the url as string (or null)
     */
    this.resource = function(url){
	if( bbop.core.is_defined(url) && 
	    bbop.core.what_is(url) == 'string' ){
	    anchor._qurl = url;
	}
	return anchor._qurl;
    };

    /*
     * Function: payload
     *
     * The information to deliver to the resource.
     * 
     * Parameters:
     *  payload - *[optional]* update payload information
     *
     * Returns:
     *  a copy of the current payload
     */
    this.payload = function(payload){
	if( bbop.core.is_defined(payload) && 
	    bbop.core.what_is(payload) == 'object' ){
	    anchor._qpayload = payload;
	}
	return bbop.core.clone(anchor._qpayload);
    };

    /*
     * Function: method
     *
     * The method to use to get the resource, as a string.
     * 
     * Parameters:
     *  method - *[optional]* update aquisition method with string
     *
     * Returns:
     *  the string or null
     */
    this.method = function(method){
	if( bbop.core.is_defined(method) && 
	    bbop.core.what_is(method) == 'string' ){
	    anchor._qmethod = method;
	}
	return anchor._qmethod;
    };

    /*
     * Function: action
     *
     * This method is the most fundamental operation. It should
     * combine the URL, payload, and method in the ways appropriate to
     * the subclass engine. This one merely combines the string.
     * 
     * The method argument is naturally ignored in this dummy class.
     * 
     * Parameters:
     *  url - *[optional]* update resource target with string
     *  payload - *[serially optional]* object to represent arguments
     *  method - *[serially optional]* (GET, POST, etc.)
     *
     * Returns:
     *  the combined URL argument as string
     * 
     * See also:
     *  <update>
     */
    this.action = function(url, payload, method){
	if( bbop.core.is_defined(url) ){ anchor.resource(url); }
	if( bbop.core.is_defined(payload) ){ anchor.payload(payload); }
	if( bbop.core.is_defined(method) ){ anchor.method(method); }

	// Since there is no AJAX/REST in our case, we just loop back
	// with the argument string.
	if( bbop.core.is_defined(anchor.resource()) ){
	    return anchor.update('success');
	}else{
	    return anchor.update('error');
	}
    };
};
bbop.core.extend(bbop.rest.manager, bbop.registry);

/*
 * Function: to_string
 *
 * Output writer for this object/class.
 * See the documentation in <core.js> on <dump> and <to_string>.
 * 
 * Parameters: 
 *  n/a
 *
 * Returns:
 *  string
 */
bbop.rest.manager.prototype.to_string = function (){
    return '[' + this._is_a + ']';
};

/*
 * Function: assemble
 *
 * Assemble the resource and arguments into a URL string.
 * 
 * May not be appropriate for all subclasses. Often used as a helper,
 * etc.
 * 
 * Parameters:
 *  n/a
 *
 * Returns:
 *  url string
 * 
 * Also see:
 *  <get_query_url>
 */
bbop.rest.manager.prototype.assemble = function(){

    // Conditional merging of the remaining variant parts.
    var qurl = this.resource();
    if( ! bbop.core.is_empty(this.payload()) ){
	var asm = bbop.core.get_assemble(this.payload());
	qurl = qurl + '?' + asm;
    }
    return qurl;
};

/*
 * Function: update
 *
 * The user code to select the type of update (and thus the type
 * of callbacks to be called on data return).
 * 
 * Parameters: 
 *  callback_type - callback type string; 'success' and 'error' (see subclasses)
 *
 * Returns:
 *  the query url
 * 
 * Also see:
 *  <get_query_url>
 */
bbop.rest.manager.prototype.update = function(callback_type){

    // Conditional merging of the remaining variant parts.
    var qurl = this.resource();
    if( ! bbop.core.is_empty(this.payload()) ){
	var asm = bbop.core.get_assemble(this.payload());
	qurl = qurl + '?' + asm;
    }

    // Callbacks accordingly.
    if( callback_type == 'success' ){
	this._run_success_callbacks(qurl);
    }else if( callback_type == 'error' ){
	this._run_error_callbacks(qurl);
    }else{
    	throw new Error("Unknown callback_type: " + callback_type);
    }
    
    //ll('qurl: ' + qurl);
    return qurl;
};
/* 
 * Package: rhino.js
 * 
 * Namespace: bbop.rest.manager.rhino
 * 
 * Rhino BBOP manager for dealing with remote calls. Remember,
 * this is actually a "subclass" of <bbop.rest.manager>.
 * 
 * This is a very simple subclass that does not get into the messiness
 * of errors and codes since we're using the trivial readURL method.
 * 
 * TODO/BUG: Does not handle "error" besides giving an "empty"
 * response.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.rest == "undefined" ){ bbop.rest = {}; }
if ( typeof bbop.rest.manager == "undefined" ){ bbop.rest.manager = {}; }

/*
 * Constructor: rhino
 * 
 * Contructor for the REST query manager; Rhino-style.
 * 
 * Be aware that this version is a synchronous call.
 * 
 * Arguments:
 *  response_handler
 * 
 * Returns:
 *  REST manager object
 * 
 * See also:
 *  <bbop.rest.manager>
 */
bbop.rest.manager.rhino = function(response_handler){
    bbop.rest.manager.call(this, response_handler);
    this._is_a = 'bbop.rest.manager.rhino';
};
bbop.core.extend(bbop.rest.manager.rhino, bbop.rest.manager);

/*
 * Function: update
 *
 *  See the documentation in <bbop/rest/manager.js> on update to get more
 *  of the story. This override function adds functionality to Rhino.
 *
 * Parameters: 
 *  callback_type - callback type string
 *
 * Returns:
 *  the query url (with any Rhino specific paramteters)
 * 
 * Also see:
 *  <fetch>
 */
bbop.rest.manager.rhino.prototype.update = function(callback_type){

    // 
    var qurl = this.assemble();

    // Grab the data from the server and pick the right callback group
    // accordingly.
    var raw_str = readUrl(qurl); // in Rhino
    if( raw_str && raw_str != '' ){
	var response = new this._response_handler(raw_str);
	this.apply_callbacks(callback_type, [response, this]);
    }else{
	var response = new anchor._response_handler(null);
	this.apply_callbacks('error', [response, this]);
	//throw new Error('explody');
    }

    return qurl;
};

/*
 * Function: fetch
 *
 * This is the synchronous data getter for Rhino--probably your best
 * bet right now for scripting.
 * 
 * Parameters:
 *  n/a 
 *
 * Returns:
 *  a <bbop.rest.response> (or subclass) or null
 * 
 * Also see:
 *  <update>
 */
bbop.rest.manager.rhino.prototype.fetch = function(url, payload){
    
    var retval = null;

    // Update if necessary.
    if( url ){ this.resource(url); }
    if( payload ){ this.payload(payload); }

    var qurl = this.assemble();
    
    // Grab the data from the server and pick the right callback group
    // accordingly.
    var raw_str = readUrl(qurl); // in Rhino
    if( raw_str && raw_str != '' ){
	retval = new this._response_handler(raw_str);
    }else{
	retval = new anchor._response_handler(null);
	//this.apply_callbacks('error', ['no data', this]);
	//throw new Error('explody');
    }

    return retval;
};

/* 
 * Package: ringo.js
 * 
 * Namespace: bbop.rest.manager.ringo
 * 
 * RingoJS BBOP manager for dealing with remote calls. Remember,
 * this is actually a "subclass" of <bbop.rest.manager>.
 * 
 * TODO/BUG: Does not handle "error" besides giving an "empty"
 * response.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.rest == "undefined" ){ bbop.rest = {}; }
if ( typeof bbop.rest.manager == "undefined" ){ bbop.rest.manager = {}; }

/*
 * Constructor: ringo
 * 
 * Contructor for the REST query manager; RingoJS-style.
 * 
 * Be aware that this version is a synchronous call. Also be aware
 * that this assumes we're in a ringo environment so that the require
 * for commonjs is around.
 * 
 * Arguments:
 *  response_handler
 * 
 * Returns:
 *  REST manager object
 * 
 * See also:
 *  <bbop.rest.manager>
 */
bbop.rest.manager.ringo = function(response_handler){
    bbop.rest.manager.call(this, response_handler);
    this._is_a = 'bbop.rest.manager.ringo';

    // Grab an http client.
    this._http_client = require("ringo/httpclient");
};
bbop.core.extend(bbop.rest.manager.ringo, bbop.rest.manager);

/*
 * Function: update
 *
 *  See the documentation in <bbop.rest.manager.js> on update to get more
 *  of the story. This override function adds functionality to RingoJS.
 *
 * Parameters: 
 *  callback_type - callback type string
 *
 * Returns:
 *  the query url (with any RingoJS specific parameters)
 * 
 * Also see:
 *  <get_query_url>
 */
bbop.rest.manager.ringo.prototype.update = function(callback_type){

    var anchor = this;
    var qurl = anchor.resource();
    //console.log('qurl: ' + qurl);

    // Grab the data from the server and pick the right callback group
    // accordingly.
    //anchor._callbacker = function(exchange){
    anchor._callbacker = function(data, status, contentType, exchange){
	// console.log('callback_type: ' + callback_type);
	// console.log('data: ' + data);
	// console.log('status: ' + status);
	// console.log('contentType: ' + contentType);
	// console.log('exchange: ' + exchange);

	var raw_str = exchange.content;
	//var raw_str = data;
	if( raw_str && raw_str != '' ){
	    var response = new anchor._response_handler(raw_str);
	    // console.log('response okay?: ' + response.okay());
	    anchor.apply_callbacks(callback_type, [response, this]);
	}else{
	    var response = new anchor._response_handler(null);
	    this.apply_callbacks('error', [response, this]);
	    //throw new Error('explody');
	}
    };
    // In RingoJS.
    var exchange = this._http_client.get(qurl, null, anchor._callbacker);
    // console.log('exchange.done: ' + exchange.done);

    return qurl;
};

// /*
//  * Function: fetch
//  *
//  * This is the synchronous data getter for RingoJS--probably your best
//  * bet right now for scripting.
//  * 
//  * NOTE:
//  * 
//  * Parameters:
//  *  url - url to get the data from
//  *
//  * Returns:
//  *  a <bbop.rest.response> or null
//  * 
//  * Also see:
//  *  <update>
//  */
// bbop.rest.manager.ringo.prototype.fetch = function(url){
    
//     var retval = null;

//     var qurl = this.resource(url);

//     // Grab the data from the server and pick the right callback group
//     // accordingly.
//     var exchange = this._http_client.get(qurl); // in RingoJS
//     // BUG/TODO: until I figure out sync.
//     var raw_str = exchange.content;
//     if( raw_str && raw_str != '' ){
// 	retval = new this._response_handler(raw_str);
//     }else{
// 	var response = new anchor._response_handler(null);
// 	this.apply_callbacks('error', [response, this]);
// 	//throw new Error('explody');
//     }

//     return retval;
// };

/* 
 * Package: node.js
 * 
 * Namespace: bbop.rest.manager.node
 * 
 * NodeJS BBOP manager for dealing with remote calls. Remember,
 * this is actually a "subclass" of <bbop.rest.manager>.
 * 
 * TODO/BUG: Does not handle "error" besides giving an "empty"
 * response.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.rest == "undefined" ){ bbop.rest = {}; }
if ( typeof bbop.rest.manager == "undefined" ){ bbop.rest.manager = {}; }

/*
 * Constructor: node
 * 
 * Contructor for the REST query manager; NodeJS-style.
 * 
 * This assumes we're in a node environment so that the require
 * for commonjs is around.
 * 
 * Arguments:
 *  response_handler
 * 
 * Returns:
 *  REST manager object
 * 
 * See also:
 *  <bbop.rest.manager>
 */
bbop.rest.manager.node = function(response_handler){
    bbop.rest.manager.call(this, response_handler);
    this._is_a = 'bbop.rest.manager.node';

    // Grab an http client.
    this._http_client = require('http');
    this._url_parser = require('url');
};
bbop.core.extend(bbop.rest.manager.node, bbop.rest.manager);

/*
 * Function: update
 *
 *  See the documentation in <bbop.rest.manager.js> on update to get more
 *  of the story. This override function adds functionality to NodeJS.
 *
 * Parameters: 
 *  callback_type - callback type string (so far unused)
 *
 * Returns:
 *  the query url (with any NodeJS specific parameters)
 */
bbop.rest.manager.node.prototype.update = function(callback_type){

    var anchor = this;

    // What to do if an error is triggered.
    function on_error(e) {
	console.log('problem with request: ' + e.message);
	var response = new anchor._response_handler(null);
	response.okay(false);
	response.message(e.message);
	response.message_type('error');
	anchor.apply_callbacks('error', [response, anchor]);
    }

    // Two things to do here: 1) collect data and 2) what to do with
    // it when we're done (create response).
    function on_connect(res){
	//console.log('STATUS: ' + res.statusCode);
	//console.log('HEADERS: ' + JSON.stringify(res.headers));
	res.setEncoding('utf8');
	var raw_data = '';
	res.on('data', function (chunk) {
	    //console.log('BODY: ' + chunk);
	    raw_data = raw_data + chunk;
	});
	// Throw to .
	res.on('end', function () {
	    //console.log('END with: ' + raw_data);
	    var response = new anchor._response_handler(raw_data);
	    if( response && response.okay() ){
		anchor.apply_callbacks('success', [response, anchor]);
	    }else{
		// Make sure that there is something there to
		// hold on to.
		if( ! response ){
		    response = new anchor._response_handler(null);
		    response.okay(false);
		    response.message_type('error');
		    response.message('null response');
		}else{
		    response.message_type('error');
		    response.message('bad response');
		}
		anchor.apply_callbacks('error', [response, anchor]);
	    }
	});
    }

    // Conditional merging of the remaining variant parts.
    var qurl = this.resource();
    var args = '';
    if( ! bbop.core.is_empty(this.payload()) ){
	var asm = bbop.core.get_assemble(this.payload());
	args = '?' + asm;
    }

    //qurl = 'http://amigo2.berkeleybop.org/cgi-bin/amigo2/amigo/term/GO:0022008/json';
    var final_url = qurl + args;

    // http://nodejs.org/api/url.html
    var purl = anchor._url_parser.parse(final_url);
    var req_opts = {
    	//'hostname': 'localhost',
    	//'path': '/cgi-bin/amigo2/amigo/term/GO:0022008/json',
	'port': 80,
	'method': 'GET'
    };
    // Tranfer the intersting bit over.
    bbop.core.each(['protocol', 'hostname', 'port', 'path'],
		   function(purl_prop){
		       if( purl[purl_prop] ){
			   req_opts[purl_prop] = purl[purl_prop];
		       }
		   });
    // And the method.
    var mth = anchor.method();
    if( mth && mth != 'get' ){
    	req_opts['method'] = mth;
    }
    var req = anchor._http_client.request(req_opts, on_connect);
    // var req = anchor._http_client.request(final_url, on_connect);

    req.on('error', on_error);
    
    // write data to request body
    //req.write('data\n');
    //req.write('data\n');
    req.end();
    
    return final_url;
};
/* 
 * Package: jquery.js
 * 
 * Namespace: bbop.rest.manager.jquery
 * 
 * TODO!
 * 
 * jQuery BBOP manager for dealing with actual ajax calls. Remember,
 * this is actually a "subclass" of <bbop.rest.manager>.
 * 
 * This should still be able to limp along (no ajax and no error
 * parsing) even outside of a jQuery environment.
 * 
 * Use <use_jsonp> is you are working against a JSONP service instead
 * of a non-cross-site JSON service.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.rest == "undefined" ){ bbop.rest = {}; }
if ( typeof bbop.rest.manager == "undefined" ){ bbop.rest.manager = {}; }

/*
 * Constructor: jquery
 * 
 * Contructor for the jQuery REST manager
 * 
 * Arguments:
 *  response_handler
 * 
 * Returns:
 *  REST manager object
 * 
 * See also:
 *  <bbop.rest.manager>
 */
bbop.rest.manager.jquery = function(response_handler){
    bbop.rest.manager.call(this, response_handler);
    this._is_a = 'bbop.rest.manager.jquery';

    this._use_jsonp = false;
    this._jsonp_callback = 'json.wrf';
    this._headers = null;

    // Before anything else, if we cannot find a viable jQuery library
    // for use, we're going to create a fake one so we can still test
    // and work in a non-browser/networked environment.
    var anchor = this;
    anchor.JQ = new bbop.rest.manager.jquery_faux_ajax();
    try{ // some interpreters might not like this kind of probing
    	if( typeof(jQuery) !== 'undefined' ){
    	    //JQ = jQuery;
    	    anchor.JQ = jQuery.noConflict();
    	}
    }catch (x){
    }finally{
    	var got = bbop.core.what_is(anchor.JQ);
    	if( got && got == 'bbop.rest.manager.jquery_faux_ajax'){
    	}else{
    	    got = 'jQuery';
    	}
    	//ll('Using ' + got + ' for ajax calls.');
    }
};
bbop.core.extend(bbop.rest.manager.jquery, bbop.rest.manager);

/*
 * Function: use_jsonp
 *
 * Set the jQuery engine to use JSONP handling instead of the default
 * JSON. If set, the callback function to use will be given my the
 * argument "json.wrf" (like Solr), so consider that special.
 * 
 * Parameters: 
 *  use_p - *[optional]* external setter for 
 *
 * Returns:
 *  boolean
 */
bbop.rest.manager.jquery.prototype.use_jsonp = function(use_p){
    var anchor = this;
    if( bbop.core.is_defined(use_p) ){
	if( use_p == true || use_p == false ){
	    anchor._use_jsonp = use_p;
	}
    }
    return anchor._use_jsonp;
};

/*
 * Function: jsonp_callback
 *
 * Get/set the jQuery jsonp callback string to something other than
 * "json.wrf".
 * 
 * Parameters: 
 *  cstring - *[optional]* setter string
 *
 * Returns:
 *  string
 */
bbop.rest.manager.jquery.prototype.jsonp_callback = function(cstring){
    var anchor = this;
    if( bbop.core.is_defined(cstring) ){
	anchor._jsonp_callback = cstring;
    }
    return anchor._jsonp_callback;
};

/*
 * Function: headers
 *
 * Try and control the server with the headers.
 * 
 * Parameters: 
 *  header_set - *[optional]* hash of headers; jQuery internal default
 *
 * Returns:
 *  hash of headers
 */
bbop.rest.manager.jquery.prototype.headers = function(header_set){
    var anchor = this;
    if( bbop.core.is_defined(header_set) ){
	anchor._headers = header_set;
    }
    return anchor._headers;
};

/*
 * Function: update
 *
 *  See the documentation in <manager.js> on update to get more
 *  of the story. This override function adds functionality for
 *  jQuery.
 * 
 * Parameters: 
 *  callback_type - callback type string (so far unused)
 *
 * Returns:
 *  the query url (with the jQuery callback specific parameters)
 */
bbop.rest.manager.jquery.prototype.update = function(callback_type){

    var anchor = this;
    
    // Assemble request.
    // Conditional merging of the remaining variant parts.
    var qurl = this.resource();
    var args = '';
    if( ! bbop.core.is_empty(this.payload()) ){
	var asm = bbop.core.get_assemble(this.payload());
	args = '?' + asm;
    }
    var final_url = qurl + args;

    // The base jQuery Ajax args we need with the setup we have.
    var jq_vars = {
    	url: final_url,
    	dataType: 'json',
	headers: { "Content-Type": "application/javascript", "Accept": "application/javascript" },
    	type: "GET"
    };

    // If we're going to use JSONP instead of the defaults, set that now.
    if( anchor.use_jsonp() ){
	jq_vars['dataType'] = 'jsonp';
	jq_vars['jsonp'] = anchor._jsonp_callback;
    }
    if( anchor.headers() ){
    	jq_vars['headers'] = anchor.headers();
    }

    // What to do if an error is triggered.
    // Remember that with jQuery, when using JSONP, there is no error.
    function on_error(xhr, status, error) {
	var response = new anchor._response_handler(null);
	response.okay(false);
	response.message(error);
	response.message_type(status);
	anchor.apply_callbacks('error', [response, anchor]);
    }

    function on_success(raw_data, status, xhr){
	var response = new anchor._response_handler(raw_data);
	if( response && response.okay() ){
	    anchor.apply_callbacks('success', [response, anchor]);
	}else{
	    // Make sure that there is something there to
	    // hold on to.
	    if( ! response ){
		response = new anchor._response_handler(null);
		response.okay(false);
		response.message_type(status);
		response.message('null response');
	    }else{
		response.message_type(status);
		response.message('bad response');
	    }
	    //anchor.apply_callbacks('error', [response, anchor]);
	    //anchor.apply_callbacks('error', [raw_data, anchor]);
	    anchor.apply_callbacks('error', [response, anchor]);
	}
    }

    // Setup JSONP for Solr and jQuery ajax-specific parameters.
    jq_vars['success'] = on_success;
    jq_vars['error'] = on_error;
    //done: _callback_type_decider, // decide & run search or reset
    //fail: _run_error_callbacks, // run error callbacks
    //always: function(){} // do I need this?
    anchor.JQ.ajax(jq_vars);
    //anchor.JQ.ajax(final_url, jq_vars);
    
    return final_url;
};

/*
 * Namespace: bbop.rest.manager.jquery_faux_ajax
 *
 * Constructor: faux_ajax
 * 
 * Contructor for a fake and inactive Ajax. Used by bbop.rest.manager.jquery
 * in (testing) environments where jQuery is not available.
 * 
 * Returns:
 *  faux_ajax object
 */
bbop.rest.manager.jquery_faux_ajax = function (){
    this._is_a = 'bbop.rest.manager.jquery_faux_ajax';

    /*
     * Function: ajax
     *
     * Fake call to jQuery's ajax.
     *
     * Parameters: 
     *  args - whatever
     *
     * Returns:
     *  null
     */
    this.ajax = function(args){
	return null;
    };
};
/* 
 * Package: conf.js
 * 
 * Generic BBOP manager for dealing with gross GOlr configuration
 * and management.
 * 
 * Contains <bbop.golr.conf_field>, <bbop.golr.conf_class>, and
 * <bbop.golr.conf>.
 * 
 * TODO: better document all of this. Essentially, this is all for
 * getting data out of a JSONized version of the YAML files used to
 * drive the OWLTools-Solr parts of GOlr.
 */

// Module and namespace checking.
if( typeof bbop == "undefined" ){ var bbop = {}; }
if( typeof bbop.golr == "undefined" ){ bbop.golr = {}; }

/*
 * Namespace: bbop.golr.conf_field
 * 
 * Constructor: conf_field
 * 
 * Contructor for a GOlr search field.
 * 
 * Arguments:
 *  field_conf_struct - JSONized config
 * 
 * Returns:
 *  conf_field object
 */
bbop.golr.conf_field = function (field_conf_struct){
    this._is_a = 'bbop.golr.conf_field';

    // Get a good self-reference point.
    var anchor = this;

    // Per-manager logger.
    var logger = new bbop.logger(this._is_a);
    logger.DEBUG = true;
    function ll(str){ logger.kvetch(str); }

    // Capture search fields.
    this._field = field_conf_struct;

    /*
     * Function: display_name
     * 
     * The user-facing display name. Suitable for label or title
     * somewhere.
     * 
     * Returns:
     *  Display name string.
     */
    this.display_name = function(){
	return this._field['display_name'];
    };

    /*
     * Function: description
     * 
     * A longer description. Suitable for tooltips.
     * 
     * Returns:
     *  Description string.
     */
    this.description = function(){
	return this._field['description'];
    };

    /*
     * Function: id
     * 
     * The unique ID of this profile.
     * 
     * Returns:
     *  String.
     */
    this.id = function(){
	return this._field['id'];
    };

    /*
     * Function: searchable
     * 
     * Returns whether or not a string field has a shadow
     * "*_searchable" field defined that is suitable for dismax
     * searches. Defaults to false.
     * 
     * Returns:
     *  boolean
     */
    this.searchable = function(){
	var retval = false;
	if( this._field['searchable'] == 'true' ||
	    this._field['searchable'] == true ){
		retval = true;	
	    }
	return retval;
    };

    /*
     * Function: required
     * 
     * Returns whether or not this field is required. Defaults to
     * false.
     * 
     * Not of particular use.
     * 
     * Returns:
     *  Boolean.
     */
    this.required = function(){
	var retval = false;
	if( this._field['required'] == 'true' ||
	    this._field['required'] == true ){
		retval = true;	
	    }
	return retval;
    };

    /*
     * Function: is_multi
     * 
     * Using the "cardinality" entry, returns whether or not this
     * field is "single" (false) or "multi" (true). Defaults to false.
     * 
     * Returns:
     *  Boolean.
     */
    this.is_multi = function(){
	var retval = false;
	if( this._field['cardinality'] == 'multi' ){
	    retval = true;	
	}
	return retval;
    };

    /*
     * Function: is_fixed
     * 
     * Using the "property_type" entry, returns whether or not this
     * field is "dynamic" (false) or "fixed" (true). Defaults to false.
     * 
     * Not of particular use.
     * 
     * Returns:
     *  Boolean.
     */
    this.is_fixed = function(){
	var retval = false;
	if( this._field['property_type'] == 'fixed' ){
	    retval = true;	
	}
	return retval;
    };

    /*
     * Function: property
     * 
     * Returns the method of this field's generation in the loader.
     * 
     * Not of particular use.
     * 
     * Returns:
     *  String.
     */
    this.property = function(){
	var retval = '???';
	if( this._field['property'] ){
	    retval = this._field['property'];
	}
	return retval;
    };

    // TODO: ...
};

/*
 * Namespace: bbop.golr.conf_class
 *
 * Constructor: conf_class
 * 
 * Contructor for a GOlr search class.
 * 
 * Arguments:
 *  class_conf_struct - JSONized config
 * 
 * Returns:
 *  conf_class object
 */
bbop.golr.conf_class = function (class_conf_struct){
    this._is_a = 'bbop.golr.conf_class';

    // Get a good self-reference point.
    var anchor = this;

    // Per-manager logger.
    var logger = new bbop.logger(this._is_a);
    logger.DEBUG = true;
    function ll(str){ logger.kvetch(str); }

    // Capture class and the component fields into variables.
    this._class = class_conf_struct;
    // this._fields = {};
    // bbop.core.each(this._class['fields'],
    // 		   function(item, index){
    // 		       var sf = new bbop.golr.conf_field(item);
    // 		       anchor._fields[sf.id()] = sf;
    // 		  });

    /*
     * Function: display_name
     * 
     * The user-facing display name. Suitable for label or title
     * somewhere.
     * 
     * Returns:
     *  Display name string.
     */
    this.display_name = function(){
	return this._class['display_name'];
    };

    /*
     * Function: description
     * 
     * A longer description. Suitable for tooltips.
     * 
     * Returns:
     *  Description string.
     */
    this.description = function(){
	return this._class['description'];
    };

    /*
     * Function: weight
     * 
     * The relative weight of this search class.
     * 
     * Returns:
     *  Integer.
     */
    this.weight = function(){
    	return parseInt(this._class['weight']) || 0;
    };

    /*
     * Function: id
     * 
     * The unique ID of this profile.
     * 
     * Returns:
     *  String.
     */
    this.id = function(){
	return this._class['id'];
    };

    /*
     * Function: document_category
     * 
     * The document category that this personality is meant to work
     * with. Otherwise, returns the class id.
     * 
     * Returns:
     *  String.
     */
    this.document_category = function(){
	return this._class['document_category'] || this.id();
    };

    /*
     * Function: searchable_extension
     * 
     * This returns the searchable extension used for this
     * class. There is a typical default, but it might be change in
     * namespace collisions, so it's better to just use this.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     * string
     */
    this.searchable_extension = function(){
    	//return this._class['searchable_extension'] || '_searchable';
    	return '_searchable';
    };

    /*
     * Function: get_field
     * 
     * Returns a search field by id string. Null otherwise.
     * 
     * Parameters:
     *  fid - a string id for the field
     * 
     * Returns:
     *  <bbop.golr.conf_field>
     */
    this.get_field = function(fid){
	var retval = null;
	if( this._class.fields_hash &&
	    this._class.fields_hash[fid] ){
		retval = new bbop.golr.conf_field(this._class.fields_hash[fid]);
	    }
	return retval;
    };

    /*
     * Function: get_fields
     * 
     * Return all of the fields in this search class.
     * 
     * Returns:
     *  Array of <bbop.golr.conf_field> (unordered).
     */
    this.get_fields = function(){
	var retval = [];
	if( this._class.fields_hash ){
	    bbop.core.each(this._class.fields_hash,
			   function(fid, struct){
			       var cf = new bbop.golr.conf_field(struct);
			       retval.push(cf);
			   });
	}
	return retval;
    };

    // Internal function to determine if the weight category that's
    // used by several functions is okay.
    this._munge_weight_category = function(weight_category){

	// Not defined or only the defined few.
	if( ! weight_category ){
	    throw new Error("Missing weight category");	
	}else if( weight_category != 'boost' &&
	    weight_category != 'result' &&
	    weight_category != 'filter' ){
	    throw new Error("Unknown weight category: " + weight_category);
	}

	return weight_category + '_weights';
    };

    /*
     * Function: get_weights
     * 
     * Get the various weights we need to run.
     * 
     * The weight category can be 'boost', 'result', or 'filter'.
     * 
     * Arguments:
     *  weight_category - string identifying the legal weight category
     * 
     * Returns:
     *  object of {field => weight, ...}
     */
    this.get_weights = function(weight_category){
	
	var rethash = {};

	// Only the defined few.
	weight_category = this._munge_weight_category(weight_category);

	// Collect the good bits.
	if( ! bbop.core.is_defined(this._class[weight_category]) ){
	    throw new Error("Missing weight category: " + weight_category);
	}else{
	    // Only work it if there is something there more than "".
	    var wcs = this._class[weight_category];
	    if( wcs && wcs != "" && wcs != " " ){
		var dfab = wcs;
		var fields = dfab.split(/\s+/);
		bbop.core.each(fields,
			       function(item, i){
				   var field_val = item.split(/\^/);
				   rethash[field_val[0]] =
				       parseFloat(field_val[1]);
			       });
	    }
	}

	return rethash;
    };

    /*
     * Function: field_order_by_weight
     * 
     * Returns an array of field ids ordered by weight.
     * 
     * The weight category can be 'boost', 'result', or 'filter'.
     * 
     * Arguments:
     * weight_category - string identifying the legal weight category
     * cutoff - *[optional]* if not defined, all listed fields in set returned
     * 
     * Returns:
     *  array like [field5, field4, ...]
     */
    this.field_order_by_weight = function(weight_category, cutoff){

    	var retset = [];

	var weights = this.get_weights(weight_category);

	// Add the ones that meet threshold (if there is one) to the
	// set.
	bbop.core.each(weights,
		       function(key, val){
			   if( cutoff ){
			       if( val >= cutoff ){
				   retset.push(key);			       
			       }
			   }else{
			       retset.push(key);			       
			   }
		      });

	// Order the set.
	retset.sort(function(a, b){
			return weights[b] - weights[a];
		    });

    	return retset;
    };
};

/*
 * Namespace: bbop.golr.conf
 *
 * Constructor: conf
 * 
 * Contructor for the GOlr query manager.
 * Why don't we just take bbop.golr.golr_meta as read? We want to
 * leave the door open to having multiple GOlrs running in the same area.
 * 
 * Arguments:
 *  golr_conf_var - JSized GOlr config
 * 
 * Returns:
 *  golr conf object
 * 
 */
bbop.golr.conf = function (golr_conf_var){
    this._is_a = 'bbop.golr.conf';

    // Get a good self-reference point.
    var anchor = this;

    // Per-manager logger.
    var logger = new bbop.logger(this._is_a);
    logger.DEBUG = true;
    function ll(str){ logger.kvetch(str); }

    // Lightly check incoming arguments.
    // There could be a hash of pinned filters argument.
    if( ! golr_conf_var || typeof golr_conf_var != 'object' ){
	ll('ERROR: no proper golr conf var argument');
    }
    
    // Settle in the conf.
    this._golr_conf = golr_conf_var;

    // Process the conf classes into one spot.
    this._classes = {};
    bbop.core.each(anchor._golr_conf,
		  function(key, val){
		      var new_asp = new bbop.golr.conf_class(val);
		      anchor._classes[new_asp.id()] = new_asp;
		  });

    /*
     * Function: get_class
     * 
     * Returns a class info object by id string. Null otherwise.
     * 
     * Arguments:
     *  fid - TODO
     * 
     * Returns:
     *  bbop.golr.conf_class.
     */
    this.get_class = function(fid){
	var retval = null;
	if( this._classes &&
	    this._classes[fid] ){
		retval = this._classes[fid];
	    }
	return retval;
    };

    /*
     * Function: get_classes
     * 
     * Returns an array of all search classes.
     * 
     * Returns:
     *  Array of <bbop.golr.conf_class> (unordered).
     */
    this.get_classes = function(){
	var ret = [];
	bbop.core.each(anchor._classes,
		       function(key, val){
			   ret.push(val);
		       });
	return ret;
    };

    /*
     * Function: get_classes_by_weight
     * 
     * Returns an array of all search classes. Ordered by weight.
     * 
     * Returns:
     *  Array of <bbop.golr.conf_class>.
     */
    this.get_classes_by_weight = function(){
	var ret = this.get_classes();

	ret.sort(
	    function(cc1, cc2){
		var w1 = cc1.weight() || 0;
		var w2 = cc2.weight() || 0;
		return w2 - w1;
	    });

	return ret;
    };
};
/* 
 * Package: response.js
 * 
 * Namespace: bbop.golr.response
 * 
 * Generic BBOP handler for dealing with the gross parsing of
 * responses from a GOlr server (whereas <golr_conf> deals with the
 * reported configuration). This is not intended to do anything like
 * modeling the data in the store (<golr_manager>), but rather to deal
 * with things like checking for success, what paging would look like,
 * what parameters were passed, etc.
 */

// Module and namespace checking.
if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.golr == "undefined" ){ bbop.golr = {}; }

/*
 * Constructor: response
 * 
 * Contructor for a GOlr query response object.
 * 
 * The constructor argument is an object, not a string.
 * 
 * Arguments:
 *  json_data - the JSON data (as object) returned from a request
 * 
 * Returns:
 *  golr response object
 */
bbop.golr.response = function(json_data){
    this._is_a = 'bbop.golr.response';

    // The raw incoming document.
    this._raw = json_data;

    // Cache for repeated calls to success().
    this._success = null;

    // Cache for repeated calls to get_doc* functions.
    // These are non-incremental indices--they are either full formed
    // (the first time they are hit) or they are null.
    this._doc_id2index = null;
    this._doc_index2_id = null;

    // Cache for repeated calls to resolve labels.
    // This cache is incremental--the more it's used the larger it gets.
    this._doc_label_maps = {}; // {<field_1>: <parsed_json_map_1>, ...}

    // For highlight stripping, I just want to compile this once.
    this._hl_regexp = new RegExp("\<\[\^\>\]\*\>", "g");

};

/*
 * Function: raw
 * 
 * returns a pointer to the initial response object
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  object
 */
bbop.golr.response.prototype.raw = function(){
    return this._raw;
};

/*
 * Function: success
 * 
 * Simple return verification of sane response from server.
 * 
 * Success caches its return value.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  boolean
 */
bbop.golr.response.prototype.success = function(){

    if( this._success == null ){

	var robj = this._raw;
	if( robj &&
	    robj.responseHeader &&
	    typeof robj.responseHeader.status != 'undefined' &&
	    robj.responseHeader.status == 0 &&
	    robj.responseHeader.params &&
	    robj.response &&
	    typeof robj.response.numFound != 'undefined' &&
	    typeof robj.response.start != 'undefined' &&
	    typeof robj.response.maxScore != 'undefined' &&
	    robj.response.docs &&
	    robj.facet_counts &&
	    robj.facet_counts.facet_fields ){
		this._success = true;
	    }else{
		this._success = false;
	    }
    }

    return this._success;
};

/*
 * Function: callback_type
 * 
 * Return the callback type if it was specified in the query,
 * otherwise return null. For example "reset" and "response".
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  string (or null)
 */
bbop.golr.response.prototype.callback_type = function(){
    var robj = this._raw;
    var retval = null;
    if( robj.responseHeader.params.callback_type &&
	typeof robj.responseHeader.params.callback_type != 'undefined' ){
	    retval = robj.responseHeader.params.callback_type;
	}
    return retval;
};

/*
 * Function: parameters
 * 
 * Get the parameter chunk--variable stuff we put in.
 * 
 * Pretty general, specialized functions are better.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  hash
 */
bbop.golr.response.prototype.parameters = function(){
    var robj = this._raw;
    return robj.responseHeader.params;
};

/*
 * Function: parameter
 * 
 * Get the parameter chunk--variable stuff we put in.
 * 
 * Pretty general, specialized functions are better.
 * 
 * Arguments:
 *  n/a
 *  key - string id for the wanted parameter
 * 
 * Returns:
 *  hash, string, whatever is there at that key (otherwise null)
 */
bbop.golr.response.prototype.parameter = function(key){
    var robj = this._raw;
    var retval = null;
    if( robj.responseHeader.params[key] && robj.responseHeader.params[key] ){
	retval = robj.responseHeader.params[key];
    }
    return retval;
};

/*
 * Function: row_step
 * 
 * Returns the number of rows requested (integer).
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  integer
 */
bbop.golr.response.prototype.row_step = function(){	
    var robj = this._raw;
    return parseInt(robj.responseHeader.params.rows);
};

/*
 * Function: total_documents
 * 
 * Return the total number of documents found.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  integer
 */
bbop.golr.response.prototype.total_documents = function(){
    var robj = this._raw;
    return parseInt(robj.response.numFound);
};

/*
 * Function: start_document
 * 
 * Returns the start document for this response as an integer.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  integer
 */
bbop.golr.response.prototype.start_document = function(){
    var robj = this._raw;
    return parseInt(robj.response.start) + 1;
};

/*
 * Function: end_document
 * 
 * Returns the end document for this response as an integer.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  integer
 */
bbop.golr.response.prototype.end_document = function(){
    var robj = this._raw;
    return this.start_document() +
	parseInt(robj.response.docs.length) - 1;
};

/*
 * Function: packet
 * 
 * Return the packet number of the current response.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  integer or null (no packet defined)
 */
bbop.golr.response.prototype.packet = function(){
    var robj = this._raw;
    var retval = null;
    var pval = robj.responseHeader.params.packet;
    if( pval ){
	retval = parseInt(pval);
    }
    return retval;
};

/*
 * Function: paging_p
 * 
 * Whether or not paging is necessary with the given results set.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  boolean
 */
bbop.golr.response.prototype.paging_p = function(){
    var robj = this._raw;
    var retval = false;
    if( this.total_documents() > this.row_step() ){
	retval = true;
    }
    return retval;
};

/*
 * Function: paging_previous_p
 * 
 * Whether or paging backwards is an option right now.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  boolean
 */
bbop.golr.response.prototype.paging_previous_p = function(){
    // We'll take this as a proxy that a step was taken.
    // Remember: we offset the start_document by one for readability.
    var robj = this._raw;
    var retval = false;
    if( this.start_document() > 1 ){
	retval = true;
    }
    return retval;
};

/*
 * Function: paging_next_p
 * 
 * Whether or paging forwards is an option right now.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  boolean
 */
bbop.golr.response.prototype.paging_next_p = function(){
    // We'll take this as a proxy that a step was taken.
    var robj = this._raw;
    var retval = false;
    if( this.total_documents() > this.end_document() ){
	retval = true;	
    }
    return retval;
};

/*
 * Function: documents
 * 
 * Returns an array of raw and unprocessed document hashes.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  hash
 */
bbop.golr.response.prototype.documents = function(){
    var robj = this._raw;
    return robj.response.docs;
};

/*
 * Function: get_doc
 * 
 * Returns a specified document, in its raw hash form.
 * 
 * Arguments:
 *  doc_id - document identifier either an id (first) or place in the array
 * 
 * Returns:
 *  document hash or null
 */
bbop.golr.response.prototype.get_doc = function(doc_id){

    var doc = null;
    var robj = this._raw;

    // First check if the document is available by position.
    var docs = robj.response.docs;
    if( docs && docs[doc_id] ){
	doc = docs[doc_id];
    }else{ // Not available by position, so lets see if we can get it by id.
	
	//print('in: ' + doc_id + ' _' + this._doc_id2index);

	// Build the doc index if it isn't there.
	var local_anchor = this;
	if( ! this._doc_id2index ){
	    //print('BUILD triggered on: ' + doc_id);
	    this._doc_id2index = {};
	    this._doc_index2id = {};
	    bbop.core.each(docs,
			   function(doc_item, doc_index){
			       var did = doc_item['id'];
			       //print('BUILD: ' + did + ' => ' + doc_index);
			       local_anchor._doc_id2index[did] = doc_index;
			       local_anchor._doc_index2id[doc_index] = did;
			   });
	}
	
	//print('pre-probe: ' + doc_id + ' _' + this._doc_id2index);

	// Try and probe it out.
	if( this._doc_id2index &&
	    bbop.core.is_defined(this._doc_id2index[doc_id]) ){
	    //print('PROBE: ' + doc_id);
	    var doc_i = this._doc_id2index[doc_id];
	    doc = docs[doc_i];
	}
    }

    return doc;
};

/*
 * Function: get_doc_field
 * 
 * Returns the value(s) of the requested fields.
 * 
 * Remember that determining whether the returned value is a string or
 * a list is left as an exercise for the reader when using this
 * function.
 * 
 * Arguments:
 *  doc_id - document identifier either an id (first) or place in the array
 *  field_id - the identifier of the field we're trying to pull
 * 
 * Returns:
 *  value or list of values
 */
bbop.golr.response.prototype.get_doc_field = function(doc_id, field_id){

    var ret = null;

    // If we found our doc, go ahead and start looking for the field.
    var doc = this.get_doc(doc_id);
    if( doc && bbop.core.is_defined(doc[field_id]) ){
	
	// We have an answer with this.
	ret = doc[field_id];
    }

    return ret;
};

/*
 * Function: get_doc_label
 * 
 * Tries to return a label for a document, field, and id combination.
 * 
 * WARNING: This function could be potentially slow on large datasets.
 * 
 * Arguments:
 *  doc_id - document identifier either an id (first) or place in the array
 *  field_id - the identifier of the field we're trying to pull
 *  item_id - *[optional]* the item identifier that we're trying to resolve; if the field in question is a string or a single-valued list (as opposed to a multi-values list), this argument is not necessary, but it wouldn't hurt either
 * 
 * Returns:
 *  null (not found) or string
 */
bbop.golr.response.prototype.get_doc_label = function(doc_id,field_id,item_id){

    var retval = null;

    var anchor = this;

    // If we found our doc, and confirmed that the field in question
    // exists in the doc, go ahead and start digging to resolve the id.
    var doc = this.get_doc(doc_id);
    if( doc && bbop.core.is_defined(doc[field_id]) ){
	
	// First try the '_label' extension.
	var ilabel = this.get_doc_field(doc_id, field_id + '_label');

	if( ilabel && bbop.core.what_is(ilabel) == 'string' ){
	    // It looks like the simple solution.
	    //print('trivial hit');
	    retval = ilabel; // Hit!
	}else if( ilabel && bbop.core.what_is(ilabel) == 'array' ){
	    
	    // Well, it's multi-valued, but id might just be the one.
	    var iid = this.get_doc_field(doc_id, field_id);
	    if( ilabel.length == 1 && iid &&
		bbop.core.what_is(iid) == 'array' &&
		iid.length == 1 ){
		    // Case of a single id trivially mapping to a
		    // single label.
		    //print('forced hit');
		    retval = ilabel[0]; // Hit!
	    }else{

		//print('need to probe');

		// Since we'll do this twice with different map
		// fields, a generic function to try and probe a JSON
		// string map (caching it along the way) for a label.
		function _map_to_try(doc_key, map_field, item_key){

		    var retlbl = null;

		    var map_str = anchor.get_doc_field(doc_key, map_field);

		    if( map_str && bbop.core.what_is(map_str) == 'string' ){

			// First, check the cache. If it's not there
			// add it.
			if( ! bbop.core.is_defined(anchor._doc_label_maps[doc_key]) ){
			    anchor._doc_label_maps[doc_key] = {};
			}
			if( ! bbop.core.is_defined(anchor._doc_label_maps[doc_key][map_field]) ){
			    // It looks like a map wasn't defined, so let's
			    // convert it into JSON now.
			    anchor._doc_label_maps[doc_key][map_field] =
				bbop.json.parse(map_str);
			}

			// Pull our map out of the cache.
			var map = anchor._doc_label_maps[doc_key][map_field];

			// Probe to see if we have anything in the map.
			if( map && map[item_key] ){
			    retlbl = map[item_key];
			}
		    }

		    return retlbl;
		}

		// Well, now we know that either we have to find a map
		// or the information isn't there. First try the
		// standard "_map".
		var mlabel = _map_to_try(doc_id, field_id + '_map', item_id);
		if( mlabel ){
		    //print('map hit');
		    retval = mlabel; // Hit!
		}else{
		    // If that didn't work, try again with
		    // "_closure_map".
		    var cmlabel =
			_map_to_try(doc_id, field_id + '_closure_map', item_id);
		    if( cmlabel ){
			//print('closure map hit');
			retval = cmlabel; // Hit!
		    }else{
			// If that didn't work, try again with
			// "_list_map".
			var lmlabel =
			    _map_to_try(doc_id, field_id +'_list_map', item_id);
			if( lmlabel ){
			    //print('list map hit');
			    retval = lmlabel; // Hit!
			}
		    }
		}
	    }
	}
    }

    return retval;
};

/*
 * Function: get_doc_highlight
 * 
 * Returns the highlighted value(s) of the requested fields.
 * 
 * WARNING: This function is a work in progress and will not return
 * multi-valued fields, just the first match it finds.
 * 
 * WARNING: This function could be potentially slow on large datasets.
 * 
 * Arguments:
 *  doc_id - document id
 *  field_id - the identifier of the field we're trying to pull
 *  item - the item that we're looking for the highlighted HTML for
 * 
 * Returns:
 *  string of highlight or null if nothing was found
 */
bbop.golr.response.prototype.get_doc_highlight = function(doc_id,field_id,item){

    var ret = null;
    var robj = this._raw;
    var hlre = this._hl_regexp;

    // See if we can find a highlighted version in the raw
    // response. First, see if the document is in the hilight section;
    // otherwise try and pull the id out first, then head for the
    // highlight section.
    var hilite_obj = null;
    if( robj.highlighting && robj.highlighting[doc_id] ){
	hilite_obj = robj.highlighting[doc_id];
    }else{
	var iid = this._doc_index2id[doc_id];
	if( iid ){
	    var new_doc = this.get_doc(iid);
	    var new_doc_id = new_doc['id'];
	    if( robj.highlighting && robj.highlighting[new_doc_id] ){
		hilite_obj = robj.highlighting[new_doc_id];
	    }
	}
    }

    // If we got a highlight object, see if the highlighted field is
    // there--search the different possibilities for what a highlight
    // field may be called.
    if( hilite_obj ){
	
	//print('here (field_id): ' + field_id);

	var ans = null;

	if( hilite_obj[field_id + '_label_searchable'] ){
	    ans = hilite_obj[field_id + '_label_searchable'];
	}

	if( ! ans ){
	    if( hilite_obj[field_id + '_label'] ){
		ans = hilite_obj[field_id + '_label'];
	    }	    
	}

	if( ! ans ){
	    if( hilite_obj[field_id + '_searchable'] ){
		ans = hilite_obj[field_id + '_searchable'];
	    }
	}

	if( ! ans ){
	    if( hilite_obj[field_id] ){
		//print('here (field_id): ' + field_id);
		ans = hilite_obj[field_id];
	    }
	}

	if( ans ){ // looks like I found a list of something

	    // Use only the first match.
	    var matches_p = false;
	    bbop.core.each(ans,
			   function(an){
			       if( ! matches_p ){
				   var stripped = an.replace(hlre, '');
				   //print('stripped: ' + stripped);
				   //print('item: ' + item);
				   if( item == stripped ){
				       matches_p = true;
				       ret = an;
				   }
			       }
			   });
	}
    }

    return ret;
};

// /*
//  * Function: facet_fields
//  * 
//  * Return a count sorted array of the response's facet fields and counts.
//  * 
//  * Arguments:
//  *  n/a
//  * 
//  * Returns:
//  *  list of string/integer doublets
//  */
// bbop.golr.response.prototype.facet_fields = function(){
//     var robj = this._raw;
//     return robj.facet_counts.facet_fields;
// };

/*
 * Function: facet_field_list
 * 
 * Return a count sorted array of the response's facet fields.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  list of strings
 */
bbop.golr.response.prototype.facet_field_list = function(){
    var robj = this._raw;
    return bbop.core.get_keys(robj.facet_counts.facet_fields).sort();
};

/*
 * Function: facet_field
 * 
 * Return a count-sorted array of a facet field's response.
 * 
 * : [["foo", 60], ...]
 * 
 * Arguments:
 *  facet_name - name of the facet to examine
 * 
 * Returns:
 *  list of nested lists
 */
bbop.golr.response.prototype.facet_field = function(facet_name){
    var robj = this._raw;
    return robj.facet_counts.facet_fields[facet_name];
};

/*
 * Function: facet_counts
 * 
 * For a given facet field, return a hash of that field's items and
 * their counts.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  hash of facets to their integer counts
 */
bbop.golr.response.prototype.facet_counts = function(){

    var robj = this._raw;
    var ret_hash = {};

    var anchor = this;
    
    var each = bbop.core.each;
    var facet_field_list = this.facet_field_list();
    each(facet_field_list,
	 function(ffield){
	     
	     // Make sure the top field is present,
	     if( ! ret_hash[ffield] ){
		 ret_hash[ffield] = {};		
	     }

	     var facet_field_items = anchor.facet_field(ffield);
	     each(facet_field_items,
		  function(item, index){
		      var name = item[0];
		      var count = item[1];
		      ret_hash[ffield][name] = count;
		  });
	 });
    
    return ret_hash;
};

/*
 * Function: query
 * 
 * Return the raw query parameter "q".
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  string or null
 */
bbop.golr.response.prototype.query = function(){
    var robj = this._raw;    
    var retval = null;
    
    if( robj.responseHeader.params && robj.responseHeader.params.q ){
	retval = robj.responseHeader.params.q;
    }
    
    return retval;
};

/*
 * Function: query_filters
 *
 * A sensible handling of the not-so-great format of "fq" returned by
 * Solr (fq can be irritating single value or irritating array, along
 * with things like "-" in front of values). Since plus and minus
 * filters are mutually exclusive, we have a return format like:
 * 
 * : {field1: {filter1: (true|false), ...}, ...}
 * 
 * Where the true|false value represents a positive (true) or negative
 * (false) filter.
 * 
 * Parameters:
 *  n/a
 *
 * Returns:
 *  a hash of keyed hashes
 */
bbop.golr.response.prototype.query_filters = function(){
    var robj = this._raw;    
    var ret_hash = {};
    var fq_list = this.parameter('fq');
    if( fq_list ){
	
	// Ensure that it's a list and not just a naked string (as can
	// sometimes happen).
	if( bbop.core.what_is(fq_list) == 'string'){
	    fq_list = [fq_list];
	}
	
	// Make the return fq more tolerable.
	var each = bbop.core.each;
	each(fq_list,
	     function(fq_item){
		 
		 // Split everything on colons. Field is the first
		 // one, and everything else joined back together is
		 // the value of the filter. Best if you think about
		 // the GO id and non-GO id cases.
		 var splits = fq_item.split(":");
		 var field = splits.shift();
		 var value = splits.join(":"); // GO 0022008 -> GO:0022008

		 // First let's just assume that we have a positive
		 // filter.
		 var polarity = true;
		 
		 // Check and see if the first value in our
		 // field is '-' or '+'. If so, edit it out, but
		 // change the polarity in the '-' case.
		 if( field.charAt(0) == '-' ){
		     polarity = false;
		     field = field.substring(1, field.length);
		 }else if( field.charAt(0) == '+' ){
		     field = field.substring(1, field.length);
		 }

		 // Ensure that there is a place in the return hash
		 // for us.
		 if( ! ret_hash[field] ){
		     ret_hash[field] = {};
		 }
		 
		 // I want just the first quote and the final quote
		 // gone from the value if they are matching quotes.
		 if( value.charAt(0) == '"' &&
		     value.charAt(value.length -1) == '"' ){
			 value = value.substring(1, value.length -1);
		     }
		 
		 // The final filter note.
		 ret_hash[field][value] = polarity;
		 
	     });
    }
    
    return ret_hash;
};
/* 
 * Package: manager.js
 * 
 * Namespace: bbop.golr.manager
 * 
 * Generic BBOP manager for dealing with gross GOlr configuration and
 * management. Remember, this is actually a "subclass" of
 * <bbop.registry>. The defined events for this registry are: "reset",
 * "search", and "error".
 * 
 *  reset - functions for initializing and resetting
 *  search - functions for receiving standard search results
 *  error - functions to call when something goes very wrong
 * 
 * Both <bbop.golr.response> (or clean error data) and the manager
 * itself (this as anchor) should be passed to the callbacks.
 * 
 * TODO/BUG: <set_query> and <set_default_query> should both take
 * strings or <bbop.logic> as arguments. Those, as well as <get_query>
 * and <get_query> should only return <bbop.logic>.
 */

// Module and namespace checking.
if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.golr == "undefined" ){ bbop.golr = {}; }

/*
 * Constructor: manager
 * 
 * Contructor for the GOlr query manager
 * 
 * Arguments:
 *  golr_loc - string url to GOlr server;
 *  golr_conf_obj - a <bbop.golr.conf> object
 * 
 * Returns:
 *  golr manager object
 * 
 * See also:
 *  <bbop.registry>
 */
bbop.golr.manager = function (golr_loc, golr_conf_obj){
    //bbop.registry.call(this, ['reset', 'search', 'error']);
    bbop.registry.call(this, ['prerun', 'reset', 'search', 'error', 'postrun']);
    this._is_a = 'bbop.golr.manager';

    // Get a good self-reference point.
    var anchor = this;

    // Per-manager logger.
    this._logger = new bbop.logger(this._is_a);
    //this._logger.DEBUG = true;
    this._logger.DEBUG = false;
    function ll(str){ anchor._logger.kvetch(str); }

    // Just want to compile these once.
    var alphanum = new RegExp(/^[a-zA-Z0-9 ]+$/);

    // To help keep requests from the past haunting us. Actually doing
    // something with this number is up to the UI.
    this.last_sent_packet = 0;
    //this.last_received_packet = 0;

    // Lightly check incoming arguments.
    // There should be a string url argument.
    // There could be a hash of pinned filters argument.
    if( ! golr_loc || ! golr_conf_obj ){
	ll('ERROR: no proper arguments');
    }
    if( typeof golr_loc != 'string' ){
	ll('ERROR: no proper golr url string argument');
    }
    if(	! golr_conf_obj._is_a || ! golr_conf_obj._is_a == 'bbop.golr.conf' ){
	    ll('ERROR: no proper bbop.golr.conf object argument');
	    throw new Error('boink! ' + bbop.core.what_is(golr_conf_obj) );
	}
    
    // Whether or not to prevent ajax events from going.
    // This may not be usable, or applicable, to all backends.
    this._safety = false;

    // Our default target url.
    this._solr_url = golr_loc;

    // Settle in the configurations.
    // this._golr_conf = new bbop.golr.conf(golr_conf_var);
    this._golr_conf = golr_conf_obj;

    // The current data batches that we are storing.
    this._batch_urls = [];
    this._batch_accumulator_func = function(){};
    this._batch_final_func = function(){};

    // The current state stack.
    this._excursions = [];

    // The current class/personality that we're using. It may be none.
    this._current_class = null;

    // Our (default) query and the real deal.
    this.fundamental_query = '*:*'; // cannot be changed
    this.default_query = '*:*'; // changable
    this.query = this.default_query; // current

    // Our (default) fl and whatever we have now.
    //this.default_fl = '*%2Cscore';
    this.default_fl = '*,score';
    this.current_fl = this.default_fl;

    // We remember defaults in the case of rows and start since they
    // are the core to any paging mechanisms and may change often.
    //this.default_rows = 25;
    //this.default_rows = 100;
    this.default_rows = 10;
    this.default_start = 0;
    this.current_rows = this.default_rows;
    this.current_start = this.default_start;

    // There is a reason for this...TODO: later (25+)
    this.default_facet_limit = 25;
    this.current_facet_limit = 25;
    // {facet_field_name: value, ...}
    this.current_facet_field_limits = {};
    // TODO: paging for facets;
    this.current_facet_offset = 25;
    this.current_facet_field_offsets = {};

    // Our default query args, with facet fields plugged in.
    this.query_variants =
	{
	    // Our default standard search type. This means we don't
	    // have to explicitly add fields to the search (although
	    // the query fields ('qf') are still necessary to make
	    // anything real happen).
	    defType: 'edismax',

	    // Things unlikely to be touched.
	    // There are unlikely to be messed with too much.
	    qt: 'standard',
	    indent: 'on',
	    wt: 'json',
	    //version: '2.2',
	    rows: anchor.current_rows,
	    start: anchor.current_start, // Solr is offset indexing
	    //fl: '*%2Cscore',
	    fl: anchor.default_fl,
    
	    // Deprecated: see query_filters
	    //fq: {},
	    
	    // Deprecated: see query_fields
	    //qf: {},
	    
	    // Deprecated: see query
	    //q: '*:*'

	    // Control of facets.
	    facet: 'true',
	    'facet.mincount': 1,
	    'facet.sort': 'count',
	    'json.nl': 'arrarr', // only in facets right now
	    'facet.limit': anchor.default_facet_limit
	    // TODO?: 'f.???.facet.limit': 50,
	    // TODO: 'json.nl': [flat|map|arrarr]

	    // Deprecated: see facet_fields
	    //'facet.field': []
	};

    // This is the 'qf' parameter. Although we keep it, it only needs
    // to be exposed when the query ('q') field is set.
    //this.query_fields = [];
    this.query_fields = {};

    // A richer way to handle the 'fq' query variant.
    // It should look like:
    // {<filter>: {<value>:{'sticky_p':(t|f), 'negative_p':(t|f)}, ...}}
    this.query_filters = {};

    // The engine for the facet.field list.
    this.facet_fields = {};

    /*
     * Function: debug
     * 
     * Turn on or off the verbose messages. Uses <bbop.logger>, so
     * they should come out everywhere.
     * 
     * Parameters: 
     *  p - *[optional]* true or false for debugging
     *
     * Returns: 
     *  boolean; the current state of debugging
     */
    this.debug = function(p){
	if( p == true || p == false ){
	    this._logger.DEBUG = p;
	    // TODO: add debug parameter a la include_highlighting
	}
	return this._logger.DEBUG;
    };

    /*
     * Function: lite
     * 
     * Limit the returns fields (the parameter "fl") to the ones
     * defined in the set of fields defined in results, label fields
     * if available (i.e. "_label", "_map" when "_label" is
     * multi=valued), and "score" and "id".
     * 
     * The default is "false".
     * 
     * Parameters: 
     *  use_lite_p - *[optional]* true or false, none just returns current
     *
     * Returns: 
     *  boolean; the current state of lite-ness
     */
    this.lite = function(use_lite_p){

	// Adjust the current state accordingly.
	if( use_lite_p == true || use_lite_p == false ){
	    if( use_lite_p == true ){
		
		// The actual collections and adjustment.
		// First, this only works if we have a personality, so
		// check to see if we have one.
		var per = anchor.get_personality();
		if( per ){
		    // Since we have a personality, collect all of the
		    // mentioned fields.
		    var field_collection = {};
		    var loop = bbop.core.each;
		    var union = bbop.core.merge;
		    var ccl = anchor._current_class;

		    // Fill field_collection with the fields
		    // in the given category.
		    //loop(['boost', 'result', 'filter'],
		    //loop(['result', 'filter'],
		    loop(['result'],
			 function(cat){
			     field_collection = 
				 union(field_collection, ccl.get_weights(cat));
			 });
		    
		    // Next, flatten into a list.
		    var flist = bbop.core.get_keys(field_collection);

		    // Now for all the fields in these categories, see
		    // if we can find additional "special" labels to
		    // go with them.
		    loop(flist,
		    	 function(flist_item){
			     loop(['_label'],
			     //loop(['_label', '_label_searchable'],
		    		   function(field_suffix){
				       var new_field = 
					   flist_item + field_suffix;
				       var nf_obj = ccl.get_field(new_field);
				       if( nf_obj ){
					   flist.push(new_field);

					   // There appears to be the
					   // thing label. If they are
					   // both multi-valued, then
					   // there will be a map as
					   // well.
					   if( nf_obj.is_multi() ){
					       flist.push(flist_item + '_map');
					   }
				       }
				   });
			 });


		    // Finally, set these fields (plus score) as the
		    // new return fields.
		    flist.push('score');
		    flist.push('id');
		    //anchor.current_fl = flist.join('%2C');
		    anchor.current_fl = flist.join(',');
		    anchor.set('fl', anchor.current_fl);
		}

	    }else{ // else false
		// Reset.
		anchor.current_fl = anchor.default_fl;
		anchor.set('fl', anchor.current_fl);
	    }
	}

	// Return the current state.
	var retval = false;
	if( anchor.default_fl != anchor.current_fl ){
	    retval = true;
	}
	return retval;
    };

    // An internal helper function to munge the name of a field into
    // the name of its corresponding facet field.
    function _field_to_facet_field(field){
	return 'f.' + field + '.facet.limit';
    }
    
    /*
     * Function: get_facet_limit
     * 
     * Get the limit for a specified facet or the global limit.
     * 
     * Parameters: 
     *  field - *[optional]* limit for a specific field; otherwise global value
     *
     * Returns: 
     *  integer or null
     */
    this.get_facet_limit = function(field){
	var retval = null;

	if( ! field ){
	    retval = anchor.current_facet_limit;
	}else{
	    var f = _field_to_facet_field(field);
	    var try_val = anchor.current_facet_field_limits[f];
	    if( bbop.core.is_defined(try_val) ){
		retval = try_val;
	    }
	}

	return retval;
    };

    /*
     * Function: set_facet_limit
     * 
     * Change the number of facet values returned per call.
     * The default is likely 25.
     * 
     * Just as in Solr, a -1 argument is how to indicate unlimted
     * facet returns.
     * 
     * This setting does not survive things like <resets_facet_limit>.
     * 
     * Parameters: 
     *  arg1 - (integer) set the global limit
     *
     * Parameters: 
     *  arg1 - (string) the name of the field to check
     *  arg2 - (integer) set the limit for this field
     *
     * Returns: 
     *  boolean on whether something was set
     */
    this.set_facet_limit = function(arg1, arg2){
	var retval = false;

	// Decide which form of the function we're using.
	if( ! bbop.core.is_defined(arg2) && 
	    bbop.core.what_is(arg1) == 'number' ){ // form one
		
		// Set
		var nlimit = arg1;
		anchor.current_facet_limit = nlimit;
		anchor.set('facet.limit', anchor.current_facet_limit);
		
		retval = true;
	
	}else if( bbop.core.is_defined(arg1) && 
		  bbop.core.is_defined(arg2) &&
		  bbop.core.what_is(arg1) == 'string' &&
		  bbop.core.what_is(arg2) == 'number' ){
		      
		      var field = _field_to_facet_field(arg1);
		      var limit = arg2;
		      anchor.current_facet_field_limits[field] = limit;
		      
		      retval = true;
	}

	return retval;
    };

    /*
     * Function: set_default_facet_limit
     * 
     * Permanently change the default number of facet values returned
     * per call. The default's default is likely 25.
     * 
     * Just as in Solr, a -1 argument is how to indicate unlimted
     * facet returns.
     * 
     * Parameters: 
     *  lim - (integer) set the global default limit
     *
     * Returns: 
     *  old default
     */
    this.set_default_facet_limit = function(lim){

	// Capture ret.
	var retval = anchor.default_facet_limit;

	// Set
	anchor.default_facet_limit = lim;
	//anchor.set('facet.limit', anchor.default_facet_limit);
		
	return retval;
    };

    /*
     * Function: reset_facet_limit
     * 
     * Either reset the global limit to the original (likely 25)
     * and/or remove the specified filter. Sets everything back to the
     * original values or whatever was set by
     * <set_default_facet_limit>.
     * 
     * Parameters: 
     *  field - *[optional]* remove limit for a field; otherwise all and global
     *
     * Returns: 
     *  boolean on whether something was reset
     */
    this.reset_facet_limit = function(field){
	var retval = false;

	if( ! bbop.core.is_defined(field) ){
	    // Eliminate all fields by blowing them away.
	    anchor.current_facet_limit = anchor.default_facet_limit;
	    anchor.set('facet.limit', anchor.current_facet_limit);
	    anchor.current_facet_field_limits = {};
	    retval = true;
	}else{ // eliminate just the one field
	    var f = _field_to_facet_field(field);
	    if( bbop.core.is_defined(anchor.current_facet_field_limits[f]) ){
		delete anchor.current_facet_field_limits[f];
		retval = true;
	    }
	}

	return retval;
    };

    /*
     * Function: get_results_count
     * 
     * Get the current number of results that will be returned.
     * 
     * Parameters: 
     *  n/a
     *
     * Returns: 
     *  integer
     */
    this.get_results_count = function(field){
	return anchor.get('rows');
    };

    /*
     * Function: set_results_count
     * 
     * Change the number of result documents returned per call.
     * The default is likely 10.
     * 
     * Parameters: 
     *  count - (integer) set the global results count
     *
     * Returns:
     *  the count set
     */
    this.set_results_count = function(count){
	anchor.set('rows', count);
	anchor.current_rows = count;
	return anchor.current_rows;
    };

    /*
     * Function: reset_results_count
     * 
     * Reset the number of documents to their original setting, likely
     * 10.
     * 
     * Parameters: 
     *  n/a
     *
     * Returns:
     *  the new count
     */
    this.reset_results_count = function(){
	anchor.set('rows', anchor.default_rows);
	anchor.current_rows = anchor.default_rows;
	return anchor.current_rows;
    };

    /*
     * Function: plist_to_property_hash
     *
     * Turn a plist to a hash containing the different properties that
     * can be defined for a query filter. Possible values are: '+'
     * (positive filter), '-' (negative filter), '*' (sticky filter),
     * '$' (transient). If mutually exclusive properties are defined
     * (e.g. both '+' and '-'), the last one will be used. Or, since
     * that is a call to silliness, let's say the behavior is
     * undefined.
     *
     * Parameters: 
     *  plist - *[optional]* a list of properties to apply to the filter
     *
     * Returns: 
     *  A hash version of the plist; otherwise, the default property hash
     */
    this.plist_to_property_hash = function(plist){

	// Let's start with the default values.
	var phash = {
	    //'positive_p': true,
	    'negative_p': false,
	    //'transient_p': true
	    'sticky_p': false
	};

	// If not defined, just return the default list.
	if( plist ){	    
	    bbop.core.each(plist,
			   function(item){
			       if( item == '+' ){
				   phash['negative_p'] = false;
				   //phash['positive_p'] = true;
			       }else if( item == '-' ){
				   phash['negative_p'] = true;
				   //phash['positive_p'] = false;
			       }else if( item == '*' ){
				   phash['sticky_p'] = true;
				   //phash['transient_p'] = false;
			       }else if( item == '$' ){
				   phash['sticky_p'] = false;
				   //phash['transient_p'] = true;
			       }
			   });
	}

	return phash;
    };

    /*
     * Function: add_query_filter_as_string
     *
     * Setter for query filters ('fq'). Acts as a 
     *
     * Parameters: 
     *  filter_string - filter (type) string (e.g. "-type:gene")
     *  plist - *[optional]* list of properties of the filter
     *
     * Returns: 
     *  (TODO) The current query filter hash.
     * 
     * See also:
     *  <add_query_filter>
     */
    this.add_query_filter_as_string = function(filter_string, plist){
	
	// Split the incoming filter string into its component parts.
	var f_v = bbop.core.first_split(':', filter_string);
	var fname = f_v[0];
	var fval = f_v[1];

	// Need to shuck the value from the quotes, as in load_url.
	fval = bbop.core.dequote(fval);

	//var props = plist || ['$'];
	var props = plist;

	// Only continue on sensible inputs.
	var ret = {};
	if( fname != '' && fval != '' ){

	    // Similar to the URL loader.
	    var lead_char = fname.charAt(0);
	    if( lead_char == '-' || lead_char == '+' ){
		props.push(lead_char);
		fname = fname.substr(1, fname.length -1);
	    }
	    
	    ret = this.add_query_filter(fname, fval, props);
	}

	return ret;
    };

    /*
     * Function: add_query_filter
     *
     * Setter for query filters ('fq').
     *
     * Parameters: 
     *  filter - filter (type) string
     *  value - filter value string (or TODO: defined logic hash)
     *  plist - *[optional]* list of properties of the filter
     *
     * Returns: 
     *  (TODO) The current query filter hash.
     * 
     * See also:
     *  <plist_to_property_hash>
     */
    this.add_query_filter = function(filter, value, plist){
	
	// Make sure we've defined the group.
	if( ! bbop.core.is_defined(this.query_filters[filter]) ){
	    this.query_filters[filter] = {};
	}

	this.query_filters[filter][value] = this.plist_to_property_hash(plist);
	
	//ll("Current state: " + bbop.core.dump(this.query_filters));

	return {}; // TODO
    };

    /*
     * Function: remove_query_filter
     *
     * Remover for query filters ('fq'), is a plist is specified, it
     * will only remove if all of the listed criteria are met.
     *
     * Parameters: 
     *  filter - filter (type) string
     *  value - filter value string (TODO: or defined logic hash)
     *  plist - *[optional]* list of properties of the filter
     *
     * Returns: 
     *  boolean (on success)
     */
    this.remove_query_filter = function(filter, value, plist){

	// Default return value.
	var retval = false;

	// Internal helper to delete a low level key, and then if the
	// top-level is empty, get that one too.
	function _full_delete(hash, key1, key2){
	    if( key1 && key2 && hash &&
		hash[key1] && hash[key1][key2] ){
		    delete hash[key1][key2];
		}
	    if( bbop.core.is_empty(hash[key1]) ){
		delete hash[key1];
	    }
	}

	// If we have a filter, a value, and it's there...
	if( filter && value &&
	    anchor.query_filters[filter] &&
	    anchor.query_filters[filter][value] ){

		// If no real plist hash been defined, just go ahead
		// and get rid of that. Otherwise, make sure that the
		// defined plist and the stored properties are the
		// same before deleting.
		if( ! plist || bbop.core.is_empty(plist) ){
		    _full_delete(anchor.query_filters, filter, value);
		    retval = true;
		}else{
		    
		    var filter_phash = anchor.query_filters[filter][value];
		    var in_phash = anchor.plist_to_property_hash(plist);
		    
		    if( bbop.core.is_same(filter_phash, in_phash) ){		
			_full_delete(anchor.query_filters, filter, value);
			retval = true;
		    }
		}
	    }

	return retval;
    };

    /*
     * Function: reset_query_filters
     *
     * Reset the query filters ('fq'); but leave sticky filters alone.
     *
     * Parameters: 
     *  n/a
     * 
     * Returns: 
     *  (TODO) The current query filter hash.
     */
    this.reset_query_filters = function(){

	// Drill down and delete all non-stickies.
	var loop = bbop.core.each;
	loop(anchor.query_filters,
	     function(filter, values){
		 //ll('filter: ' + filter);
		 loop(values,
		      function(value, props){
			  //ll('  value: ' + value);
			  var sticky_p = props['sticky_p'];
			  if( ! sticky_p ){
			      //ll('hit: ' + filter + ', ' + value);
			      anchor.remove_query_filter(filter, value);
			  }
		      });
	     });

	return {}; // TODO
    };

    /*
     * Function: get_query_filter_properties
     *
     * Get a hash representing a query filter ('fq').
     *
     * Parameters: 
     *  key - filter string (TODO: or defined logic hash)
     *
     * Returns: 
     *  The current query filter hash for key.
     */
    this.get_query_filter_properties = function(filter, value){

	// Default return value.
	var retobj = null;
	
	// If we have a key and it's there...
	var aqf = anchor.query_filters;
	if( filter && value && aqf[filter] && aqf[filter][value] ){
	    retobj =
		{
		    'filter' : filter,
		    'value' : value,
		    //'polarity': aqf[filter][value]['negative_p'],
		    'negative_p': aqf[filter][value]['negative_p'],
		    'sticky_p': aqf[filter][value]['sticky_p']
		};
	}

	return retobj;
    };

    /*
     * Function: get_query_filters
     *
     * Get a list of hashes representing the query filters ('fq'). The
     * return lists look like:
     *
     * : [{'filter': A, 'value': B, 'negative_p': C, 'sticky_p': D}, ...]
     *
     * Where A and B are strings and C and D are booleans.
     * 
     * Parameters: 
     *  n/a
     *
     * Returns: 
     *  A list of the current query filter hashs.
     */
    this.get_query_filters = function(){

	var retlist = [];	
	var loop = bbop.core.each;
	loop(anchor.query_filters,
	     function(f, values){
		 loop(values,
		      function(v, props){
			  retlist.push(anchor.get_query_filter_properties(f,v));
		      });
	     });

	return retlist;
    };

    /*
     * Function: get_sticky_query_filters
     *
     * Get a list of hashes representing the current stucky query
     * filters ('fq'). See <get_query_filters> for a specification of
     * what the return type looks like.
     * 
     * Parameters: 
     *  n/a
     *
     * Returns: 
     *  A list of the current sticky query filter hashs.
     * 
     * See also:
     *  <get_query_filters>
     */
    this.get_sticky_query_filters = function(){

	var retlist = [];	
	var loop = bbop.core.each;
	loop(anchor.query_filters,
	     function(f, values){
		 loop(values,
		      function(v, props){
			  var qfp = anchor.get_query_filter_properties(f,v);
			  if( qfp['sticky_p'] == true ){
			      retlist.push(qfp);			      
			  }
		      });
	     });

	return retlist;
    };

    // A little extra thing that we might need sometimes.
    this.query_extra = null;

    // Spaces can cause problems in URLs in some environments.
    //final_qurl = final_qurl.replace(/ /g, '%20');
    // Convert the URL into something more usable.
    // Because we internally use %09 as a special case, make sure
    // we don't double-up on it.
    this._query_encode = function(str_to_encode){

	var fs1 = encodeURI(str_to_encode);
	var fs2 = fs1.replace(/\%2509/g, '%09');

	var final_encoding = fs2;
	return final_encoding;
    };

    // The callback function called after a successful AJAX
    // intialization/reset call. First it runs some template code,
    // then it does all of the callbacks.
    this._run_reset_callbacks = function(json_data){
	ll('run reset callbacks...');
	var response = new bbop.golr.response(json_data);
	anchor.apply_callbacks('reset', [response, anchor]);
	anchor.apply_callbacks('postrun', [response, anchor]);
    };

    // The main callback function called after a successful AJAX call in
    // the update function.
    this._run_search_callbacks = function(json_data){
	ll('run search callbacks...');
	var response = new bbop.golr.response(json_data);
	anchor.apply_callbacks('search', [response, anchor]);
	anchor.apply_callbacks('postrun', [response, anchor]);
    };

    // This set is called when we run into a problem.
    this._run_error_callbacks = function(json_data){
	ll('run error callbacks...');
	var response = new bbop.golr.response(json_data);
	anchor.apply_callbacks('error', [response, anchor]);
	anchor.apply_callbacks('postrun', [response, anchor]);
    };

    /*
     * Function: filter_list_to_assemble_hash
     *
     * Get all of our query filter variables and try and make
     * something of them that <get_assemble> can understand.
     *
     * Sticky doesn't matter here, but negativity does. However, we
     * can be pretty naive since the hashing should have already taken
     * out mutually exclusive dupes.
     * 
     * The argument is a list of query filter properties, as returned
     * by <get_query_filters> and <get_sticky_query_filters>.
     *
     * Parameters:
     *  flist - a list of query filter properties (see above)
     *
     * Returns:
     *  hash of filter names to value lists
     * 
     * See also:
     *  <get_query_filters>
     *  <get_sticky_query_filters>
     */
    this.filter_list_to_assemble_hash = function(flist){
	var h = {};
	bbop.core.each(flist,
		       function(filter_property){

			   // Grab only the properties that affect the
			   // URL.
			   var filter = filter_property['filter'];
			   var value = filter_property['value'];
			   var negative_p = filter_property['negative_p'];

			   // We need to alter at the filter level.
			   if( negative_p ){
			       filter = '-' + filter;
			   }

			   // Make sure it is defined.
			   if( ! bbop.core.is_defined(h[filter]) ){
			       h[filter] = [];
			   }
			   h[filter].push(value);
		       });
	return h;
    };

    /*
     * Function: sensible_query_p
     * 
     * Simply ask the manager if a free text query ('q') makes sense
     * at this point.
     * 
     * This currently means that the query text ('q') is three (3) or
     * longer and that query fields ('qf') are defined.
     * 
     * This is an overridable opinion of the manager.
     * 
     * Parameters:
     *  n/a
     *
     * Returns:
     *  boolean
     */
    this.sensible_query_p = function(qfs){
	var retval = false;
	var q = anchor.get_query();
	var qf = anchor.query_field_set();
	if( q && q.length >= 3 && qf && ! bbop.core.is_empty(qf) ){
	    retval = true;
	}
	return retval;
    };

    /*
     * Function: last_packet_sent
     *
     * It is up to the UI to do something interesting with this number.
     * 
     * Also remember that this number only rises through calls to
     * <update> or one of its wrappers. Calls to <get_query_url> and
     * the like will not affect this number.
     * 
     * Parameters:
     *  n/a 
     *
     * Returns:
     *  integer
     * 
     * See also:
     *  <update>
     */
    this.last_packet_sent = function(){
    	return anchor.last_sent_packet;
    };

    /*
     * Function: clear
     *
     * Clear all non-sticky query parameters to get back to a more
     * "original" state.
     * 
     * Not to be confused with <reset>.
     * 
     * Parameters: 
     *  n/a
     *
     * Returns:
     *  n/a
     */
    this.clear = function(){

	// Reset 'q'.
	anchor.query = anchor.default_query;

	// Reset 'fq', all but sticky.
	anchor.reset_query_filters();
    };

    /*
     * Function: reset
     *
     * Manually trigger the "reset" chain of events.
     *
     * This is a curried wrapper for <update> and should be preferred
     * over a direct call to update.
     *
     * Note to be confused with <clear>.
     *
     * Returns:
     *  the query url (with the jQuery callback specific parameters)
     * 
     * See also:
     *  <update>
     */
    this.reset = function(){
	return anchor.update('reset');
    };

    /*
     * Function: search
     *
     * Trigger the "search" chain of events.
     * Takes a field-keyed hash of bbop.logics as an argument.
     * 
     * This is a curried wrapper for <update> and should be preferred
     * over a direct call to update.
     * 
     * Parameters:
     *  n/a
     *
     * Returns:
     *  the query url (with the jQuery callback specific parameters)
     * 
     * See also:
     *  <update>
     */
    this.search = function(){
	return anchor.update('search');
    };

    /*
     * Function: page
     *
     * Re-trigger the "search" chain of events, but with the variables
     * set for a different section of the results.
     * 
     * Note that this operates independently of any impossibilites in
     * the results--just how such paging would look and
     * triggering. Ths UI should handle impossibilities and the like.
     * 
     * This is a wrapper for <update> and should be preferred over a
     * direct call to update.
     * 
     * Parameters: 
     *  rows - the number of rows to return
     *  start - the offset of the rows to return
     *
     * Returns:
     *  the query url (with the jQuery callback specific parameters)
     * 
     * See also:
     *  <update>
     */
    this.page = function(rows, start){
	anchor.set('rows', rows);
	anchor.set('start', start);
	return anchor.update('search', rows, start);
    };

    /*
     * Function: page_first
     *
     * Currently a convenience alias for <search>. Think about it--it
     * makes sense.
     * 
     * This is a wrapper for <page> and should be preferred over a
     * direct call to page.
     * 
     * Parameters: 
     *  n/a
     *
     * Returns:
     *  n/a
     * 
     * See also:
     *  <page>
     */
    this.page_first = anchor.search;
    
    /*
     * Function: page_previous
     * 
     * This is a wrapper for <page> and should be preferred over a
     * direct call to page.
     * 
     * Parameters: 
     *  n/a
     *
     * Returns:
     *  the query url (with the jQuery callback specific parameters)
     * 
     * See also:
     *  <page>
     */
    this.page_previous = function(){
	var do_rows = anchor.get_page_rows();
	var do_offset = anchor.get_page_start() - do_rows;
	return anchor.page(do_rows, do_offset);
    };
    
    /*
     * Function: page_next
     * 
     * This is a wrapper for <page> and should be preferred over a
     * direct call to page.
     * 
     * Parameters: 
     *  the query url (with the jQuery callback specific parameters)
     *
     * Returns:
     *  n/a
     * 
     * See also:
     *  <page>
     */
    this.page_next = function(){
	var do_rows = anchor.get_page_rows();
	var do_offset = anchor.get_page_start() + do_rows;
	return anchor.page(do_rows, do_offset);
    };
    
    /*
     * Function: page_last
     * 
     * Trigger search on last page parameters.
     * 
     * Since the manager has no idea about what is actually being
     * returned, the real world number of total documents needs to be
     * added as an argument.
     * 
     * This is a wrapper for <page> and should be preferred over a
     * direct call to page.
     * 
     * Parameters: 
     *  total_document_count - integer for the total number of docs found
     *
     * Returns:
     *  the query url (with the jQuery callback specific parameters)
     * 
     * See also:
     *  <page>
     */
    this.page_last = function(total_document_count){
	var do_rows = anchor.get_page_rows();
	var mod = total_document_count % do_rows;
	var do_offset = total_document_count - mod;
	// ll("page_last: " + total_document_count + " " +
	//    do_rows + " " + mod + " " + do_offset);
	var ret = null;
	if( mod == 0 ){
	    ret = anchor.page(do_rows, do_offset - do_rows);
	}else{
	    ret = anchor.page(do_rows, do_offset);
	}
	return ret;
    };

    /*
     * Function: get_page_rows
     *
     * Return the number of rows the manager is currently set
     * to. Useful as an argument to <page>.
     * 
     * Parameters: 
     *  n/a
     *
     * Returns:
     *  integer; the number of rows the manager is currently set to
     * 
     * See also:
     *  <page>
     */
    this.get_page_rows = function(){
	return anchor.get('rows');
    };

    /*
     * Function: get_page_start
     *
     * Return the rows offset the manager is currently set to. Useful
     * as an argument to <page>.
     * 
     * Parameters: 
     *  n/a
     *
     * Returns:
     *  integer; the offset the manager is currently set to
     * 
     * See also:
     *  <page>
     */
    this.get_page_start = function(){
	return anchor.get('start');
    };

    /*
     * Function: add_query_field
     * 
     * Add a new query field to the query. 
     * 
     * This does not go through and expand into searchable fields, for
     * that see: <query_field_set>.
     *
     * Parameters: 
     *  qf - the query field to add
     *  boost - *[optional]* defaults to 1.0
     *
     * Returns:
     *  true or false on whether or not it is a new field
     * 
     * See also:
     *  <query_field_set>
     */
    this.add_query_field = function(qf, boost){
	
	var retval = false;

	// Make sure that some boost is there.
	if( ! bbop.core.is_defined(boost) ){
	    boost = 1.0;
	}

	// Check.
	if( ! bbop.core.is_defined(anchor.query_fields[qf]) ){
	    retval = true;
	}

	// Add.
	anchor.query_fields[qf] = boost;

	return retval;
    };

    /*
     * Function: query_field_set
     *
     * Bulk getter/setter for the query fields--the fields that are
     * searched (and by what weight) when using a query ('q' or
     * set_query(), i.e. the 'qf' field).
     * 
     * This will always use searchable fields if possible,
     * automatically replacing the non-searchable versions (I can't
     * think of any reason to use non-searchable versions unless you
     * want your searches to not work) if a personality is set. If no
     * personality is set, it will just use the arguments as-is.
     * 
     * The argument replaces the current set.
     *
     * The qfs argument should be a hash like:
     * 
     *  {'field01': value01, ...}
     * 
     * Parameters: 
     *  qfs - *[optional]* query fields to set
     *
     * Returns:
     *  the current query_fields array (e.g. ["field01^value01", ...])
     */
    this.query_field_set = function(qfs){

	// Covenience.
	var loop = bbop.core.each;
	var cclass = anchor._current_class;

	// Only do something if we have a query field set.
	if( qfs ){
	    
	    // Only do the probing if a personality has been set.
	    if( cclass ){

		// Get the current searchable extension string from
		// the personality class.
		//var s_ext = cclass.searchable_extension();
		// Actually, we're going to make this non-variable.
		var s_ext = '_searchable';

		// Probe the input to see if there are any searchable
		// alternatives to try, use those instead.
		var searchable_qfs = {};
		loop(qfs,
	    	     function(filter, value){
			 // If the probe fails, just put in
			 // whatever is there.
			 var cfield = cclass.get_field(filter);
			 if( cfield && cfield.searchable() ){
			     //ll('filter/value:');
			     var new_f = filter + s_ext;
			     searchable_qfs[new_f] = value;
			 }else{
			     searchable_qfs[filter] = value;
			 }
	    	     });
		qfs = searchable_qfs;
	    }	    

	    // Overwrite the current.
	    anchor.query_fields = qfs;
	}
	
	// Using the original information, convert them to the
	// proper output format.
	var output_format = [];
	loop(anchor.query_fields,
	     function(filter, value){
		 output_format.push(filter + '^' + value);
	     });
	return output_format;
    };

    /*
     * Function: facets
     *
     * Bulk getter/setter for facets (technically 'facet.field').
     *
     * Parameters: 
     *  key - *[optional]* facet to add to the facet list
     *
     * Parameters: 
     *  list - *[optional]* list to replace the current list with
     *
     * Returns:
     *  the current facets hash.
     */
    this.facets = function(list_or_key){
	if( list_or_key ){
	    if( bbop.core.what_is(list_or_key) != 'array' ){
		// Arrayify it.
		list_or_key = [list_or_key];
	    }else{
		// When there is a list, we are replacing the whole
		// thing, so let's just poof it out of existance.
		anchor.facet_fields = {};
	    }
	    bbop.core.each(list_or_key,
			   function(item){
			       anchor.facet_fields[item] = true;
			   });
	}
	return bbop.core.get_keys(anchor.facet_fields);
    };

    /*
     * Function: set_default_query
     *
     * Setter for the default query for the query variable ('q').
     * 
     * Call <reset_query> if you want to affect query immediately.
     * 
     * Parameters: 
     *  new_default_query - new default query string (or TODO: <bbop.logic>)
     *
     * Returns:
     *  the current setting of default query for ('q')
     */
    this.set_default_query = function(new_default_query){
	anchor.default_query = new_default_query;
	return anchor.default_query;
    };

    // /*
    //  * Function: set_first_run_query
    //  *
    //  * Setter for a first run query.  Normally, when <reset_query>, or
    //  * related method, is executed, we reset back to the default
    //  * query. This method sets a one time variable so a non empty
    //  * value can be used for the first reset.
    //  * 
    //  * Call <reset_query> if you want to affect query immediately.
    //  * 
    //  * Parameters: 
    //  *  first_run_query - query_string (or TODO: <bbop.logic>)
    //  *
    //  * Returns:
    //  *  the current setting of default query for ('q')
    //  */
    // this.set_first_run_query = function(first_run_query){
    // 	anchor.default_query = new_default_query;
    // 	return anchor.default_query;
    // };

    /*
     * Function: reset_default_query
     *
     * Reset the default query back to "*:*".
     * 
     * Call <reset_query> if you want to affect query immediately.
     * 
     * Parameters:
     *  n/a
     *
     * Returns:
     *  the current setting of default query ('q')
     */
    this.reset_default_query = function(){
	anchor.default_query = anchor.fundamental_query;
	return anchor.default_query;
    };

    /*
     * Function: set_query
     *
     * Setter for the query variable ('q').
     * 
     * Parameters: 
     *  new_query - new value for the query string (or TODO: <bbop.logic>)
     *
     * Returns:
     *  the current setting of query ('q')
     * 
     * Also see:
     *  <set_comfy_query>
     */
    this.set_query = function(new_query){
	anchor.query = new_query;
	return anchor.query;
    };

    /*
     * Function: set_comfy_query
     *
     * A specialized setter for the query variable ('q'), as follows:
     *
     * If the input is all alphanum or space, the input is
     * tokenized. If there is one token, if it is at least three
     * characters, gets a wildcard '*'; if there are more tokens, the
     * last one gets a wild card.
     * 
     * This might be a more comfortable way to search for most naive
     * (non-power user) interfaces.
     * 
     * Parameters: 
     *  new_query - new value for the query string (or TODO: <bbop.logic>)
     *
     * Returns:
     *  the current setting of query ('q')
     * 
     * Also see:
     *  <set_query>
     */
    this.set_comfy_query = function(new_query){

	var comfy_query = new_query;

	// Check that there is something there.
	if( new_query && new_query.length && new_query.length > 0 ){

	    // Check if the last real input has a space after it.
	    var has_cursor_p = true;
	    if( new_query.slice(-1) === ' ' ){
		has_cursor_p = false;
	    }

	    // Now chomp it down again to get rid of whitespace.
	    new_query = bbop.core.chomp(new_query);

	    // Check (again) that there is something there.
	    if( new_query && new_query.length && new_query.length > 0 ){

		// That it is alphanum+space-ish and that we actually
		// might want to add a wildcard (i.e. has cursor).
		if( alphanum.test(new_query) && has_cursor_p ){
	    
		    // Break it into tokens and get the last.
		    var tokens = new_query.split(new RegExp('\\s+'));
		    var last_token = tokens[tokens.length -1];
		    //ll('last: ' + last_token);
		
		    if( tokens.length == 1 ){
			
			// If it is three or more, add the wildcard.
			if( last_token.length >= 3 ){
			    tokens[tokens.length -1] = last_token + '*';
			}
		    }else{
			tokens[tokens.length -1] = last_token + '*';
		    }
		    // And join it all back into our comfy query.
		    comfy_query = tokens.join(' ');
		}
	    }
	}

	// Kick it back to the normal set_query.
	return anchor.set_query(comfy_query);
    };

    /*
     * Function: set_id
     *
     * A limited setter, removing whatever else is on query. This is
     * for when you want to lock into one (unique) document by id
     * (essentially 'q=id:"foo"'). All other query operations behave
     * as they should around it.
     * 
     * Parameters: 
     *  new_id - string id
     *
     * Returns:
     *  the current setting of query ('q')
     * 
     * Also see:
     *  <set_ids>
     */
    this.set_id = function(new_id){
	anchor.query = 'id:' + bbop.core.ensure(new_id, '"');
	return anchor.query;
    };

    // Function to unwind and lock a list if identifiers onto a field.
    function _lock_map(field, id_list){
	var fixed_list = [];
	bbop.core.each(id_list,
		       function(item){
			   fixed_list.push(bbop.core.ensure(item, '"'));
		       });

	var base_id_list = '(' + fixed_list.join(' OR ') + ')';

	var ret_query = field + ':' + base_id_list;
	return ret_query;
	
    }

    /*
     * Function: set_ids
     *
     * Like <set_id>, a limited setter. It removes whatever else is on
     * query and replaces it with something like:
     * 
     * : gm.set_ids(['GO:1', 'GO:2'])
     * 
     * This is for when you want to lock into a set of documents by id. All
     * other query operations behave as they should around it.
     * 
     * Parameters: 
     *  id_list - a list of ids to search for
     *
     * Returns:
     *  the current setting of query ('q')
     * 
     * Also see:
     *  <set_ids>
     */
    this.set_ids = function(id_list){
	anchor.query = _lock_map('id', id_list);
	return anchor.query;
    };

    /*
     * Function: set_targets
     *
     * Like a more generalized version of <set_ids>, a limited. It
     * removes whatever else is on query and replaces it with
     * something like:
     * 
     * : gm.set_targets(['GO:1', 'GO:2'], ['field_1', 'field_2'])
     * 
     * This is for when you want to lock into a set of documents by
     * locking onto identifiers in some set of search fields. All
     * other query operations behave as they should around it.
     * 
     * Parameters: 
     *  id_list - a list of ids to search for
     *  field_list - a list of fields ids to search across
     *
     * Returns:
     *  the current setting of query ('q')
     * 
     * Also see:
     *  <set_ids>
     */
    this.set_targets = function(id_list, field_list){

	var fixed_list = [];
	bbop.core.each(field_list, function(field){
	    fixed_list.push(_lock_map(field, id_list));
	});

	var sum = fixed_list.join(' OR ');

	anchor.query = sum;
	return anchor.query;
    };

    /*
     * Function: get_query
     *
     * Getter for the query variable ('q').
     * 
     * Parameters: 
     *  n/a
     *
     * Returns:
     *  the current setting of extra
     */
    this.get_query = function(){
	return anchor.query;
    };

    /*
     * Function: get_default_query
     *
     * Getter for what the query variable 'q' will be set to on a
     * <reset_query>.
     * 
     * Parameters: 
     *  n/a
     *
     * Returns:
     *  the current setting of the default query
     */
    this.get_default_query = function(){
	return anchor.default_query;
    };

    /*
     * Function: get_fundamental_query
     *
     * Getter for what the query variable 'q' will be set to on a
     * <reset_default_query>.
     * 
     * Parameters: 
     *  n/a
     *
     * Returns:
     *  the current setting of the fundamental default query
     */
    this.get_fundamental_query = function(){
	return anchor.fundamental_query;
    };

    /*
     * Function: get_query
     *
     * Getter for the query variable ('q').
     * 
     * Parameters: 
     *  n/a
     *
     * Returns:
     *  the current setting of extra
     */
    this.get_query = function(){
	return anchor.query;
    };

    /*
     * Function: reset_query
     *
     * Remove/reset the query variable ('q'); this set it back to the
     * default query.
     *
     * Parameters:
     *  none
     *
     * Returns:
     *  the current value of query
     * 
     * Also see:
     *  <set_default_query>
     *  <reset_default_query>
     */
    this.reset_query = function(){
	anchor.query = anchor.default_query;
	ll('reset query to default: ' + anchor.query);
	return anchor.query;
    };

    /*
     * Function: set_extra
     *
     * Setter for the internal string variable to be appended to the
     * end of a query. For special use cases only (e.g. extend
     * functionality of the API safely).
     * 
     * Parameters: 
     *  new_extra - *[optional]* new value for the extras string
     *
     * Returns:
     *  the current setting of extra
     */
    this.set_extra = function(new_extra){
	anchor.query_extra = new_extra;
	return anchor.query_extra;
    };

    /*
     * Function: get_extra
     *
     * Getter for the internal string variable to be appended
     * to the end of a query.
     *
     * Parameters: 
     *  n/a
     *
     * Returns:
     *  the current setting of extra
     */
    this.get_extra = anchor.set_extra;

    /*
     * Function: remove_extra
     *
     * Remove/reset the extra bit.
     *
     * Parameters:
     *  none
     *
     * Returns:
     *  ""
     */
    this.remove_extra = function(){
	anchor.query_extra = "";
	return anchor.query_extra;
    };

    /*
     * Function: set
     *
     * Set an internal variable for the query. The internal variables
     * are typically things like 'qt', 'indent', etc.--things that you
     * might set and forget a while. It does /not/ include highly
     * dynamic variables (like callback and packet) or querying
     * variables like 'q' and 'fq'; for those you need to use the API.
     *
     * Parameters: 
     *  key - the name of the parameter to change
     *  new_val - what you want the new value to be
     *
     * Returns:
     *  n/a
     */
    this.set = function(key, new_val){
	anchor.query_variants[key] = new_val;
    };

    /*
     * Function: get
     *
     * Get an internal variable for the query.
     *
     * See <set> for the kinds of parameters that can be read.
     * 
     * Parameters: 
     *  key - the name of the parameter to get
     *
     * Returns:
     *  The found value of the key.
     */
    this.get = function(key){
	return anchor.query_variants[key];
    };

    /*
     * Function: unset
     *
     * Unset (remove) an internal variable for the query. Only usable on certain types of 
     * 
     * Only use is you really know what you're doing.
     *
     * Parameters: 
     *  key - the name of the parameter to unset/remove
     *
     * Returns:
     *  boolean; true false on whether the key was found
     */
    this.unset = function(key){
	var retval = false;

	if( bbop.core.is_defined(anchor.query_variants[key]) ){
	    retval = true;
	    delete anchor.query_variants[key];
	}

	return retval;
    };

    /*
     * Function: include_highlighting
     *
     * Turn hilighting on or off (with true or false).
     * 
     * This essentially adds the parameters to the query string to
     * make sure that basic highlighting on the search is returned.
     * 
     * It starts off as false. The optional html_elt_str argument
     * defaults to:
     *  : <em class="hilite">
     *
     * Parameters: 
     *  hilite_p - *[optional]* boolean
     *  html_elt_str - *[serially optional]* the HTML element string to use
     *
     * Returns:
     *  either false or the current string being used for the return element
     */
    this.include_highlighting = function(hilite_p, html_elt_str){
	var retval = false;

	if( bbop.core.is_defined(hilite_p) &&
	    (hilite_p == true || hilite_p == false) ){
	    if( hilite_p == true ){

		// Set the default string if necessary.
		if( ! html_elt_str ){ html_elt_str = '<em class="hilite">'; }

		// Set the parameters.
		anchor.set('hl', 'true');
		anchor.set('hl.simple.pre', html_elt_str);

		// And the retval is not longer false.
		retval = html_elt_str;

	    }else{
		
		// Unset the parameters.
		anchor.unset('hl');
		anchor.unset('hl.simple.pre');
	    }

	}else{
	    // Otherwise, just discover the current state and return
	    // it.
	    var cl_tmp = anchor.get('hl.simple.pre');
	    if( bbop.core.is_defined(cl_tmp) ){
		retval = cl_tmp;
	    }
	}

	return retval;
    };

    /*
     * Function: set_personality
     *
     * While we are always contacting the same Solr instance, we
     * sometimes want to have different weights, facets, etc. This
     * function allows us to use the pre-set ones defined in the
     * constructor configuration argument.
     * 
     * Currently, this only sets the 'facet.field' internal variable.
     *
     * Parameters: 
     *  personality_id - string
     *
     * Returns:
     *  Will return false if personality doesn't exist
     */
    this.set_personality = function(personality_id){
	var retval = false;

	// This sets the facet.field internal variable.
	var cclass = anchor._golr_conf.get_class(personality_id);
	if( cclass ){

	    // Remember what our personality is.
	    // WARNING: this line must go before the query_field_set
	    // line below, or else we won't get the "smart" search.
	    this._current_class = cclass;

	    // Set the facets for our class.
	    anchor.facets(cclass.field_order_by_weight('filter'));

	    // Set the query field weights ('qf') necessary to make
	    // queries run properly.
	    anchor.query_field_set(cclass.get_weights('boost'));
	    
	    // Show that we did indeed set a personality.
	    retval = true;
	}

	return retval;
    };

    /*
     * Function: get_personality
     *
     * Returns the current personality, null if none.
     * 
     * Parameters: 
     *  n/a
     *
     * Returns:
     *  Returns the current personality as a string, null if none is set
     */
    this.get_personality = function(){
	var retval = null;

	if( bbop.core.is_defined(anchor._current_class) &&
	    bbop.core.what_is(anchor._current_class) == 'bbop.golr.conf_class'){
	    retval = anchor._current_class.id();
	}

	return retval;
    };

    /*
     * Function: get_query_url
     *
     * Get the current invariant state of the manager returned as a
     * encoded URL string (using encodeURI()).
     * 
     * This means the URL for the current query to the GOlr store, but
     * without extra information about packets, callbacks, and the
     * like.
     * 
     * This is generally appropriate for getting data, but maybe not
     * for things like high-speed autocomplete where races can
     * occur. For those, you might want to consider <update> or
     * <search>.
     *
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  URL string
     * 
     * Also see:
     *  <update>, <search>
     */
    this.get_query_url = function(){

	// Structure of the necessary invariant parts.	
	var qurl = anchor._solr_url + 'select?';

	// Filters to assemble.
	var assemf = anchor.get_query_filters();
	var fq = anchor.filter_list_to_assemble_hash(assemf);

	// Add all of our different specialized hashes.
	var things_to_add = [
	    //bbop.core.get_assemble(anchor.query_invariants),
	    //bbop.core.get_assemble(anchor.query_facets),
	    bbop.core.get_assemble(anchor.query_variants),
	    bbop.core.get_assemble(anchor.current_facet_field_limits),
	    //bbop.core.get_assemble({'fq': anchor.query_sticky_filters}),
	    bbop.core.get_assemble({'fq': fq}),
	    bbop.core.get_assemble({'facet.field':
				    bbop.core.get_keys(anchor.facet_fields)}),
	    bbop.core.get_assemble({'q': anchor.query}),
	    anchor.query_extra
	];
	// Add query_fields ('qf') iff query ('q') is set and it is
	// not length 0.
	if( anchor.query &&
	    anchor.query.length &&
	    anchor.query.length != 0 &&
	    anchor.query != anchor.fundamental_query ){
		var in_qf =
		    bbop.core.get_assemble({'qf': anchor.query_field_set()});
		things_to_add.push(in_qf);
	    }
	
	// Assemble the assemblies into a single URL, throw out
	// everything that seems like it isn't real to keep the URL as
	// clean a possible.
	var filtered_things = 
	    bbop.core.pare(things_to_add,
			   function(item, index){
			       var retval = true;
			       if( item && item != '' ){
				   retval = false;
			       }
			       return retval;
			   });

	var final_qurl = qurl + filtered_things.join('&');
	final_qurl = anchor._query_encode(final_qurl);
	ll('qurl: ' + final_qurl);
    	return final_qurl;
    };

    /*
     * Function: push_excursion
     *
     * Save the current state of the manager--data and sticky filter
     * information--onto an internal stack. Batch information is not
     * stored.
     * 
     * Useful for gettinginto a state, doing something else, then
     * returning to the original state.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  the number of items on the excursion stack
     * 
     * Also see:
     *  <get_query_url>
     *  <pop_excursion>
     */
    this.push_excursion = function(){
	
	var now = {
	    // Save current state (data).
	    data_url: anchor.get_query_url(),
	    // Save current state (session).
	    session: {
		// Get the sticky filters.
		sticky_filters: anchor.get_sticky_query_filters()
	    }
	};

	// Save.
	anchor._excursions.push(now);

	// ...
    	return anchor._excursions.length;
    };

    /*
     * Function: pop_excursion
     *
     * Return to a previously pushed state. Batch items are not
     * recovered.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  boolean on whether a state was recovered
     * 
     * Also see:
     *  <get_query_url>
     *  <gpush_excursion>
     */
    this.pop_excursion = function(){
	
	var retval = false;

	var then = anchor._excursions.pop();
	if( then ){
	    retval = true;

	    // Recover data state.
	    var then_data_url = then['data_url'];
	    anchor.load_url(then_data_url);

	    // Recover the session state.
	    var then_session_stickies = then['session']['sticky_filters'];
	    // Add the sticky filters.
	    bbop.core.each(then_session_stickies,
			   function(sticky){
			       var flt = sticky['filter'];
			       var fvl = sticky['value'];
			       var fpl = [];
			       if( sticky['negative_p'] == true ){
				   fpl.push('-');
			       }
			       if( sticky['sticky_p'] == true ){
				   fpl.push('*');
			       }
			       anchor.add_query_filter(flt, fvl, fpl);
			   });	    
	}

    	return retval;
    };

    /*
     * Function: get_download_url
     *
     * Get the current invariant state of the manager returned as a
     * URL string.
     * 
     * This differs from <get_query_url> in that the generated string
     * is intended for text-processing uses rather than computerized
     * searching uses. The idea where is to create a TSV file for
     * downloading and consumption.
     * 
     * Instead of downloading all of the results, a limited listed set
     * can be downloaded using entity_list, which identifies documents by id.
     * 
     * The optional argument hash looks like:
     *  rows - the number of rows to return; defaults to: 1000
     *  encapsulator - how to enclose whitespace fields; defaults to: ""
     *  separator - separator between fields; defaults to: "%09" (tab)
     *  header - whether or not to show headers; defaults to: "false"
     *  mv_separator - separator for multi-valued fields; defaults to: "|"
     *  entity_list - list of specific download items in results; default null
     * 
     * With the entity list, keep in mind that null and an empty list
     * are handled in pretty much the same way--they are an indication
     * that we are going after nothing specific, and so all results
     * are game.
     * 
     * Parameters:
     *  field_list - a list of fields to return
     *  in_arg_hash - *[optional]* additional optional arguments
     * 
     * Returns:
     *  URL string
     * 
     * Also see:
     *  <get_query_url>
     */
    this.get_download_url = function(field_list, in_arg_hash){
	
	// Save current state.
	anchor.push_excursion();

	// Deal with getting arguments in properly.
	var default_hash =
	    {
		rows : 1000,
		encapsulator : '',
		separator : "%09",
		header : 'false',
		mv_separator : "|",
		entity_list : []
	    };
	var arg_hash = bbop.core.fold(default_hash, in_arg_hash);

	// Make the changes we want.
	anchor.set('wt', 'csv');
	anchor.set('start', 0);
	anchor.set('fl', field_list.join(','));
	anchor.set('rows', arg_hash['rows']);
	anchor.set('csv.encapsulator', arg_hash['encapsulator']);
	anchor.set('csv.separator', arg_hash['separator']);
	anchor.set('csv.header', arg_hash['header']);
	anchor.set('csv.mv.separator', arg_hash['mv_separator']);

	// A little more tricky, jimmy the entity list into the query
	// if it's viable.
	var entity_list = arg_hash['entity_list'];
	if( bbop.core.is_defined(entity_list) &&
	    bbop.core.is_array(entity_list) &&
	    entity_list.length > 0 ){
		anchor.set_ids(entity_list);
	}

	// Get url.
	var returl = anchor.get_query_url();

	// Reset the old state.
	anchor.pop_excursion();

    	return returl;
    };

    /*
     * Function: get_filter_query_string
     *
     * Get the current state of the manager, as defined by the current
     * gross filter set--query, sticky filters, and standard filters--
     * returned as a URL query string (sans the '?').
     * 
     * This differs from <get_query_url> and <get_state_url> in that
     * the generated string is intended for applications that may want
     * just enough information to recover filter state when the
     * personality, and other types of information, are already
     * known. It is intended to be part of a light RESTy bookmarking
     * mechanism in larger application.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  query string for current filters (sans the '?')
     * 
     * Also see:
     *  <get_query_url>
     *  <get_state_url>
     */
    this.get_filter_query_string = function(){
	
	// // Save current state.
	// anchor.push_excursion();

	var q = anchor.get_query();

	// Get the filters and sort them into sticky and "normal"
	// sets.
	var filters = anchor.get_query_filters();
	var std_filters = [];
	var sticky_filters = [];
	bbop.core.each(filters,
		       function(filter){
			   if( filter['sticky_p'] ){
			       sticky_filters.push(filter);
			   }else{
			       std_filters.push(filter);
			   }
		       });

	var fq = anchor.filter_list_to_assemble_hash(std_filters);
	var sfq = anchor.filter_list_to_assemble_hash(sticky_filters);

	var things_to_add = [];
	if( q ){
	    things_to_add.push(bbop.core.get_assemble({'q': q}));
	}
	if( ! bbop.core.is_empty(fq) ){
	    things_to_add.push(bbop.core.get_assemble({'fq': fq}));
	}
	if( ! bbop.core.is_empty(sfq) ){
	    things_to_add.push(bbop.core.get_assemble({'sfq': sfq}));
	}
	    
	// // Reset the old state.
	// anchor.pop_excursion();

	var final_qstr = things_to_add.join('&');
	final_qstr = anchor._query_encode(final_qstr);
    	return final_qstr;
    };

    /*
     * Function: get_state_url
     *
     * Get the current invariant state of the manager, plus the
     * current personality as a parameter, returned as a URL string.
     * 
     * This differs from <get_query_url> in that the generated string
     * is intended for applications that may want a little more
     * information and hinting over just what the current search
     * is. This method essentially parameterizes some of the "hidden
     * state" of the manager.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  URL string
     * 
     * Also see:
     *  <get_query_url>
     */
    this.get_state_url = function(){
	
	// Save current state.
	anchor.push_excursion();

	// Make the changes we want. First, physically set the
	// "personality", then set pins for jump-in recovery.
	anchor.set('personality', anchor.get_personality());

	// Explicitly set sticky pins for later recovery.
	// Do this pretty much exactly like we do for get_query_url().
	var sticky_filters = anchor.get_sticky_query_filters();
	var sfq = anchor.filter_list_to_assemble_hash(sticky_filters);
	anchor.set('sfq', sfq);
	
	// Get url.
	var returl = anchor.get_query_url();

	// Reset the old state.
	anchor.pop_excursion();

    	return returl;
    };

    /*
     * Function: load_url
     *
     * Makes a a best attempt to recover the state of a manager from
     * the clues left in a data url. This can also (and probably
     * should) be thought of as a "load bookmark"
     * function. Theoretically, you should even be able to use
     * "bookmarks" from alien installations.
     * 
     * Note that while this recovers enough to get the same data,
     * certain "session"/"preference" type things that are not encoded
     * in the url (e.g. filter stickiness, the contents of batch
     * queues, non-default base queries, etc.) will not be replayed
     * and must be recovered or guessed on an app by app basis..
     * 
     * Warning: this currently only replays a small subset of possible
     * parameters. Currently: personality, q, fq, ???. In the future,
     * this should no all non-session information.
     * 
     * Warning: Because there is more to bookmarks than just the major
     * stuff, variants not supplied in the bookmark will be removed.
     * 
     * This returns true if the parameter portions of the new and
     * bookmark urls match. However, this is often not the case--think
     * shifting personalities, etc.
     * 
     * Parameters:
     *  url - A URL string generated by a manager's get_query_url (or similar)
     * 
     * Returns:
     *  boolean
     */
    this.load_url = function(url){

	var loop = bbop.core.each;

	// // Some Regexps that would be nice to just compile once.
	// var regexp_url_space = /\%20/g; // '%20' == ' '
	// var regexp_url_quote = /\%22/g; // '%22' == '"'
	// var regexp_url_left_paren = /\%28/g; // '%28' == '('
	// var regexp_url_right_paren = /\%29/g; // '%29' == ')'

	// We are assuming that we are consuming our own URLs from
	// get_query_url(), so we start by attempting to decode it
	// (TODO: need a tab watch here)?
	var decoded_url = decodeURI(url);

	// Break down url.
	var in_params = bbop.core.url_parameters(decoded_url);

	// First, look for the personality setting and invoke it if
	// it's there--it will dominate unless we take care of it first.
	// Also note the all the keys that we see (for later erasure
	// of excess).
	var seen_params = {};
	loop(in_params,
	     function(ip){
		 var key = ip[0];
		 var val = ip[1];
		 if( key == 'personality' && val && val != '' ){
		     anchor.set_personality(val);
		 }
		 seen_params[key] = true;
	     });
	
	// Now cycle through the the parameters again and invoke the
	// appropriate functions to bring them in line.
	var sticky_cache = {};
	loop(in_params,
	     function(ip){
		 var key = ip[0];
		 var val = ip[1];
		 if( bbop.core.is_defined(val) && val != '' ){
		     if( key == 'personality' ){
			 // Already did it, skip.
		     }else if( key == 'q' ){
			 anchor.set_query(val);
		     }else if( key == 'fq' || key == 'sfq' ){
			 // Split the fq (or sfq) parameter.
			 var fnv = bbop.core.first_split(':', val);
			 var fname = fnv[0];
			 var fval = fnv[1];
			 //ll('HERE: fname: ' + fname);
			 //ll('HERE: fval: ' + fval);
			 if( fname && fval ){

			     var plist = [];

			     // Remove leading sign on a filter and
			     // add it to the plist.
			     var lead_char = fname.charAt(0);
			     if( lead_char == '-' || lead_char == '+' ){
				 plist.push(lead_char);
				 fname = fname.substr(1, fname.length -1);
			     }

			     // // TODO: 
			     // // If the fval looks like it has not been
			     // // decoded (like from a URL-safe
			     // // bookmark), go ahead and do so.
			     // fval = fval.replace(regexp_url_space, ' ');
			     // fval = fval.replace(regexp_url_quote, '"');
			     // fval = fval.replace(regexp_url_left_paren, '(');
			     // fval = fval.replace(regexp_url_right_paren,')');

			     // Do not allow quotes in--they will be
			     // added by the assembler.
			     fval = bbop.core.dequote(fval);

			     // Make it sticky it it came in on "sfq".
			     // Note if this is the sticky form.
			     var skey = fname + '^' + fval;
			     if( key == 'sfq' ){
				 sticky_cache[skey] = true;
				 plist.push('*');
			     }

			     // Add the query filter properly, but
			     // only if we have not already added the
			     // sticky form (prevent clobbering).
			     if( ! bbop.core.is_defined(sticky_cache[skey]) ||
				 key == 'sfq'){
				 anchor.add_query_filter(fname, fval, plist);
				 
			     }
			 }
		     }else if( key == 'qf' ){
			 // qf is handles a little strangely...
			 var foo = bbop.core.first_split('^', val);
			 //ll('qf: key: '+ key +', val: '+ val +', foo: '+ foo);
			 anchor.add_query_field(foo[0], foo[1]);
		     }else if( key == 'facet.field' ){
		      	 anchor.facets(val);
		     }else if( key == 'start' || key == 'rows' ){
			 // Numbers need to be handled carefully.
			 if( bbop.core.what_is(val) == 'string' ){
			     val = parseFloat(val);
			 }
		      	 anchor.set(key, val);
		     }else{
			 // This one catches all of the non-special
			 // parameters and resets them using .set().
			 anchor.set(key, val);
			 // if( key == 'fq' ){
			 //     throw new Error("OI");			     
			 // }
		     }
		 }
	     });

	// Now go through and remove all of the query variant
	// parameters that were not seen in the bookmark.
	loop(anchor.query_variants,
	     function(key, val){
		 if( ! bbop.core.is_defined(seen_params[key]) ){
		     anchor.unset(key);
		 }
	     });

	// Produce our own url from what we've done. If the parameters
	// match with the incoming argument's return true.
	var curr_url = anchor.get_query_url();
	var curr_params = bbop.core.url_parameters(curr_url);
	var differences = 0;
	if( in_params.length == curr_params.length ){
	    loop(in_params,
		 function(in_p, i){
		     var curr_p = curr_params[i];
		     if( in_p.length == curr_p.length ){
			 if( in_p.length == 1 ){
			     if( in_p[0] == curr_p[0] ){
				 // match!
			     }else{
				 differences++;
			     }
			 }else if( in_p.length == 2 ){
			     if( in_p[0] == curr_p[0] && in_p[1] == curr_p[1] ){
				 // match!
			     }else{
				 differences++;
			     }
			 }
		     }else{
			 differences++;
		     }
		 });
	}else{
	    differences++;
	}

	// Tally the differences and decides if they're the same.
	var retval = false;
	if( differences == 0 ){
	    retval = true;
	}
    	return retval;
    };

    /*
     * Function: add_to_batch
     *
     * "Save" the current manager state to run later in serial batch
     * mode.
     * 
     * The actual job of running these batches is left to the
     * implementation of the sub-managers; probably in "run_batch".
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  state url
     */
    this.add_to_batch = function(){
	var qurl = anchor.get_query_url();
	anchor._batch_urls.push(qurl);
    	return qurl;
    };

    /*
     * Function: batch_urls
     *
     * Return a pointer to the current batch urls.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  array
     */
    this.batch_urls = function(){
    	return anchor._batch_urls;
    };

    /*
     * Function: next_batch_url
     *
     * Return the next data to be processed, removing it from the
     * batch queue in the process.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  state url or null
     */
    this.next_batch_url = function(){
    	return anchor._batch_urls.shift() || null;
    };

    /*
     * Function: reset_batch
     *
     * Clear the currently queued data batch.
     * 
     * The actual job of running these batches is left to the
     * implementation of the sub-managers; probably in "run_batch".
     * 
     * Parameters:
     *  n/a
     * 
     * Returns:
     *  the number of items cleared
     */
    this.reset_batch = function(){
	var num = anchor._batch_urls.length;
	anchor._batch_urls = [];
    	return num;
    };
};
bbop.core.extend(bbop.golr.manager, bbop.registry);

/*
 * Function: to_string
 *
 * Output writer for this object/class.
 * See the documentation in <core.js> on <dump> and <to_string>.
 * 
 * Parameters: 
 *  n/a
 *
 * Returns:
 *  string
 */
bbop.golr.manager.prototype.to_string = function (){
    return '<' + this._is_a + '>';
};

/*
 * Function: update
 *
 * The user code to select the type of update (and thus the type
 * of callbacks to be called on data return).
 * 
 * This mechanism adds a couple of variables over other methods
 * for bookkeeping: packet (incremented every time) and callback_type.
 * 
 * The currently recognized callback types are "reset" (for when you
 * are starting or starting over) and "search" (what you typically
 * want when you get new data) and "error" for when something went
 * wrong. But only "search" and "reset" manipulate the system.
 * 
 * If rows or start are not set, they will both be reset to their
 * initial values--this is to allow for paging on "current"
 * results and then getting back to the business of searching with
 * as little fuss as possible. Because of things like this, one
 * should avoid calling this directly whenever possible and prefer
 * simpler functionality of the wrapper methods: <search>,
 * <reset>, and <page>.
 * 
 * Parameters: 
 *  callback_type - callback type string; 'search', 'reset' and 'error'
 *  rows - *[optional]* integer; the number of rows to return
 *  start - *[serially optional]* integer; the offset of the returned rows
 *
 * Returns:
 *  the query url (with the jQuery callback specific parameters)
 * 
 * Also see:
 *  <get_query_url>
 */
bbop.golr.manager.prototype.update = function(callback_type, rows, start){

    //function ll(s){ this._logger.kvetch(s); }

    // Handle paging in this main section by resetting to
    // the defaults if rows and offset are not explicitly
    // defined.
    if( ! bbop.core.is_defined(rows) || ! bbop.core.is_defined(start) ){
    	this.set('rows', this.current_rows);
    	this.set('start', this.current_start);
    }
    
    // Our bookkeeping--increment packet.
    this.last_sent_packet = this.last_sent_packet + 1;
    
    // Necessary updated query variants.
    var update_query_variants = {
    	packet: this.last_sent_packet,
    	callback_type: callback_type
    };
    var update_qv = bbop.core.get_assemble(update_query_variants);
    
    // Structure of the necessary invariant parts.	
    //var qurl = this.get_query_url();
    var qurl = null;
    
    // Conditional merging of the remaining variant parts.
    if( callback_type == 'reset' ){
	
    	// Take everything back to the initial state--this means
    	// resetting the query and removing all non-sticky
    	// filters.
	
    	// Reset and do completely open query.
    	//ll('reset assembly');
	
    	// Save the q vals, do a fundamental get, then reset to
    	// what we had.
    	//var tmp_save = this.get_query();
    	//this.reset_default_query();
    	this.reset_query();
    	this.reset_query_filters();
    	qurl = this.get_query_url();
    	qurl = qurl + '&' + update_qv;
    	//this.set_query(tmp_save);
	
    }else if( callback_type == 'search' ){
	
    	//ll('search assembly');
    	qurl = this.get_query_url();
    	qurl = qurl + '&' + update_qv;
	
    }else{
    	throw new Error("Unknown callback_type: " + callback_type);
    }
    
    this.apply_callbacks('prerun', [this]);

    //ll('qurl: ' + qurl);
    return qurl;
};
/* 
 * Package: preload.js
 * 
 * Namespace: bbop.golr.manager.preload
 * 
 * Preload BBOP manager for dealing with remote calls. Remember,
 * this is actually a "subclass" of <bbop.golr.manager>.
 * 
 * This is synchronous.
 * 
 * This is mostly for testing purposes.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.golr == "undefined" ){ bbop.golr = {}; }
if ( typeof bbop.golr.manager == "undefined" ){ bbop.golr.manager = {}; }

/*
 * Constructor: preload
 * 
 * Contructor for the GOlr query manager.
 * 
 * Allows preloading of the returned document.
 * 
 * Arguments:
 *  golr_loc - string url to GOlr server
 *  golr_conf_obj - a <bbop.golr.conf> object
 * 
 * Returns:
 *  golr manager object
 * 
 * See also:
 *  <bbop.golr.manager>
 */
bbop.golr.manager.preload = function (golr_loc, golr_conf_obj){
    bbop.golr.manager.call(this, golr_loc, golr_conf_obj);
    this._is_a = 'bbop.golr.manager.preload';

    // The only property to add.
    this._bgm_load = null;
};
bbop.core.extend(bbop.golr.manager.preload, bbop.golr.manager);

/*
 * Function: load
 *
 * Parameters: 
 *  thing - what to send to the callbacks
 *
 * Returns:
 *  n/a
 */
bbop.golr.manager.preload.prototype.load = function(thing){
    this._bgm_load = thing;    
};

/*
 * Function: update
 *
 *  See the documentation in <golr_manager.js> on update to get more
 *  of the story. This override function adds a trigger that can be
 *  preloaded with results. Really only for testing.
 *
 * Parameters: 
 *  callback_type - callback type string
 *  rows - *[serially optional]* integer; the number of rows to return
 *  start - *[serially optional]* integer; the offset of the returned rows
 *
 * Returns:
 *  the query url
 * 
 * Also see:
 *  <get_query_url>
 */
bbop.golr.manager.preload.prototype.update = function(callback_type,
						      rows, start){
    // Get "parents" url first.
    var parent_update = bbop.golr.manager.prototype.update;
    var qurl = parent_update.call(this, callback_type, rows, start);

    // 
    var logger = new bbop.logger(this._is_a);
    //this._logger = new bbop.logger(this._is_a);
    logger.DEBUG = true;
    function ll(str){ logger.kvetch(str); }

    // Grab the data from the server and pick the right callback group
    // accordingly.
    var json_data = this._bgm_load;    
    if( bbop.core.is_defined(json_data) ){
	var response = new bbop.golr.response(json_data);
	this.apply_callbacks(callback_type, [response, this]);
    }else{
	this.apply_callbacks('error', ['unparsable json data', this]);
    }

    return qurl;
};
/* 
 * Package: jquery.js
 * 
 * Namespace: bbop.golr.manager.jquery
 * 
 * jQuery BBOP manager for dealing with actual ajax calls. Remember,
 * this is actually a "subclass" of <bbop.golr.manager>.
 * 
 * This should still be able to limp along (no ajax and no error
 * parsing) even outside of a jQuery environment.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.golr == "undefined" ){ bbop.golr = {}; }
if ( typeof bbop.golr.manager == "undefined" ){ bbop.golr.manager = {}; }

/*
 * Constructor: jquery
 * 
 * Contructor for the GOlr query manager
 * 
 * Arguments:
 *  golr_loc - string url to GOlr server;
 *  golr_conf_obj - a <bbop.golr.conf> object
 * 
 * Returns:
 *  golr manager object
 * 
 * See also:
 *  <bbop.golr.manager>
 */
bbop.golr.manager.jquery = function (golr_loc, golr_conf_obj){
    bbop.golr.manager.call(this, golr_loc, golr_conf_obj);
    this._is_a = 'bbop.golr.manager.jquery';
    
    // Get a good self-reference point.
    var anchor = this;

    // Per-manager logger helper.
    function ll(str){ anchor._logger.kvetch(str); }

    // Before anything else, if we cannot find a viable jQuery library
    // for use, we're going to create a fake one so we can still test
    // and work in a non-browser/networked environment.
    anchor.JQ = new bbop.golr.faux_ajax();
    try{ // some interpreters might not like this kind of probing
    	if( typeof(jQuery) !== 'undefined' ){
    	    //JQ = jQuery;
    	    anchor.JQ = jQuery.noConflict();
    	}
    }catch (x){
    }finally{
    	var got = bbop.core.what_is(anchor.JQ);
    	if( got && got == 'bbop.golr.faux_ajax'){
    	}else{
    	    got = 'jQuery';
    	}
    	ll('Using ' + got + ' for Ajax calls.');
    }

    // The base jQuery Ajax args we need with the setup we have.
    anchor.jq_vars = {
	//url: qurl,
	//type: "GET",
	'type': "POST",
	'dataType': 'jsonp',
	'jsonp': 'json.wrf'
    };

    // We'll override the original with something that actually speaks
    // jQuery. This is the function that runs where there is an AJAX
    // error during an update. First it has to run some template code,
    // then it does all of the callbacks.
    this._run_error_callbacks = function(result, status, error) {

    	ll('Failed server request: '+ result +', '+ status +', '+ error);
    	//ll('Failed (a): '+ bbop.core.what_is(status));
    	//ll('Failed (b): '+ bbop.core.dump(status));
		
    	var clean_error = "unknown error";

    	// Get the error out (clean it) if possible.
    	var jreq = result.responseText;
    	var req = anchor.JQ.parseJSON(jreq); // TODO/BUG: this must be removed
    	if( req && req['errors'] && req['errors'].length > 0 ){
    	    var in_error = req['errors'][0];
    	    ll('ERROR:' + in_error);
    	    // Split on newline if possible to get
    	    // at the nice part before the perl
    	    // error.
    	    var reg = new RegExp("\n+", "g");
    	    var clean_error_split =
    		in_error.split(reg);
    	    clean_error = clean_error_split[0];
    	}else if( bbop.core.what_is(error) == 'string' &&
    		  error.length > 0){
    	    clean_error = error;
    	}else if( bbop.core.what_is(status) == 'string' &&
    		  status.length > 0){
    	    clean_error = status;
    	}
	
    	// Run all against registered functions.
    	ll('run error callbacks...');
    	anchor.apply_callbacks('error', [clean_error, anchor]);
    };

    // Try and decide between a reset callback and a search callback.
    // This is useful since jQuery doesn't have a natural way to do
    // that within the callbacks.
    this._callback_type_decider = function(json_data){
    	ll('in callback type decider...');

	var response = new bbop.golr.response(json_data);

    	// 
    	if( ! response.success() ){
    	    throw new Error("Unsuccessful response from golr server!");
    	}else{
    	    var cb_type = response.callback_type();
    	    ll('okay response from server, will probe type...: ' + cb_type);
    	    if( cb_type == 'reset' ){
    		anchor._run_reset_callbacks(json_data);
    	    }else if( cb_type == 'search' ){
    		anchor._run_search_callbacks(json_data);
    	    }else{
    		throw new Error("Unknown callback type!");
    	    }
    	}
    };

    /*
     * Function: safety
     *
     * Getter/setter for the trigger safety.
     * 
     * If the safety is on, ajax events controlled by the manager will
     * not occur. The default if off (false).
     * 
     * Parameters: 
     *  safety_on_p - boolean
     *
     * Returns:
     *  boolean
     */
    this.safety = function(safety_on_p){
	if( bbop.core.is_defined(safety_on_p) ){
	    anchor._safety = safety_on_p;
	}
	return anchor._safety;
    };
};
bbop.core.extend(bbop.golr.manager.jquery, bbop.golr.manager);

/*
 * Function: update
 *
 *  See the documentation in <golr_manager.js> on update to get more
 *  of the story. This override function adds functionality for
 *  jQuery.
 * 
 * You can prevent the triggering of ajax with the <safety>
 * method.
 *
 * Parameters: 
 *  callback_type - callback type string
 *  rows - *[serially optional]* integer; the number of rows to return
 *  start - *[serially optional]* integer; the offset of the returned rows
 *
 * Returns:
 *  the query url (with the jQuery callback specific parameters)
 * 
 * Also see:
 *  <get_query_url>
 */
bbop.golr.manager.jquery.prototype.update = function(callback_type, rows, start){
    
    // Get "parents" url first.
    var parent_update = bbop.golr.manager.prototype.update;
    var qurl = parent_update.call(this, callback_type, rows, start);
    
    // Only actually trigger if the safety is off (default).
    if( ! this.safety() ){
	
	//ll('try: ' + qurl);
	//widgets.start_wait('Updating...');
	
	// Setup JSONP for Solr and jQuery ajax-specific parameters.
	this.jq_vars['success'] = this._callback_type_decider; // decide & run
	this.jq_vars['error'] = this._run_error_callbacks; // run error cbs
	//done: _callback_type_decider, // decide & run search or reset
	//fail: _run_error_callbacks, // run error callbacks
	//always: function(){} // do I need this?
	this.JQ.ajax(qurl, this.jq_vars);
    }
    
    return qurl;
};

/*
 * Function: run_batch
 *
 * A distant cousin of <update>.
 * Designed to "serially" get data from a server for
 * certain types of data crunching routines.
 * 
 * Why would you want this? Lets say there are ten distinct things
 * that you want from the server. Coordinating and collating them all
 * without annoying the server or going insane is hard in an
 * asynchronous environment.
 *
 * Parameters: 
 *  accumulator_func - the function that collects
 *  final_func - the function to run on completion
 *
 * Returns:
 *  the number of batch items run
 */
bbop.golr.manager.jquery.prototype.run_batch = function(accumulator_func,
							final_func){

    var anchor = this;

    // Set the various callbacks internally so we can get back at them
    // when we lose our stack during the ajax.
    if( accumulator_func ){ this._batch_accumulator_func = accumulator_func; }
    if( final_func ){ this._batch_final_func = final_func; }

    // Look at how many states are left.
    var qurl = anchor.next_batch_url();
    if( qurl ){
	    
	// Generate a custom callback function that will start
	// this process (next_generator) again--continue the cycle.
	var next_cycle = function(json_data){
	    var response = new bbop.golr.response(json_data);
	    anchor._batch_accumulator_func.apply(anchor, [response, anchor]);
	    anchor.run_batch();
	};
	
	// Put this custom callback on success.
	anchor.jq_vars['success'] = next_cycle;
	anchor.jq_vars['error'] = anchor._run_error_callbacks;
	anchor.JQ.ajax(qurl, anchor.jq_vars);
    }else{
	anchor._batch_final_func.apply(anchor);
    }
};

/*
 * Function: fetch
 *
 * A cousin of <update>, but is made to avoid all of the usual
 * callback functions (except error) and just run the single function
 * from the argument.
 * 
 * Why would you want this? Sometimes you need just a little data
 * without updating the whole interface or whatever.
 *
 * Parameters: 
 *  run_func - the function to run on completion
 *
 * Returns:
 *  n/a
 */
bbop.golr.manager.jquery.prototype.fetch = function(run_func){

    // ...
    var anchor = this;
    var qurl = anchor.get_query_url();
    anchor._run_func = run_func;
    anchor.jq_vars['success'] =
	function(json_data){
	    var response = new bbop.golr.response(json_data);
	    anchor._run_func(response);   
	};
    anchor.jq_vars['error'] = anchor._run_error_callbacks;
    anchor.JQ.ajax(qurl, anchor.jq_vars);
};

/*
 * Namespace: bbop.golr.faux_ajax
 *
 * Constructor: faux_ajax
 * 
 * Contructor for a fake and inactive Ajax. Used by bbop.golr.manager.jquery
 * in (testing) environments where jQuery is not available.
 * 
 * Returns:
 *  faux_ajax object
 */
bbop.golr.faux_ajax = function (){
    this._is_a = 'bbop.golr.faux_ajax';

    /*
     * Function: ajax
     *
     * Fake call to jQuery's ajax.
     *
     * Parameters: 
     *  args - whatever
     *
     * Returns:
     *  null
     */
    this.ajax = function(args){
	return null;
    };
    /*
     * Function: parseJSON
     *
     * Fake call to jQuery's parseJSON.
     *
     * Parameters: 
     *  args - whatever--they are ignored
     *
     * Returns:
     *  ""
     */
    this.parseJSON = function(args){
	return "";
    };
};
/* 
 * Package: rhino.js
 * 
 * Namespace: bbop.golr.manager.rhino
 * 
 * Rhino BBOP manager for dealing with remote calls. Remember,
 * this is actually a "subclass" of <bbop.golr.manager>.
 * 
 * This may be madness.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.golr == "undefined" ){ bbop.golr = {}; }
if ( typeof bbop.golr.manager == "undefined" ){ bbop.golr.manager = {}; }

/*
 * Constructor: rhino
 * 
 * Contructor for the GOlr query manager; Rhino-style.
 * 
 * Beware that this version is a synchronous call.
 * 
 * Arguments:
 *  golr_loc - string url to GOlr server
 *  golr_conf_obj - a <bbop.golr.conf> object
 * 
 * Returns:
 *  golr manager object
 * 
 * See also:
 *  <bbop.golr.manager>
 */
bbop.golr.manager.rhino = function (golr_loc, golr_conf_obj){
    bbop.golr.manager.call(this, golr_loc, golr_conf_obj);
    this._is_a = 'bbop.golr.manager.rhino';
};
bbop.core.extend(bbop.golr.manager.rhino, bbop.golr.manager);

/*
 * Function: update
 *
 *  See the documentation in <golr_manager.js> on update to get more
 *  of the story. This override function adds functionality to Rhino.
 *
 * Parameters: 
 *  callback_type - callback type string
 *  rows - *[serially optional]* integer; the number of rows to return
 *  start - *[serially optional]* integer; the offset of the returned rows
 *
 * Returns:
 *  the query url (with any Rhino specific paramteters)
 * 
 * Also see:
 *  <get_query_url>
 */
bbop.golr.manager.rhino.prototype.update = function(callback_type,
						    rows, start){
    // Get "parents" url first.
    var parent_update = bbop.golr.manager.prototype.update;
    var qurl = parent_update.call(this, callback_type, rows, start);

    // 
    var logger = new bbop.logger(this._is_a);
    //this._logger = new bbop.logger(this._is_a);
    logger.DEBUG = true;
    function ll(str){ logger.kvetch(str); }

    // Grab the data from the server and pick the right callback group
    // accordingly.
    var raw = readUrl(qurl); // in Rhino
    var json_data = null;
    if( raw && raw != '' ){
	json_data = JSON.parse(raw);
	if( json_data ){
	    var response = new bbop.golr.response(json_data);
	    this.apply_callbacks(callback_type, [response, this]);
	}else{
	    this.apply_callbacks('error', ['unparsable data', this]);
	}
    }else{
	this.apply_callbacks('error', ['no data', this]);
    }

    return qurl;
};

/*
 * Function: fetch
 *
 * This is the synchronous data getter for Rhino--probably your best
 * bet right now for scripting.
 * 
 * Parameters:
 *  n/a 
 *
 * Returns:
 *  <bbop.golr.response> or null
 * 
 * Also see:
 *  <update>
 */
bbop.golr.manager.rhino.prototype.fetch = function(){
    
    var qurl = this.get_query_url();

    // Grab the data from the server and pick the right callback group
    // accordingly.
    var raw = readUrl(qurl); // in Rhino
    var json_data = null;
    var retval = null;
    if( raw && raw != '' ){
	json_data = JSON.parse(raw);
	if( json_data ){
	    var response = new bbop.golr.response(json_data);
	    retval = response;
	}
    }

    return retval;
};

/* 
 * Package: ringo.js
 * 
 * Namespace: bbop.golr.manager.ringo
 * 
 * Ringo BBOP manager for dealing with remote GOlr calls. Remember,
 * this is actually a "subclass" of <bbop.golr.manager>.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.golr == "undefined" ){ bbop.golr = {}; }
if ( typeof bbop.golr.manager == "undefined" ){ bbop.golr.manager = {}; }

/*
 * Constructor: ringo
 * 
 * Contructor for the GOlr query manager; Ringo flavor. YMMV.
 * 
 * Arguments:
 *  golr_loc - string url to GOlr server;
 *  golr_conf_obj - a <bbop.golr.conf> object
 * 
 * Returns:
 *  golr manager object
 * 
 * See also:
 *  <bbop.golr.manager>
 */
bbop.golr.manager.ringo = function (golr_loc, golr_conf_obj){

    // We are a registry like this:
    bbop.golr.manager.call(this, golr_loc, golr_conf_obj);
    this._is_a = 'bbop.golr.manager.ringo';

    // Grab the http client.
    this._http_client = require("ringo/httpclient");
};
bbop.core.extend(bbop.golr.manager.ringo, bbop.golr.manager);

/*
 * Function: update
 *
 *  See the documentation in <golr_manager.js> on update to get more
 *  of the story. This override function adds functionality to Ringo.
 *
 * Parameters: 
 *  callback_type - callback type string
 *  rows - *[serially optional]* integer; the number of rows to return
 *  start - *[serially optional]* integer; the offset of the returned rows
 *
 * Returns:
 *  the query url (with any Ringo specific paramteters)
 * 
 * Also see:
 *  <get_query_url>
 */
bbop.golr.manager.ringo.prototype.update = function(callback_type,
						    rows, start){
    // Get "parents" url first.
    var parent_update = bbop.golr.manager.prototype.update;
    var qurl = parent_update.call(this, callback_type, rows, start);

    // // 
    // var logger = new bbop.logger(this._is_a);
    // //this._logger = new bbop.logger(this._is_a);
    // logger.DEBUG = true;
    // function ll(str){ logger.kvetch(str); }

    var anchor = this;
    
    // Grab the data from the server and pick the right callback group
    // accordingly.
    anchor._callbacker = function(data, status, contentType, exchange){

	// 
	var raw_str = exchange.content;
	var json_data = null;
	if( raw_str && raw_str != '' ){
	    json_data = JSON.parse(raw_str);
	    if( json_data ){
		var response = new bbop.golr.response(json_data);
		anchor.apply_callbacks(callback_type, [response, this]);
	    }else{
		this.apply_callbacks('error', ['unparsable data', this]);
	    }
	}else{
	    this.apply_callbacks('error', ['no data', this]);
	}
    };
    var exchange = this._http_client.get(qurl, null, anchor._callbacker);
    
    return qurl;
};
/* 
 * Package: nodejs.js
 * 
 * Namespace: bbop.golr.manager.nodejs
 * 
 * NodeJS BBOP manager for dealing with remote calls. Remember,
 * this is actually a "subclass" of <bbop.golr.manager>.
 * 
 * This may be madness.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.golr == "undefined" ){ bbop.golr = {}; }
if ( typeof bbop.golr.manager == "undefined" ){ bbop.golr.manager = {}; }

/*
 * Constructor: nodejs
 * 
 * Contructor for the GOlr query manager; NodeJS flavor. YMMV.
 * 
 * Arguments:
 *  golr_loc - string url to GOlr server;
 *  golr_conf_obj - a <bbop.golr.conf> object
 * 
 * Returns:
 *  golr manager object
 * 
 * See also:
 *  <bbop.golr.manager>
 */
bbop.golr.manager.nodejs = function (golr_loc, golr_conf_obj){
//function GOlrManager(in_args){
    // We are a registry like this:
    bbop.golr.manager.call(this, golr_loc, golr_conf_obj);
    this._is_a = 'bbop.golr.manager.nodejs';

    // Get a good self-reference point.
    //var anchor = this;

    // Per-manager logger.
    //this._ll = ll;

    // //
    // ll('Alive.');

};
bbop.core.extend(bbop.golr.manager.nodejs, bbop.golr.manager);

/*
 * Function: update
 *
 *  See the documentation in <golr_manager.js> on update to get more
 *  of the story. This override function adds functionality to NodeJS.
 *
 * Parameters: 
 *  callback_type - callback type string
 *  rows - *[serially optional]* integer; the number of rows to return
 *  start - *[serially optional]* integer; the offset of the returned rows
 *
 * Returns:
 *  the query url (with any NodeJS specific paramteters)
 * 
 * Also see:
 *  <get_query_url>
 */
bbop.golr.manager.nodejs.prototype.update = function(callback_type,
						     rows, start){
    // Get "parents" url first.
    var parent_update = bbop.golr.manager.prototype.update;
    var qurl = parent_update.call(this, callback_type, rows, start);

    // 
    var logger = new bbop.logger(this._is_a);
    //this._logger = new bbop.logger(this._is_a);
    logger.DEBUG = true;
    function ll(str){ logger.kvetch(str); }

    var anchor = this;
    this.last = null;
    
    //
    function on_error(e) {
	console.log('problem with request: ' + e.message);
    }
    function on_connect(res){
	//console.log('STATUS: ' + res.statusCode);
	//console.log('HEADERS: ' + JSON.stringify(res.headers));
	res.setEncoding('utf8');
	var raw_data = '';
	res.on('data', function (chunk) {
		   //console.log('BODY: ' + chunk);
		   raw_data = raw_data + chunk;
	       });
	// Parse JS and call callback_type callbacks.
	res.on('end', function () {
		   var json_data = JSON.parse(raw_data);
		   anchor.last = json_data;
		   var response = new bbop.golr.response(json_data);
		   anchor.apply_callbacks(callback_type, [response, anchor]);
	       });
    }
    //debugger;
    // WARNING: This should actually be passed in by the context.
    var http = require('http');
    var req = http.request(qurl, on_connect);
    req.on('error', on_error);
    
    // write data to request body
    //req.write('data\n');
    //req.write('data\n');
    req.end();
    
    return qurl;
};
/*
 * Package: clickable_object.js
 * 
 * Namespace: bbop.widget.display.clickable_object
 * 
 * BBOP object to produce a clickable image or a clickable text span,
 * both producing something that can give its id for later clickable
 * actions.
 * 
 * This is a method, not a constructor.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.widget == "undefined" ){ bbop.widget = {}; }
if ( typeof bbop.widget.display == "undefined" ){ bbop.widget.display = {}; }

/*
 * Method: clickable_object
 * 
 * Generator for a clickable object.
 * 
 * TODO: May eventually expand it to include making a jQuery button.
 * 
 * Arguments:
 *  label - *[optional]* the text to use for the span or label (defaults to '')
 *  source - *[optional]* the URL source of the image (defaults to '')
 *  id - *[optional]* the id for the object (defaults to generate_id: true)
 * 
 * Returns:
 *  bbop.html.span or bbop.html.image
 */
bbop.widget.display.clickable_object = function(label, source, id){
    //this._is_a = 'bbop.widget.display.clickable_object';
    //var anchor = this;
    // // Per-UI logger.
    // var logger = new bbop.logger();
    // logger.DEBUG = true;
    // function ll(str){ logger.kvetch('W (clickable_object): ' + str); }

    // Default args.
    if( ! label ){ label = ''; }
    if( ! source ){ source = ''; }

    // Decide whether we'll use an incoming id or generate our own.
    var args = {};
    if( id ){
	args['id'] = id;
    }else{
	args['generate_id'] = true;
    }

    // Figure out an icon or a label.
    var obj = null;
    if( source == '' ){
	obj = new bbop.html.span(label, args);
    }else{
	args['src'] = source;
	args['title'] = label;
	obj = new bbop.html.image(args);
    }

    return obj;
};
/*
 * Package: text_buttom_sim.js
 * 
 * Namespace: bbop.widget.display.text_button_sim
 * 
 * BBOP object to produce a clickable text span, that in conjunction with the local CSS, should make an awfully button looking creature.
 * 
 * It uses the class: "bbop-js-text-button-sim".
 * 
 * Note: this is a method, not a constructor.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.widget == "undefined" ){ bbop.widget = {}; }
if ( typeof bbop.widget.display == "undefined" ){ bbop.widget.display = {}; }

/*
 * Method: text_button_sim
 * 
 * Generator for a text span for use for buttons.
 * 
 * Arguments:
 *  label - *[optional]* the text to use for the span or (defaults to 'X')
 *  title - *[optional]* the hover text (defaults to 'X')
 *  id - *[optional]* the id for the object (defaults to generate_id: true)
 *  add_attrs - *[optional]* more attributes to be folded in to the span as hash
 * 
 * Returns:
 *  bbop.html.span
 */
bbop.widget.display.text_button_sim = function(label, title, id, add_attrs){
    
    // Default args.
    if( ! label ){ label = 'X'; }
    if( ! title ){ title = 'X'; }
    if( ! add_attrs ){ add_attrs = {}; }
    
    // Decide whether we'll use an incoming id or generate our own.
    var args = {
	'class': "bbop-js-text-button-sim",
	'title': title
    };
    if( id ){
	args['id'] = id;
    }else{
	args['generate_id'] = true;
    }

    // Addtional optional atrributes and overrides.    
    args = bbop.core.merge(args, add_attrs);

    var obj = new bbop.html.span(label, args);    
    return obj;
};
/*
 * Package: button_templates.js
 * 
 * Namespace: bbop.widget.display.button_templates
 * 
 * Template generators for various button "templates" that can be fed
 * into the <search_pane> widget.
 * 
 * These templates foten have functions that manipulate the
 * environment outside, such as window.*, etc. Be aware and look at
 * the code carefully--there is a reason they're in the
 * widgets/display area.
 * 
 * Note: this is a collection of methods, not a constructor/object.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.widget == "undefined" ){ bbop.widget = {}; }
if ( typeof bbop.widget.display == "undefined" ){ bbop.widget.display = {}; }
if ( typeof bbop.widget.display.button_templates == "undefined" ){ bbop.widget.display.button_templates = {}; }

/*
 * Method: field_download
 * 
 * Generate the template for a simple download button.
 * 
 * Arguments:
 *  label - the text to use for the hover
 *  count - the number of items to download
 *  fields - the field to download
 * 
 * Returns:
 *  hash form of jQuery button template for consumption by <search_pane>.
 */
bbop.widget.display.button_templates.field_download = function(label,
							       count,
							       fields){
    var dl_props = {
	'entity_list': null,
	'rows': count
    };
    var field_download_button =
	{
	    label: label,
	    diabled_p: false,
	    // text_p: false,
	    // icon: 'ui-icon-document',
	    click_function_generator: function(manager, results_table){
		return function(event){
		    var dialog_props = {
			title: 'Download',
			buttons: {
			    'Download': function(){
				//alert('download');
				dl_props['entity_list'] =
				    results_table.get_selected_items();
				var raw_gdl =
				    manager.get_download_url(fields, dl_props);
				window.open(raw_gdl, '_blank');
				//jQuery(this).dialog('destroy');
    				jQuery(this).remove();
			    },
			    'Cancel': function(){
				//jQuery(this).dialog('destroy');
    				jQuery(this).remove();
			    }
			}
		    };
		    new bbop.widget.dialog('<h4>Download (up to ' + count + ')</h4><p>You may download up to ' + count + ' lines in a new window. If your request is large or if the the server busy, this may take a while to complete--please be patient.</p>',
					   dialog_props);
		    //window.open(raw_gdl, '_blank');
		};
	    }
	};
    return field_download_button;
};

/*
 * Method: restmark
 * 
 * Generate the template for a simple bookmark button with pop-up.
 * 
 * Arguments:
 *  linker - the linker to be used for this bookmarking
 * 
 * Returns:
 *  hash form of jQuery button template for consumption by <search_pane>.
 */
bbop.widget.display.button_templates.restmark = function(linker){
    
    var bookmark_button =
	{
	    label: 'Show URL/bookmark',
	    diabled_p: false,
	    text_p: false,
	    icon: 'ui-icon-link',
	    click_function_generator: function(manager){
		return function(event){
		    //alert('GAF download: ' + manager.get_query_url());
		    //alert('URL: ' + manager.get_query_url());
		    var raw_restmark = manager.get_filter_query_string();
		    // var a_args = {
		    // 	// Since we're using the whole URI as a
		    // 	// parameter, we use the heavy hitter on top
		    // 	// of the already encoded URI.
		    // 	id: encodeURIComponent(raw_bookmark),
		    // 	label: 'this search'
		    // };
		    //  linker.anchor(a_args, 'search', curr_personality)

		    var restmark_anchor =
			'<a href="?' + raw_restmark + '">this search</a>';

		    new bbop.widget.dialog('<p>Bookmark for: ' + restmark_anchor + '.</p><p>Please be aware that <strong>this bookmark does not save properties</strong> like currently selected items.</p><p>The AmiGO 2 bookmarking method may change in the future: at this point, <strong>it is intended as a temporary method</strong> (days, not weeks or months) of allowing the reruning of searches using a link.</p>',
					   {'title': 'Bookmark'});
		};
	    }
	};
    return bookmark_button;
};

/*
 * Method: bookmark
 * 
 * Generate the template for a simple bookmark (for search) button
 * with pop-up.
 * 
 * Arguments:
 *  linker - the linker to be used for this bookmarking
 * 
 * Returns:
 *  hash form of jQuery button template for consumption by <search_pane>.
 */
bbop.widget.display.button_templates.bookmark = function(linker){
    
    var bookmark_button =
	{
	    label: 'Show URL/bookmark',
	    diabled_p: false,
	    text_p: false,
	    icon: 'ui-icon-link',
	    click_function_generator: function(manager){
		return function(event){
		    //alert('GAF download: ' + manager.get_query_url());
		    //alert('URL: ' + manager.get_query_url());
		    var raw_bookmark = manager.get_state_url();
		    var curr_personality = manager.get_personality();
		    var a_args = {
			// Since we're using the whole URI as a
			// parameter, we use the heavy hitter on top
			// of the already encoded URI.
			id: encodeURIComponent(raw_bookmark),
			label: 'this search'
		    };
		    
		    new bbop.widget.dialog('<p>Bookmark for: ' + linker.anchor(a_args, 'search', curr_personality) + '</p><p>Please be aware that <strong>this bookmark does not save properties</strong> like currently selected items.</p><p>The AmiGO 2 bookmarking method may change in the future: at this point, <strong>it is intended as a temporary method</strong> (days, not weeks or months) of allowing the reruning of searches using a link.</p>',
					   {'title': 'Bookmark'});
		};
	    }
	};
    return bookmark_button;
};

/*
 * Method: send_fields_to_galaxy
 * 
 * Generate the template for a button that sends fields to a Galaxy
 * instance.
 * 
 * Arguments:
 *  label - the text to use for the hover
 *  count - the number of items to download
 *  fields - the field to download
 *  galaxy - the url to the galaxy instance we're sending to
 * 
 * Returns:
 *  hash form of jQuery button template for consumption by <search_pane>.
 */
bbop.widget.display.button_templates.send_fields_to_galaxy = function(label,
								      count,
								      fields,
								      galaxy){
    var dl_props = {
	'entity_list': null,
	'rows': count
    };
    var galaxy_button =
	{
	    label: label,
	    diabled_p: false,
	    text_p: false,
	    icon: 'ui-icon-mail-closed',
	    click_function_generator: function(manager){
		return function(event){
		    
		    // If we have something, construct a form
		    if( ! galaxy || galaxy == "" ){
			alert('Sorry: could not find a usable Galaxy.');
		    }else{
			// We have a galaxy, so let's try and kick out
			// to it. Cribbing form POST from Gannet.
			var bval = '1 field';
			if( fields && fields.length > 1 ){
			    bval = fields.length + ' fields';
			}
			var input_su =
			    new bbop.html.input({name: 'submit',
						 type: 'submit',
						 value: bval});
			var input_um =
			    new bbop.html.input({name: 'URL_method',
						 type: 'hidden',
						 value: 'get'});

			// See GAF download button for more info.
			dl_props['entity_list'] = manager.get_selected_items();
			var raw_gdl =
			    manager.get_download_url(fields, dl_props);
			var input_url =
			    new bbop.html.input({name: 'URL',
						 type: 'hidden',
						 value: raw_gdl});

			var form =
			    new bbop.html.tag('form',
					      {
						  id: 'galaxyform',
						  name: 'galaxyform',
						  method: 'POST',
						  target: '_blank',
						  action: galaxy
					      },
					      [input_su, input_um, input_url]
					     );
			
			// Finally, bang out what we've constructed in
			// a form.
			new bbop.widget.dialog('Export to Galaxy: ' +
					       form.to_string());
		    }
		};
	    }
	};

    return galaxy_button;
};

/*
 * Method: open_facet_matrix
 * 
 * Generate the template for a button that sends the user to the
 * facet_matrix page with the current manager state and two facets.
 * 
 * TODO: The facet_matrix link should be handled by the linker, not
 * manually using the app_base info.
 * 
 * Arguments:
 *  gconf - a copy of the <golr_conf> for the currrent setup
 *  instance_data - a copy of an amigo.data.server() for app_base info
 * 
 * Returns:
 *  hash form of jQuery button template for consumption by <search_pane>.
 */
bbop.widget.display.button_templates.open_facet_matrix = function(gconf,
								  instance_data){

    // Aliases.
    var loop = bbop.core.each;

    var facet_matrix_button =
	{
	    label: 'Use a matrix to compare document counts for two facets (limit 50 on each axis).',
	    diabled_p: false,
	    text_p: false,
	    //icon: 'ui-icon-caret-2-e-w',
	    icon: 'ui-icon-calculator',
	    click_function_generator: function(manager){
		return function(event){
		    
		    // 
		    var pers = manager.get_personality();
		    var class_conf = gconf.get_class(pers);
		    if( class_conf ){
			
			var filter_list = 
			    class_conf.field_order_by_weight('filter');

			// Get a list of all the facets that we can
			// compare.
			var facet_list_1 = [];
			loop(filter_list,
			     function(filter_id, findex){
				 var cf = class_conf.get_field(filter_id);
				 var cname = cf.display_name();
				 var cid = cf.id();
				 var pset = [cname, cid];

				 // Make sure the first one is
				 // checked.
				 if( findex == 0 ){ pset.push(true); }

				 facet_list_1.push(pset);
			     });
			// We need two though.
			var facet_list_2 = bbop.core.clone(facet_list_1);

			// Stub sender.
			var lss_args = {
			    title: 'Select facets to compare',
			    blurb: 'This dialog will launch you into a tool in another window where you can examine the document counts for two selected facets in a matrix (grid) view.',
			    list_of_lists: [facet_list_1, facet_list_2],
			    title_list: ['Facet 1', 'Facet 2'],
			    action: function(selected_args){
				var f1 = selected_args[0] || '';
				var f2 = selected_args[1] || '';
				var jmp_state = manager.get_state_url();
				var mngr = encodeURIComponent(jmp_state);
				var jump_url = instance_data.app_base() +
				    '/facet_matrix?'+
				    [
					'facet1=' + f1,
					'facet2=' + f2,
					'manager=' + mngr
				    ].join('&');
				window.open(jump_url, '_blank');
			    }};
			new bbop.widget.list_select_shield(lss_args);
		    }
		};
	    }
	};
    return facet_matrix_button;
};

/*
 * Method: flexible_download
 * 
 * Generate the template for a button that gives the user a DnD and
 * reorderable selector for how they want their tab-delimited
 * downloads.
 * 
 * Arguments:
 *  label - the text to use for the hover
 *  count - the number of items to be downloadable
 *  start_fields - ordered list of the initially selected fields 
 *  personality - the personality (id) that we want to work with
 *  gconf - a copy of the <golr_conf> for the currrent setup
 * 
 * Returns:
 *  hash form of jQuery button template for consumption by <search_pane>.
 */
bbop.widget.display.button_templates.flexible_download = function(label, count,
								  start_fields,
								  personality,
								  gconf){

    var dl_props = {
	'entity_list': null,
	'rows': count
    };

    // Aliases.
    var loop = bbop.core.each;
    var hashify = bbop.core.hashify;

    var flexible_download_button =
	{
	    label: label,
	    diabled_p: false,
	    text_p: false,
	    icon: 'ui-icon-circle-arrow-s',
	    click_function_generator: function(manager){

		return function(event){
		    
		    var class_conf = gconf.get_class(personality);
		    if( class_conf ){
			
			// First, a hash of our default items so we
			// can check against them later to remove
			// those items from the selectable pool.
			// Then convert the list into a more
			// interesting data type.
			var start_hash = hashify(start_fields);
			var start_list = [];
			loop(start_fields,
			     function(field_id, field_index){
				 var cf = class_conf.get_field(field_id);
				 var cname = cf.display_name();
				 var cid = cf.id();
				 var pset = [cname, cid];
				 start_list.push(pset);
			     });

			// Then get an ordered list of all the
			// different values we want to show in
			// the pool list.
			var pool_list = [];
			var all_fields = class_conf.get_fields();
			loop(all_fields,
			     function(field, field_index){
				 var field_id = field.id();
				 if( start_hash[field_id] ){
				     // Skip if already in start list.
				 }else{
				     var cname = field.display_name();
				     var cid = field.id();
				     var pset = [cname, cid];
				     pool_list.push(pset);
				 }
			     });

			// To alphabetical.
			pool_list.sort(function(a, b){
			    var av = a[0];
			    var bv = b[0];
			    var val = 0;
			    if( av < bv ){
				return -1;
			    }else if( av > bv){
				return 1;
			    }
			    return val;
			});

			// Stub sender.
			var dss_args = {
			    title: 'Select the fields to download (up to ' + count + ')',
			    blurb: '<p><strong>Drag and drop</strong> the desired fields <strong>from the left</strong> column (available pool) <strong>to the right</strong> (selected fields). You may also reorder them.</p><p>Download up to ' + count + ' lines in a new window by clicking <strong>Download</strong>. If your request is large or if the the server busy, this may take a while to complete--please be patient.</p>',
			    //blurb: 'By clicking "Download" at the bottom, you may download up to ' + count + ' lines in your browser in a new window. If your request is large or if the the server busy, this may take a while to complete--please be patient.',
			    pool_list: pool_list,
			    selected_list: start_list,
			    action_label: 'Download',
			    action: function(selected_items){
			    	dl_props['entity_list'] =
			    	    manager.get_selected_items();
			    	var raw_gdl =
			    	    manager.get_download_url(selected_items,
			    				     dl_props);
			    	window.open(raw_gdl, '_blank');
			    }};
			new bbop.widget.drop_select_shield(dss_args);
		    }
		};
	    }
	};
    return flexible_download_button;
};

/*
 * Method: flexible_download
 * 
 * Generate the template for a button that gives the user a DnD and
 * reorderable selector for how they want their tab-delimited
 * downloads.
 * 
 * Arguments:
 *  label - the text to use for the hover
 *  count - the number of items to be downloadable
 *  start_fields - ordered list of the initially selected fields 
 *  personality - the personality (id) that we want to work with
 *  gconf - a copy of the <golr_conf> for the currrent setup
 * 
 * Returns:
 *  hash form of jQuery button template for consumption by other widgets
 */
bbop.widget.display.button_templates.flexible_download_b3 = function(
    label, count, start_fields, personality, gconf){

    var dl_props = {
	'entity_list': null,
	'rows': count
    };

    // Aliases.
    var loop = bbop.core.each;
    var hashify = bbop.core.hashify;

    var flexible_download_button = {
	label: label,
	diabled_p: false,
	click_function_generator: function(results_table, manager){
	    
	    return function(event){
		
		var class_conf = gconf.get_class(personality);
		if( class_conf ){
		    
		    // First, a hash of our default items so we
		    // can check against them later to remove
		    // those items from the selectable pool.
		    // Then convert the list into a more
		    // interesting data type.
		    var start_hash = hashify(start_fields);
		    var start_list = [];
		    loop(start_fields, function(field_id, field_index){
			var cf = class_conf.get_field(field_id);
			var cname = cf.display_name();
			var cid = cf.id();
			var pset = [cname, cid];
			start_list.push(pset);
		    });
		    
		    // Then get an ordered list of all the
		    // different values we want to show in
		    // the pool list.
		    var pool_list = [];
		    var all_fields = class_conf.get_fields();
		    loop(all_fields, function(field, field_index){
			var field_id = field.id();
			if( start_hash[field_id] ){
			    // Skip if already in start list.
			}else{
			    var cname = field.display_name();
			    var cid = field.id();
			    var pset = [cname, cid];
			    pool_list.push(pset);
			}
		    });
		    
		    // To alphabetical.
		    pool_list.sort(function(a, b){
			var av = a[0];
			var bv = b[0];
			var val = 0;
			if( av < bv ){
			    return -1;
			}else if( av > bv){
			    return 1;
			}
			return val;
		    });
		    
		    // Stub sender.
		    var dss_args = {
			title: 'Select the fields to download (up to ' + count + ')',
			blurb: '<p><strong>Drag and drop</strong> the desired fields <strong>from the left</strong> column (available pool) <strong>to the right</strong> (selected fields). You may also reorder them.</p><p>Download up to ' + count + ' lines in a new window by clicking <strong>Download</strong>. If your request is large or if the the server busy, this may take a while to complete--please be patient.</p>',
			//blurb: 'By clicking "Download" at the bottom, you may download up to ' + count + ' lines in your browser in a new window. If your request is large or if the the server busy, this may take a while to complete--please be patient.',
			pool_list: pool_list,
			selected_list: start_list,
			action_label: 'Download',
			action: function(selected_items){
			    // Get selected items from results
			    // checkboxes.
			    dl_props['entity_list'] = null;
			    if( ! bbop.core.is_empty(results_table) ){
			    	dl_props['entity_list'] =
   				    results_table.get_selected_items();
			    }
			    // Download for the selected fields...
			    var raw_gdl =
			    	    manager.get_download_url(selected_items,
			    				     dl_props);
			    // ...opening it in a new window.
			    window.open(raw_gdl, '_blank');
			}};
		    new bbop.widget.drop_select_shield(dss_args);
		}
	    };
	}
    };
    return flexible_download_button;
};
/*
 * Package: results_table_by_class_conf.js
 * 
 * Namespace: bbop.widget.display.results_table_by_class_conf
 * 
 * Subclass of <bbop.html.tag>.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.widget == "undefined" ){ bbop.widget = {}; }
if ( typeof bbop.widget.display == "undefined" ){ bbop.widget.display = {}; }

/*
 * Function: results_table_by_class_conf
 *
 * Using a conf class and a set of data, automatically populate and
 * return a results table.
 *  
 * Parameters:
 *  class_conf - a <bbop.golr.conf_class>
 *  golr_resp - a <bbop.golr.response>
 *  linker - a linker object; see <amigo.linker> for more details
 *  handler - a handler object; see <amigo.handler> for more details
 *  elt_id - the element id to attach it to
 *  selectable_p - *[optional]* whether to create checkboxes (default true)
 *
 * Returns:
 *  <bbop.html.table> filled with results
 */
bbop.widget.display.results_table_by_class = function(cclass,
						      golr_resp,
						      linker,
						      handler,
						      elt_id,
						      selectable_p){
    //bbop.html.tag.call(this, 'div');
    //var amigo = new bbop.amigo();

    // Temp logger.
    var logger = new bbop.logger();
    //logger.DEBUG = true;
    logger.DEBUG = false;
    function ll(str){ logger.kvetch('RTBCC: ' + str); }

    // Conveience aliases.
    var each = bbop.core.each;
    var is_defined = bbop.core.is_defined;

    // The context we'll deliver to
    var display_context = 'bbop.widgets.search_pane';

    // Only want to compile once.
    var ea_regexp = new RegExp("\<\/a\>", "i"); // detect an <a>
    var br_regexp = new RegExp("\<br\ \/\>", "i"); // detect a <br />

    // Sort out whether we want to display checkboxes. Also, give life
    // to the necessary variables if they will be called upon.
    var add_selectable_p = false;
    var select_column_id = null;
    var select_item_name = null;
    if( is_defined(selectable_p) && selectable_p == true ){
	add_selectable_p = true;

	// Special id and names for optional select column.
	var local_mangle = bbop.core.uuid();
	select_column_id = 'rtbcc_select_' + local_mangle;
	select_item_name = 'rtbcc_select_name_' + local_mangle;
    }

    /*
     * Function: item_name
     *
     * Return a string of the name attribute used by the checkboxes if
     * we selected for checkboxes to be displayed.
     * 
     * Parameters:
     *  n/a
     *
     * Returns:
     *  string or null if displaying checkboxes was false
     */
    this.item_name = function(){	
	return select_item_name;
    };

    /*
     * Function: toggle_id
     *
     * Return a string of the id of the checkbox in the header if we
     * selected for checkboxes to be displayed.
     * 
     * Parameters:
     *  n/a
     *
     * Returns:
     *  string or null if displaying checkboxes was false
     */
    this.toggle_id = function(){	
	return select_column_id;
    };

    // Now take what we have, and wrap around some expansion code
    // if it looks like it is too long.
    var trim_hash = {};
    var trimit = 100;
    function _trim_and_store( in_str ){

	var retval = in_str;

	//ll("T&S: " + in_str);

	// Skip if it is too short.
	//if( ! ea_regexp.test(retval) && retval.length > (trimit + 50) ){
	if( retval.length > (trimit + 50) ){
	    //ll("T&S: too long: " + retval);

	    // Let there be tests.
	    var list_p = br_regexp.test(retval);
	    var anchors_p = ea_regexp.test(retval);

	    var tease = null;
	    if( ! anchors_p && ! list_p ){
		// A normal string then...trim it!
		//ll("\tT&S: easy normal text, go nuts!");
		tease = new bbop.html.span(bbop.core.crop(retval, trimit, ''),
					   {'generate_id': true});
	    }else if( anchors_p && ! list_p ){
		// It looks like it is a link without a break, so not
		// a list. We cannot trim this safely.
		//ll("\tT&S: single link so cannot work on!");
	    }else{
		//ll("\tT&S: we have a list to deal with");
		
		var new_str_list = retval.split(br_regexp);
		if( new_str_list.length <= 3 ){
		    // Let's just ignore lists that are only three
		    // items.
		    //ll("\tT&S: pass thru list length <= 3");
		}else{
		    //ll("\tT&S: contruct into 2 plus tag");
		    var new_str = '';
		    new_str = new_str + new_str_list.shift();
		    new_str = new_str + '<br />';
		    new_str = new_str + new_str_list.shift();
		    tease = new bbop.html.span(new_str, {'generate_id': true});
		}
	    }

	    // If we have a tease, assemble the rest of the packet
	    // to create the UI.
	    if( tease ){
		//ll("T&S: tease: " + tease.to_string());
		
		// Setup the text for tease and full versions.
		// var more_b = new bbop.html.span('<b>[more...]</b>',
		// 				{'generate_id': true});
		// var full = new bbop.html.span(retval,
		// 			      {'generate_id': true});
		// var less_b = new bbop.html.span('<b>[less]</b>',
		// 				{'generate_id': true});
		var bgen = bbop.widget.display.text_button_sim;
		var more_b = new bgen('more...', 'Display the complete list');
		var full = new bbop.html.span(retval,
					      {'generate_id': true});
		var less_b = new bgen('less', 'Display the truncated list');
		
		// Store the different parts for later activation.
		var tease_id = tease.get_id();
		var more_b_id = more_b.get_id();
		var full_id = full.get_id();
		var less_b_id = less_b.get_id();
		trim_hash[tease_id] = 
		    [tease_id, more_b_id, full_id, less_b_id];
		
		// New final string.
		retval = tease.to_string() + " " +
		    more_b.to_string() + " " +
		    full.to_string() + " " +
		    less_b.to_string();
	    }
	}

	return retval;
    }

    // Create a locally mangled checkbox.
    function _create_select_box(val, id, name){
	if( ! is_defined(name) ){
	    name = select_item_name;	    
	}
	
	var input_attrs = {
	    'value': val,
	    'name': name,
	    'type': 'checkbox'
	};
	if( is_defined(id) ){
	    input_attrs['id'] = id;
	}
	var input = new bbop.html.input(input_attrs);
	return input;
    }

    ///
    /// Render the headers.
    ///

    // Start with score, and add the others by order of the class
    // results_weights field.
    // var headers = ['score'];
    // var headers_display = ['Score'];
    var headers = [];
    var headers_display = [];
    if( add_selectable_p ){
	// Hint for later.
	headers.push(select_column_id);

	// Header select for selecting all.
	var hinp = _create_select_box('', select_column_id, '');
	//headers_display.push('All ' + hinp.to_string());
	headers_display.push(hinp.to_string());
    }
    var results_order = cclass.field_order_by_weight('result');
    each(results_order,
	 function(fid){
	     // Store the raw headers/fid for future use.
	     headers.push(fid);
	     // Get the headers into a presentable state.
	     var field = cclass.get_field(fid);
	     if( ! field ){ throw new Error('conf error: not found:' + fid); }
	     //headers_display.push(field.display_name());
	     var fdname = field.display_name();
	     var fdesc = field.description() || '???';
	     var head_span_attrs = {
		 // TODO/NOTE: to make the tooltip work properly, since the
		 // table headers are being created each time,
		 // the tooltop initiator would have to be called after
		 // each pass...I don't know that I want to do that.
		 //'class': 'bbop-js-ui-hoverable bbop-js-ui-tooltip',
		 'class': 'bbop-js-ui-hoverable',
		 'title': fdesc
	     };
	     // More aggressive link version.
	     //var head_span = new bbop.html.anchor(fdname, head_span_attrs);
	     var head_span = new bbop.html.span(fdname, head_span_attrs);
	     headers_display.push(head_span.to_string());
	 });

    ///
    /// Render the documents.
    ///

    // Some of what we'll do for each field in each doc (see below).
    // var ext = cclass.searchable_extension();
    function _process_entry(fid, iid, doc){

	var retval = '';
	var did = doc['id'];

	// BUG/TODO: First see if the filed will be multi or not.
	// If not multi, follow the first path. If multi, break it
	// down and try again.

	// Get a label instead if we can.
	var ilabel = golr_resp.get_doc_label(did, fid, iid);
	if( ! ilabel ){
	    ilabel = iid;
	}

	// Extract highlighting if we can from whatever our "label"
	// was.
	var hl = golr_resp.get_doc_highlight(did, fid, ilabel);

	// See what kind of link we can create from what we got.
	var ilink = linker.anchor({id: iid, label: ilabel, hilite: hl}, fid);
	
	ll('processing: ' + [fid, ilabel, iid].join(', '));
	//ll('ilink: ' + ilink);

	// See what we got, in order of how much we'd like to have it.
	if( ilink ){
	    retval = ilink;
	}else if( ilabel ){
	    retval = ilabel;
	}else{
	    retval = iid;
	}

	return retval;
    }

    // Cycle through and render each document.
    // For each doc, deal with it as best we can using a little
    // probing. Score is a special case as it is not an explicit
    // field.
    var table_buff = [];
    var docs = golr_resp.documents();
    each(docs,
	 function(doc){
	     
	     // Well, they had better be in here, so we're
	     // just gunna cycle through all the headers/fids.
	     var entry_buff = [];
	     each(headers,
		  function(fid){
		      // Detect out use of the special selectable
		      // column and add a special checkbox there.
		      if( fid == select_column_id ){
			  // Also
			  var did = doc['id'];
			  var dinp = _create_select_box(did);
			  entry_buff.push(dinp.to_string());
		      }else if( fid == 'score' ){
			  // Remember: score is also
			  // special--non-explicit--case.
			  var score = doc['score'] || 0.0;
			  score = bbop.core.to_string(100.0 * score);
			  entry_buff.push(bbop.core.crop(score, 4) + '%');
		      }else{
			  
			  // Not "score", so let's figure out what we
			  // can automatically.
			  var field = cclass.get_field(fid);
			  
			  // Make sure that something is there and
			  // that we can iterate over whatever it
			  // is.
			  var bits = [];
			  if( doc[fid] ){
			      if( field.is_multi() ){
				  //ll("Is multi: " + fid);
				  bits = doc[fid];
			      }else{
				  //ll("Is single: " + fid);
				  bits = [doc[fid]];
			      }
			  }
			  
			  // Render each of the bits.
			  var tmp_buff = [];
			  each(bits,
			       function(bit){
				   
				   // The major difference that we'll have here
				   // is between standard fields and special
				   // handler fields. If the handler
				   // resolves to null, fall back onto
				   // standard.
				   ll('! B:'+ bit +', F:'+ fid +
				      ', D:'+ display_context);
				   var out = handler.dispatch(bit, fid,
							      display_context);
				   if( is_defined(out) && out != null ){
				       // Handler success.
				       tmp_buff.push(out);
				   }else{
				       // Standard output.   
				       out = _process_entry(fid, bit, doc);
				       //ll('out: ' + out);
				       tmp_buff.push(out);
				   }
			       });
			  // Join it, trim/store it, push to to output.
			  var joined = tmp_buff.join('<br />');
			  entry_buff.push(_trim_and_store(joined));
		      }
		  });
	     table_buff.push(entry_buff);
	 });
	
    // Add the table to the DOM.
    var final_table =
	new bbop.html.table(headers_display, table_buff,
			    {'class': 'bbop-js-search-pane-results-table'});
    jQuery('#' + elt_id).append(bbop.core.to_string(final_table));
    
    // Add the roll-up/down events to the doc.
    each(trim_hash,
	 function(key, val){
	     var tease_id = val[0];
	     var more_b_id = val[1];
	     var full_id = val[2];
	     var less_b_id = val[3];
	     
	     // Initial state.
	     jQuery('#' + full_id ).hide();
	     jQuery('#' + less_b_id ).hide();
	     
	     // Click actions to go back and forth.
	     jQuery('#' + more_b_id ).click(
		 function(){
		     jQuery('#' + tease_id ).hide();
		     jQuery('#' + more_b_id ).hide();
		     jQuery('#' + full_id ).show('fast');
		     jQuery('#' + less_b_id ).show('fast');
		 });
	     jQuery('#' + less_b_id ).click(
		 function(){
		     jQuery('#' + full_id ).hide();
		     jQuery('#' + less_b_id ).hide();
		     jQuery('#' + tease_id ).show('fast');
		     jQuery('#' + more_b_id ).show('fast');
		 });
	 });

    //return final_table;
};
//bbop.widget.display.results_table_by_class.prototype = new bbop.html.tag;
/*
 * Package: results_table_by_class_conf_bs3.js
 * 
 * Namespace: bbop.widget.display.results_table_by_class_conf_bs3
 * 
 * Subclass of <bbop.html.tag>.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.widget == "undefined" ){ bbop.widget = {}; }
if ( typeof bbop.widget.display == "undefined" ){ bbop.widget.display = {}; }

/*
 * Function: results_table_by_class_conf_bs3
 *
 * Using a conf class and a set of data, automatically populate and
 * return a results table.
 *  
 * This is the Bootstrap 3 version of this display. It affixes itself
 * directly to the DOM using jQuery at elt_id.
 *  
 * Parameters:
 *  class_conf - a <bbop.golr.conf_class>
 *  golr_resp - a <bbop.golr.response>
 *  linker - a linker object; see <amigo.linker> for more details
 *  handler - a handler object; see <amigo.handler> for more details
 *  elt_id - the element id to attach it to
 *  selectable_p - *[optional]* whether to create checkboxes (default true)
 *
 * Returns:
 *  this object
 *
 * See Also:
 *  <bbop.widget.display.results_table_by_class>
 */
bbop.widget.display.results_table_by_class_conf_b3 = function(cclass,
							      golr_resp,
							      linker,
							      handler,
							      elt_id,
							      selectable_p,
							      select_toggle_id,
							      select_item_name){

    //
    var anchor = this;

    // Temp logger.
    var logger = new bbop.logger();
    //logger.DEBUG = true;
    logger.DEBUG = false;
    function ll(str){ logger.kvetch('RTBCCBS3: ' + str); }

    // Conveience aliases.
    var each = bbop.core.each;
    var is_defined = bbop.core.is_defined;

    // The context we'll deliver to
    var display_context = 'bbop.widgets.search_pane';

    // Only want to compile once.
    var ea_regexp = new RegExp("\<\/a\>", "i"); // detect an <a>
    var br_regexp = new RegExp("\<br\ \/\>", "i"); // detect a <br />

    // // Sort out whether we want to display checkboxes. Also, give life
    // // to the necessary variables if they will be called upon.
    // var select_toggle_id = null;
    // var select_item_name = null;
    // if( is_defined(selectable_p) && selectable_p == true ){

    // }

    // Now take what we have, and wrap around some expansion code
    // if it looks like it is too long.
    var trim_hash = {};
    var trimit = 100;
    function _trim_and_store( in_str ){

	var retval = in_str;

	//ll("T&S: " + in_str);

	// Skip if it is too short.
	//if( ! ea_regexp.test(retval) && retval.length > (trimit + 50) ){
	if( retval.length > (trimit + 50) ){
	    //ll("T&S: too long: " + retval);

	    // Let there be tests.
	    var list_p = br_regexp.test(retval);
	    var anchors_p = ea_regexp.test(retval);

	    var tease = null;
	    if( ! anchors_p && ! list_p ){
		// A normal string then...trim it!
		//ll("\tT&S: easy normal text, go nuts!");
		tease = new bbop.html.span(bbop.core.crop(retval, trimit, ''),
					   {'generate_id': true});
	    }else if( anchors_p && ! list_p ){
		// It looks like it is a link without a break, so not
		// a list. We cannot trim this safely.
		//ll("\tT&S: single link so cannot work on!");
	    }else{
		//ll("\tT&S: we have a list to deal with");
		
		var new_str_list = retval.split(br_regexp);
		if( new_str_list.length <= 3 ){
		    // Let's just ignore lists that are only three
		    // items.
		    //ll("\tT&S: pass thru list length <= 3");
		}else{
		    //ll("\tT&S: contruct into 2 plus tag");
		    var new_str = '';
		    new_str = new_str + new_str_list.shift();
		    new_str = new_str + '<br />';
		    new_str = new_str + new_str_list.shift();
		    tease = new bbop.html.span(new_str, {'generate_id': true});
		}
	    }

	    // If we have a tease, assemble the rest of the packet
	    // to create the UI.
	    if( tease ){
		// Setup the text for tease and full versions.
		function bgen(lbl, dsc){
		    var b = new bbop.html.button(
  			lbl,
			{
			    'generate_id': true,
			    'type': 'button',
			    'title': dsc || lbl,
			    //'class': 'btn btn-default btn-xs'
			    'class': 'btn btn-primary btn-xs'
			});
		    return b;
		}
		var more_b = new bgen('more...', 'Display the complete list');
		var full = new bbop.html.span(retval,
					      {'generate_id': true});
		var less_b = new bgen('less', 'Display the truncated list');
		
		// Store the different parts for later activation.
		var tease_id = tease.get_id();
		var more_b_id = more_b.get_id();
		var full_id = full.get_id();
		var less_b_id = less_b.get_id();
		trim_hash[tease_id] = 
		    [tease_id, more_b_id, full_id, less_b_id];
		
		// New final string.
		retval = tease.to_string() + " " +
		    more_b.to_string() + " " +
		    full.to_string() + " " +
		    less_b.to_string();
	    }
	}

	return retval;
    }

    // Create a locally mangled checkbox.
    function _create_select_box(val, id, name){
	if( ! is_defined(name) ){
	    name = select_item_name;	    
	}
	
	var input_attrs = {
	    'value': val,
	    'name': name,
	    'type': 'checkbox'
	};
	if( is_defined(id) ){
	    input_attrs['id'] = id;
	}
	var input = new bbop.html.input(input_attrs);
	return input;
    }

    ///
    /// Render the headers.
    ///

    // Start with score, and add the others by order of the class
    // results_weights field.
    // var headers = ['score'];
    // var headers_display = ['Score'];
    var headers = [];
    var headers_display = [];
    if( selectable_p ){
	// Hint for later.
	headers.push(select_toggle_id);

	// Header select for selecting all.
	var hinp = _create_select_box('', select_toggle_id, '');
	//headers_display.push('All ' + hinp.to_string());
	headers_display.push(hinp.to_string());
    }
    var results_order = cclass.field_order_by_weight('result');
    each(results_order,
	 function(fid){
	     // Store the raw headers/fid for future use.
	     headers.push(fid);
	     // Get the headers into a presentable state.
	     var field = cclass.get_field(fid);
	     if( ! field ){ throw new Error('conf error: not found:' + fid); }
	     //headers_display.push(field.display_name());
	     var fdname = field.display_name();
	     var fdesc = field.description() || '???';
	     var head_span_attrs = {
		 // TODO/NOTE: to make the tooltip work properly, since the
		 // table headers are being created each time,
		 // the tooltop initiator would have to be called after
		 // each pass...I don't know that I want to do that.
		 //'class': 'bbop-js-ui-hoverable bbop-js-ui-tooltip',
		 'class': 'bbop-js-ui-hoverable',
		 'title': fdesc
	     };
	     // More aggressive link version.
	     //var head_span = new bbop.html.anchor(fdname, head_span_attrs);
	     var head_span = new bbop.html.span(fdname, head_span_attrs);
	     headers_display.push(head_span.to_string());
	 });

    ///
    /// Render the documents.
    ///

    // Some of what we'll do for each field in each doc (see below).
    // var ext = cclass.searchable_extension();
    function _process_entry(fid, iid, doc){

	var retval = '';
	var did = doc['id'];

	// BUG/TODO: First see if the filed will be multi or not.
	// If not multi, follow the first path. If multi, break it
	// down and try again.

	// Get a label instead if we can.
	var ilabel = golr_resp.get_doc_label(did, fid, iid);
	if( ! ilabel ){
	    ilabel = iid;
	}

	// Extract highlighting if we can from whatever our "label"
	// was.
	var hl = golr_resp.get_doc_highlight(did, fid, ilabel);

	// See what kind of link we can create from what we got.
	var ilink = linker.anchor({id: iid, label: ilabel, hilite: hl}, fid);
	
	ll('processing: ' + [fid, ilabel, iid].join(', '));
	//ll('ilink: ' + ilink);

	// See what we got, in order of how much we'd like to have it.
	if( ilink ){
	    retval = ilink;
	}else if( ilabel ){
	    retval = ilabel;
	}else{
	    retval = iid;
	}

	return retval;
    }

    // Cycle through and render each document.
    // For each doc, deal with it as best we can using a little
    // probing. Score is a special case as it is not an explicit
    // field.
    var table_buff = [];
    var docs = golr_resp.documents();
    each(docs, function(doc){
	     
	// Well, they had better be in here, so we're just gunna cycle
	// through all the headers/fids.
	var entry_buff = [];
	each(headers, function(fid){
	    // Detect out use of the special selectable column and add
	    // a special checkbox there.
	    if( fid == select_toggle_id ){
		// Also
		var did = doc['id'];
		var dinp = _create_select_box(did);
		entry_buff.push(dinp.to_string());
	    }else if( fid == 'score' ){
		// Remember: score is also
		// special--non-explicit--case.
		var score = doc['score'] || 0.0;
		score = bbop.core.to_string(100.0 * score);
		entry_buff.push(bbop.core.crop(score, 4) + '%');
	    }else{
		
		// Not "score", so let's figure out what we can
		// automatically.
		var field = cclass.get_field(fid);
		
		// Make sure that something is there and that we can
		// iterate over whatever it is.
		var bits = [];
		if( doc[fid] ){
		    if( field.is_multi() ){
			//ll("Is multi: " + fid);
			bits = doc[fid];
		    }else{
			//ll("Is single: " + fid);
			bits = [doc[fid]];
		    }
		}
		
		// Render each of the bits.
		var tmp_buff = [];
		each(bits, function(bit){
		    
		    // The major difference that we'll have here is
		    // between standard fields and special handler
		    // fields. If the handler resolves to null, fall
		    // back onto standard.
		    ll('! B:' + bit + ', F:' + fid + ', D:' + display_context);
		    var out = handler.dispatch(bit, fid, display_context);
		    if( is_defined(out) && out != null ){
			// Handler success.
			tmp_buff.push(out);
		    }else{
			// Standard output.   
			out = _process_entry(fid, bit, doc);
			//ll('out: ' + out);
			tmp_buff.push(out);
		    }
		});
		// Join it, trim/store it, push to to output.
		var joined = tmp_buff.join('<br />');
		entry_buff.push(_trim_and_store(joined));
	    }
	});
	table_buff.push(entry_buff);
    });
	
    // Add the table to the DOM.
    var final_table =
	new bbop.html.table(headers_display, table_buff,
			    {'class': 'table table-striped table-hover table-condensed'});
	// new bbop.html.table(headers_display, table_buff,
	// 		    {'class': 'bbop-js-search-pane-results-table'});
    jQuery('#' + elt_id).append(bbop.core.to_string(final_table));
    
    // Add the roll-up/down events to the doc.
    each(trim_hash, function(key, val){
	var tease_id = val[0];
	var more_b_id = val[1];
	var full_id = val[2];
	var less_b_id = val[3];
	
	// Initial state.
	jQuery('#' + full_id ).hide();
	jQuery('#' + less_b_id ).hide();
	
	// Click actions to go back and forth.
	jQuery('#' + more_b_id ).click(function(){
	    jQuery('#' + tease_id ).hide();
	    jQuery('#' + more_b_id ).hide();
	    jQuery('#' + full_id ).show('fast');
	    jQuery('#' + less_b_id ).show('fast');
	});
	jQuery('#' + less_b_id ).click(function(){
	    jQuery('#' + full_id ).hide();
	    jQuery('#' + less_b_id ).hide();
	    jQuery('#' + tease_id ).show('fast');
	    jQuery('#' + more_b_id ).show('fast');
	});
    });

    // Since we already added to the DOM in the table, now add the
    // group toggle if the optional checkboxes are defined.
    if( select_toggle_id && select_item_name ){
	jQuery('#' + select_toggle_id).click(function(){
	    var cstr = 'input[id=' + select_toggle_id + ']';
	    var nstr = 'input[name=' + select_item_name + ']';
	    if( jQuery(cstr).prop('checked') ){
		jQuery(nstr).prop('checked', true);
	    }else{
		jQuery(nstr).prop('checked', false);
	    }
	});
    }
};
/*
 * Package: two_column_layout.js
 * 
 * Namespace: bbop.widget.display.two_column_layout
 * 
 * Reusable object to create a two-column layout.
 * 
 * Subclass of <bbop.html.tag>.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.widget == "undefined" ){ bbop.widget = {}; }
if ( typeof bbop.widget.display == "undefined" ){ bbop.widget.display = {}; }

/*
 * Constructor: two_column_layout
 *
 * Produce a div containing a CSS hardwired two-column layout.
 * These are currently hardwired to:
 * 
 * : 'class': 'twocol-leftcolumn', 'style': 'margin-top: -15px;'
 * : 'class': 'twocol-content', 'style': 'margin-left: 26em; margin-top: -15px;'
 * 
 * Parameters:
 *  col1 - the string or <bbop.html> object for the left column
 *  col2 - the string or <bbop.html> object for the right column
 *
 * Returns:
 *  <bbop.html.tag> subclass
 */
bbop.widget.display.two_column_layout = function (col1, col2){
    bbop.html.tag.call(this, 'div', {'class': 'twocol-wrapper'});

    // Left (control) side.
    this._two_column_stack_left =
	new bbop.html.tag('div',
			  {'class': 'twocol-leftcolumn',
			   'style': 'margin-top: -15px;'},
			  col1);
    this.add_to(this._two_column_stack_left);

    // Right (display) side.
    this._two_column_stack_right =
	new bbop.html.tag('div',
			  {'class': 'twocol-content',
			   'style': 'margin-left: 26em; margin-top: -15px;'},
			  col2);
    this.add_to(this._two_column_stack_right);
};
bbop.widget.display.two_column_layout.prototype = new bbop.html.tag;

/*
 * Package: filter_shield.js
 * 
 * Namespace: bbop.widget.display.filter_shield
 * 
 * BBOP object to produce a self-constructing/self-destructing shield
 * to support very large filter selection in the live search/search
 * pane genre.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.widget == "undefined" ){ bbop.widget = {}; }
if ( typeof bbop.widget.display == "undefined" ){ bbop.widget.display = {}; }

/*
 * Constructor: filter_shield
 * 
 * Contructor for the bbop.widget.display.filter_shield object.
 * 
 * Support for <bbop.widget.search_pane> by way of
 * <bbop.widget.display.live_search>
 * 
 * Arguments:
 *  spinner_img_src - *[optional]* optional source of a spinner image to use
 *  wait_msg - *[optional]* the wait message to use; may be a string or bbop.html; defaults to "Waiting..."
 * 
 * Returns:
 *  self
 */
bbop.widget.display.filter_shield = function(spinner_img_src, wait_msg){

    this._is_a = 'bbop.widget.display.filter_shield';

    var anchor = this;

    // Per-UI logger.
    var logger = new bbop.logger();
    logger.DEBUG = true;
    function ll(str){ logger.kvetch('W (filter_shield): ' + str); }

    // Determine wait_msg, if any.
    if( ! wait_msg ){
	wait_msg = 'Waiting...';
    }else{
	// pass it through
    }

    // Variables that we'll need to keep.
    var is_open_p = false;
    var parea = new bbop.html.tag('div', {'generate_id': true});
    var pmsg = new bbop.html.tag('div', {'generate_id': true}, wait_msg);
    parea.add_to(pmsg);

    var div = new bbop.html.tag('div', {'generate_id': true}, parea);
    var pmsg_id = pmsg.get_id();
    //var pbar_id = pbar.get_id();
    var div_id = div.get_id();
    var diargs = {
	modal: true,
	draggable: false,
	width: 800,
	height: 600,
	close:
	function(){
	    // TODO: Could maybe use .dialog('destroy') instead?
	    jQuery('#' + div_id).remove();
	}	    
    };

    /*
     * Function: start_wait
     * 
     * Render an unpopulated modal shield with some kind of waiting
     * element. This is to act as a block for the IO if
     * desired--calling this before .draw() is not required (as
     * .draw() will call it anyways if you haven't).
     * 
     * Arguments:
     *  n/a
     * 
     * Returns:
     *  n/a
     */
    this.start_wait = function(){

	// Mark that we've finally opened it.
	is_open_p = true;

	// Append div to body.
	jQuery('body').append(div.to_string());	

	// If we have an image source specified, go ahead and add it to
	// the waiting display before popping it open.
	if( spinner_img_src && spinner_img_src != '' ){
	    var s = new bbop.widget.spinner(parea.get_id(), spinner_img_src);
	}

	// Pop open the dialog.
	var dia = jQuery('#' + div_id).dialog(diargs);
    };

    /*
     * Function: draw
     * 
     * Render a temporary modal filter shield.
     * 
     * Arguments:
     *  field_name - the name (id) of the filter field to display
     *  filter_list - a list of [[filter_id, filter_count], ...]
     *  manager - the manager that we'll use for the callbacks
     * 
     * Returns:
     *  n/a
     */
    this.draw = function(field_name, filter_list, manager){
	//ll(doc['id']);

	// Open the shield if it is not already open.
	if( ! is_open_p ){
	    anchor.open();
	}

	var txt = 'No filters...';
	var tbl = new bbop.html.table(null, null, {'generate_id': true});
	var button_hash = {};
	var each = bbop.core.each; // conveience
	var bgen = bbop.widget.display.text_button_sim;
	each(filter_list,
 	     function(field){
		 var fname = field[0];
		 var fcount = field[1];

		 var b_plus = new bgen('+', 'Add positive filter');
		 var b_minus = new bgen('-', 'Add negative filter');
		 button_hash[b_plus.get_id()] =
		     [field_name, fname, fcount, '+'];
		 button_hash[b_minus.get_id()] =
		     [field_name, fname, fcount, '-'];

		 tbl.add_to([fname, '(' + fcount + ')',
			     b_plus.to_string(),
			     b_minus.to_string()]);
	     });
	txt = tbl.to_string();

	// Create a filter slot div.
	
	// Add filter slot and table text to div.
	jQuery('#' + div_id).empty();
	var fdiv = new bbop.html.tag('div', {'generate_id': true});
	jQuery('#' + div_id).append(fdiv.to_string());	
	jQuery('#' + div_id).append(txt);

	// Apply the filter to the table.
	var ft = null;
	if( spinner_img_src && spinner_img_src != '' ){
	    ft = bbop.widget.filter_table(fdiv.get_id(), tbl.get_id(),
					  spinner_img_src, null);
	}else{
	    ft = bbop.widget.filter_table(fdiv.get_id(), tbl.get_id(), null);
	}

	// Okay, now introducing a function that we'll be using a
	// couple of times in our callbacks. Given a button id (from
	// a button hash) and the [field, filter, count, polarity]
	// values from the props, make a button-y thing an active
	// filter.
	function filter_select_live(button_id, create_time_button_props){
	    var in_polarity = create_time_button_props[3];

	    // Decide on the button graphical elements.
	    var b_ui_icon = 'ui-icon-plus';
	    if( in_polarity == '-' ){
		b_ui_icon = 'ui-icon-minus';
	    }
	    var b_ui_props = {
		icons: { primary: b_ui_icon},
		text: false
	    };

	    // Create the button and immediately add the event.
	    jQuery('#' + button_id).click(
		function(){
		    var tid = jQuery(this).attr('id');
		    var call_time_button_props = button_hash[tid];
		    var call_field = call_time_button_props[0];	 
		    var call_filter = call_time_button_props[1];
		    //var in_count = button_props[2];
		    var call_polarity = call_time_button_props[3];
		    
		    // Change manager, fire, and close the dialog.
		    manager.add_query_filter(call_field, call_filter,
			  		     [call_polarity]);
		    manager.search();
		    jQuery('#' + div_id).remove();
		});
	}

	// Now let's go back and add the buttons, styles,
	// events, etc. in the main accordion section.
	each(button_hash, filter_select_live);

    };

};
/*
 * Package: live_search.js
 * 
 * Namespace: bbop.widget.display.live_search
 * 
 * AmiGO object to draw various UI elements that have to do with things
 * dealing with a fully faceted searcher/browser.
 * 
 * It is probably not particularly useful directly, but rather used as
 * the framework for more specialized interfaces.
 * 
 * See Also:
 *  <search_pane.js>
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.widget == "undefined" ){ bbop.widget = {}; }
if ( typeof bbop.widget.display == "undefined" ){ bbop.widget.display = {}; }

/*
 * Constructor: live_search
 * 
 * Contructor for the bbop.widget.display.live_search object.
 * 
 * Arguments:
 *  interface_id - string id of the div to build on
 *  conf_class - <bbop.golr.conf_class> for hints and other settings
 * 
 * Returns:
 *  BBOP GOlr UI object
 */
bbop.widget.display.live_search = function(interface_id, conf_class){

    var anchor = this;
    var each = bbop.core.each;
    
    // Per-UI logger.
    var logger = new bbop.logger();
    logger.DEBUG = false;
    //logger.DEBUG = true;
    function ll(str){ logger.kvetch('UI (search): ' + str); }

    // There should be a string interface_id argument.
    // The class configuration we'll be using to hint and build.
    this.interface_id = interface_id;
    this.class_conf = conf_class;

    // Somebody will probably set these externally at some point.
    this.linker = new bbop.linker();
    this.handler = new bbop.handler();
   
    // We need strong control of the displayed buttons since we're
    // going to make them a dynamic (post-setup) resource.
    //this.button_definitions = button_defs;
    this.button_definitions = [];

    // Get the user interface hook and remove anything that was there.
    var ui_div_id = this.interface_id;
    jQuery('#' + ui_div_id).empty();

    // Mangle everything around this unique id so we don't collide
    // with other instances on the same page.
    var mangle = ui_div_id + '_ui_element_' + bbop.core.uuid() + '_';

    // Render a control section into HTML. This includes the accordion
    // and current filter sections.
    var ui_controls_section_id = mangle + 'ui-controls-wrapper';
    var controls_div = new bbop.html.tag('div', {'id': ui_controls_section_id});
    //jQuery('#' + ui_div_id).append(controls_div.to_string());

    // Render a results section into HTML. The includes the results
    // table and the results meta-info sections.
    var ui_results_section_id = mangle + 'ui-results-wrapper';
    var results_div = new bbop.html.tag('div', {'id': ui_results_section_id});
    //jQuery('#' + ui_div_id).append(results_div.to_string());

    // A dynamic handle (set when rendering results) of the select
    // column control id and item group name.
    var ui_results_selection_control_id = null;
    var ui_results_selection_item_name = null;
    var show_checkboxes_p = false;

    // Add the sections to a two column layout and add that into the
    // main ui div.
    var two_col_div =
	new bbop.widget.display.two_column_layout(controls_div, results_div);
    jQuery('#' + ui_div_id).append(two_col_div.to_string());

    // Main div id hooks to the easily changable areas of the two
    // column display.
    var ui_meta_div_id = mangle + 'meta-id';
    var ui_user_button_div_id = mangle + 'user-button-id';
    var ui_results_table_div_id = mangle + 'results-table-id';
    var ui_count_control_div_id = mangle + 'count_control-id';
    var ui_sticky_filters_div_id = mangle + 'sticky_filters-id';
    var ui_current_filters_div_id = mangle + 'current_filters-id';
    var ui_query_input_id = mangle + 'query-id';
    var ui_clear_query_span_id = mangle + 'clear-query-id';
    var ui_clear_user_filter_span_id = mangle + 'clear-user-filter-id';

    // Globally declared (or not) icons.
    var ui_spinner_search_source = '';
    var ui_spinner_shield_source = '';
    var ui_spinner_shield_message = null;
    var ui_icon_positive_label = '';
    var ui_icon_positive_source = '';
    var ui_icon_negative_label = '';
    var ui_icon_negative_source = '';
    var ui_icon_remove_label = '';
    var ui_icon_remove_source = '';

    // The spinner, if it exists, needs to be accessible by everybody
    // and safe to use.
    var spinner = null;
    function _spinner_gen(elt_id){
	var spinner_args = {
	    //timeout: 5,
	    //timeout: 500,
	    timeout: 10,
	    //classes: 'bbop-widget-search_pane-spinner',
	    visible_p: false
	};
	spinner = new bbop.widget.spinner(elt_id,
					  ui_spinner_search_source,
					  spinner_args);
    }
    function _spin_up(){
	if( spinner ){
	    spinner.start_wait();
	}
    }
    function _spin_down(){
	if( spinner ){
	    spinner.finish_wait();
	}
    }

    // Additional id hooks for easy callbacks. While these are not as
    // easily changable as the above, we use them often enough and
    // across functions to have a hook.
    var accordion_div_id = mangle + 'filter-accordion-id';
    
    // These pointers are used in multiple functions (e.g. both
    // *_setup and *_draw).
    var filter_accordion_widget = null;
    //var current_filters_div = null;

    /*
     * Function: show_checkboxes_p
     *
     * External function to show the item checkboxes in the use interface.
     * 
     * Parameters:
     *  new_setting - *[optional]* show or not; defaults to false
     *
     * Returns:
     *  true/false--the current state of showing the select boxes
     */
    this.show_checkboxes_p = function(new_setting){
	if( bbop.core.is_defined(new_setting) ){
	    if( new_setting ){
		show_checkboxes_p = true;
	    }else{
		show_checkboxes_p = false;		
	    }
	}

	return show_checkboxes_p;
    };

    /*
     * Function: set_linker
     *
     * Set the linker to be used when creating links.
     * If not set, a null function is used.
     * 
     * Parameters:
     *  linker - the linker function to be used
     *
     * Returns:
     *  true/false on whether it was properly set
     */
    this.set_linker = function(linker){

	var retval = false;

	if( bbop.core.is_defined(linker) ){
		anchor.linker = linker;
		retval = true;
	}

	return retval;
    };

    /*
     * Function: set_handler
     *
     * Set the handler to be used when dealing with displaying special fields.
     * If not set, a null function is used.
     * 
     * Parameters:
     *  handler - the handler function to be used
     *
     * Returns:
     *  true/false on whether it was properly set
     */
    this.set_handler = function(handler){

	var retval = false;

	if( bbop.core.is_defined(handler) ){
		anchor.handler = handler;
		retval = true;
	}

	return retval;
    };

    /*
     * Function: selected_name
     *
     * External function to show give the name of the input name group
     * for the selectable items in the checkboxes (if they are being
     * used). Null otherwise.
     * 
     * Keep in mind that this variable changes every times that the
     * results table refreshes.
     * 
     * Parameters:
     *  n/a
     *
     * Returns:
     *  string or null
     */
    this.selected_name = function(){
	return ui_results_selection_item_name;
    };

    /*
     * Function: setup_query
     *
     * Setup the free text query display under contructed tags for
     * later population.
     * 
     * If no icon_clear_source is defined, icon_clear_label will be
     * used as the defining text.
     * 
     * Parameters:
     *  label_str - *[optional]* string or bbop.html for input label
     *  icon_clear_label - *[optional]* string or bbop.html for clear icon
     *  icon_clear_source - *[optional]* string to define the src of img 
     *
     * Returns:
     *  n/a
     */
    this.setup_query = function(label_str, icon_clear_label, icon_clear_source){
	ll('setup_query for: ' + ui_query_input_id);

	// Some defaults.
	if( ! label_str ){ label_str = ''; }
	if( ! icon_clear_label ){ icon_clear_label = ''; }
	if( ! icon_clear_source ){ icon_clear_source = ''; }
	
	// The incoming label.
	var query_label_attrs = {
	    'class': 'bbop-js-search-pane-query-label'
	};
	var query_label_div =
	    new bbop.html.tag('div', query_label_attrs, label_str);

	// The text area.
	var ta_args = {
	    'id': ui_query_input_id,
	    'rows': '1',
	    'class': 'bbop-js-search-pane-textarea'
	};
	var query_area = new bbop.html.tag('textarea', ta_args);

	// Figure out an icon or a label.
	var clear_query_obj =
	    bbop.widget.display.clickable_object(icon_clear_label,
						 icon_clear_source,
						 ui_clear_query_span_id);
	// And a div to put it in.
	var clear_div_attrs = {
	    'class': 'bbop-js-search-pane-clear-button',
	    'generate_id': true
	};
	var clear_div =
	    new bbop.html.tag('div', clear_div_attrs, clear_query_obj);	

	// General container div.
	var gen_div_attrs = {
	    'generate_id': true
	};
	var gen_div = new bbop.html.tag('div', gen_div_attrs);

	// Add to display.
	query_label_div.add_to(clear_div.to_string());
	gen_div.add_to(query_label_div.to_string());
	gen_div.add_to(query_area.to_string());
	jQuery('#' + ui_controls_section_id).append(gen_div.to_string());
    };

    // /*
    //  * Function: setup_count_control
    //  *
    //  * Setup the results count control for later use. This is a kind
    //  * of semi-permanent structure like the accordion.
    //  * 
    //  * Parameters:
    //  *  n/a
    //  *
    //  * Returns:
    //  *  n/a
    //  */
    // this.setup_count_control = function(manager){
    // 	ll('setup_count_control for: ' + ui_query_input_id);
	
    // 	// Create inputs (the current order is important for proper
    // 	// for/id creation).
    // 	var cinputs = [];
    // 	each([10, 25, 50, 100],
    // 	     function(num, cindex){
    // 		 // Create and store the option.
    // 		 var sel_input_attrs = {
    // 		     'generate_id': true,
    // 		     'value': num
    // 		 };
    // 		 var sel_input =
    // 		     new bbop.html.tag('option', sel_input_attrs, num);
    // 		 var sel_input_id = sel_input.get_id();
    // 		 cinputs.push(sel_input);
    // 	     });
    // 	// Option container div.
    // 	var sel_attrs = {
    // 	    'id': ui_count_control_div_id
    // 	};
    // 	var sel = new bbop.html.tag('select', sel_attrs, cinputs);

    // 	// Create a text label.
    // 	var sel_label = new bbop.html.tag('label', {},
    // 					  'Results count&nbsp;&nbsp;');

    // 	// Container div.
    // 	var sel_div_attrs = {
    // 	    'generate_id': true,
    // 	    'class': 'bbop-js-search-pane-results-count'
    // 	};
    // 	var sel_div = new bbop.html.tag('div', sel_div_attrs);

    // 	// Assemble these elements into the UI.
    // 	sel_div.add_to(sel_label);
    // 	sel_div.add_to(sel);
    // 	jQuery('#' + ui_controls_section_id).append(sel_div.to_string());
    // };

    /*
     * Function: setup_sticky_filters
     *
     * Setup sticky filters display under contructed tags for later
     * population. The seeding information is coming in through the
     * GOlr conf class.
     * 
     * Add in the filter state up here.
     * 
     * Parameters:
     *  n/a
     *
     * Returns:
     *  n/a
     */
    this.setup_sticky_filters = function(){
    
	ll('setup_sticky_filters UI for class configuration: ' +
	   this.class_conf.id());

	var sticky_filters_attrs = {
	    'id': ui_sticky_filters_div_id,
	    'class': 'bbop-js-search-pane-sticky-filters'
	};
	var sticky_filters_div =
	    new bbop.html.tag('div', sticky_filters_attrs,
			      "No applied sticky filters.");

	// Add the output to the page.
	var sticky_filters_str = sticky_filters_div.to_string();
	jQuery('#' + ui_controls_section_id).append(sticky_filters_str);
    };

    /*
     * Function: setup_current_filters
     *
     * Setup current filters display under contructed tags for later
     * population. The seeding information is coming in through the
     * GOlr conf class.
     * 
     * Add in the filter state up here.
     * 
     * If no icon_reset_source is defined, icon_reset_label will be
     * used as the defining text.
     * 
     * Parameters:
     *  icon_remove_label - *[optional]* string or bbop.html for remove icon
     *  icon_remove_source - *[optional]* string to define the src of img 
     *
     * Returns:
     *  n/a
     */
    this.setup_current_filters = function(icon_remove_label,icon_remove_source){
	ll('setup_current_filters UI for class configuration: ' +
	   this.class_conf.id());

	// Set the class variables for use when we do the redraws.
	if( icon_remove_label ){ ui_icon_remove_label = icon_remove_label; }
	if( icon_remove_source ){ ui_icon_remove_source = icon_remove_source; }

	// Create the placeholder.
	var current_filters_div =
	    new bbop.html.tag('div', {'id': ui_current_filters_div_id},
			      "No applied user filters.");

	// Add the output to the page.
	var curr_filters_str = current_filters_div.to_string();
	jQuery('#' + ui_controls_section_id).append(curr_filters_str);
    };

    /*
     * Function: setup_accordion
     *
     * Setup the accordion skeleton under contructed tags for later
     * population. The seeding information is coming in through the
     * GOlr conf class.
     * Start building the accordion here. Not an updatable part.
     * 
     * If no icon_*_source is defined, icon_*_label will be
     * used as the defining text.
     * 
     * Parameters:
     *  icon_positive_label - *[optional]* string or bbop.html for positive icon
     *  icon_positive_source - *[optional]* string to define the src of img 
     *  icon_negative_label - *[optional]* string or bbop.html for positive icon
     *  icon_negative_source - *[optional]* string to define the src of img 
     *  spinner_shield_source - *[optional]* string to define the src of img 
     *  spinner_shield_message - *[optional]* string or bbop.html for message 
     *
     * Returns: 
     *  n/a
     */
    this.setup_accordion = function(icon_positive_label, icon_positive_source,
				    icon_negative_label, icon_negative_source,
				    spinner_shield_source,
				    spinner_shield_message){
	
	ll('setup_accordion UI for class configuration: ' +
	   this.class_conf.id());

	// Set the class variables for use when we do the redraws.
	if( spinner_shield_source ){
	    ui_spinner_shield_source = spinner_shield_source; }
	if( spinner_shield_message ){
	    ui_spinner_shield_message = spinner_shield_message; }
	if( icon_positive_label ){
	    ui_icon_positive_label = icon_positive_label; }
	if( icon_positive_source ){
	    ui_icon_positive_source = icon_positive_source; }
	if( icon_negative_label ){
	    ui_icon_negative_label = icon_negative_label; }
	if( icon_negative_source ){
	    ui_icon_negative_source = icon_negative_source; }

	var filter_accordion_attrs = {
	    id: accordion_div_id
	};
	filter_accordion_widget = // heavy lifting by special widget
	    new bbop.html.accordion([], filter_accordion_attrs, true);

	// Add the sections with no contents as a skeleton to be
	// filled by draw_accordion.
	var field_list = this.class_conf.field_order_by_weight('filter');
	each(field_list,
	     function (in_field){
		 ll('saw field: ' + in_field);
		 var ifield = anchor.class_conf.get_field(in_field);
		 var in_attrs = {
		     id: in_field,
		     label: ifield.display_name(),
		     description: ifield.description()
		 };
		 filter_accordion_widget.add_to(in_attrs, '', true);
	     });
	
	// Add the output from the accordion to the page.
	var accordion_str = filter_accordion_widget.to_string();
	jQuery('#' + ui_controls_section_id).append(accordion_str);

	// Add the jQuery accordioning.
	var jqacc_attrs = {
	    clearStyle: true,
	    heightStyle: 'content',
	    collapsible: true,
	    active: false
	};
	jQuery("#" + accordion_div_id).accordion(jqacc_attrs);
    };

    /*
     * Function: setup_results
     *
     * Setup basic results table using the class conf. For actual
     * results rendering, see .draw_results. While there is a meta
     * block supplied, its use is optional.
     * 
     * Argument hash entries:
     *  meta - draw the meta-results; defaults to false
     *  spinner_source - the source of the image to use for the activity spinner
     * 
     * Parameters:
     *  hash; see above for details
     *
     * Returns:
     *  n/a
     */
    this.setup_results = function(args){

	ll('setup_results UI for class configuration: ' + this.class_conf.id());
	
	// Decide whether or not to add the meta div.
	var add_meta_p = false;
	if( args && args['meta'] && args['meta'] == true ){
	    add_meta_p = true;
	}
	// Get the spinner source and set it globally, if there is
	// one.
	var add_spinner_p = false;
	if( args && args['spinner_source'] && args['spinner_source'] != '' ){
	    ui_spinner_search_source = args['spinner_source'];
	    add_spinner_p = true;
	}

	// <div id="results_block" class="block">
	// <h2>Found entities</h2>
	// <div id="load_float"></div>
	// <div id="meta_results">
	// <div id="results_div">
	var block = new bbop.html.tag('div', {'class': 'block'});

	// Add header section.
	var hargs = {
	    generate_id: true,
	    'class': 'bbop-widget-search_pane-spinner-element'
	};
	//var header = new bbop.html.tag('h2', hargs, 'Found entities&nbsp;');
	var header = new bbop.html.tag('h4', hargs, 'Found entities&nbsp;');
	block.add_to(header);

	// If wanted, add meta to display queue.
	if( add_meta_p ){	    
	    var meta_attrs = {
		'id': ui_meta_div_id
	    };
	    var meta = new bbop.html.tag('div', meta_attrs);
	    block.add_to(meta);
	}

	// Add results section.
	var results = new bbop.html.tag('div', {'id': ui_results_table_div_id});
	block.add_to(results);

	jQuery('#' + ui_results_section_id).append(block.to_string());

	// If wanted, add initial render of meta.
	if( add_meta_p ){	    
	    ll('Add meta UI div');
	    jQuery('#' + ui_meta_div_id).empty();
	    var init_str = 'Performing initial search, please wait...';
	    jQuery('#' + ui_meta_div_id).append(init_str);

	    // Optionally, if we have defined the image source, add
	    // the image to the initial waiting.
	    if( ui_spinner_search_source && ui_spinner_search_source != '' ){
		var init_spin_str = '&nbsp;<img src="' +
		    ui_spinner_search_source + '" alt="[waiting]" ' +
		    'class="bbop-js-spinner"/>';
		jQuery('#' + ui_meta_div_id).append(init_spin_str);
	    }

	}

	// Now that the block is added, we can add the spinner to our
	// larger context. Safe access functions defined elsewhere.
	if( add_spinner_p ){
	    _spinner_gen(header.get_id());
	}
    };

    /*
     * Function: draw_user_buttons
     *
     * (Re)draw the user-defined buttons in the meta information area.
     * Will naturally fail if there is no meta div that has been
     * nested with the user button element.
     * 
     * Parameters:
     *  manager - <bbop.golr.manager> that we initially registered with
     *
     * Returns:
     *  n/a
     */
    this.draw_user_buttons = function(manager){
	function _button_rollout(button_def_hash){
	    var default_hash =
    		{
		    label : 'n/a',
		    disabled_p : false,
		    text_p : false,
		    icon : 'ui-icon-help',
		    click_function_generator :
		    function(){
			return function(){
			    alert('No callback defined for this button--' +
				  'the generator may have been empty!');
			};
		    }
    		};
	    var folding_hash = button_def_hash || {};
	    var arg_hash = bbop.core.fold(default_hash, folding_hash);
	    
	    var label = arg_hash['label'];
	    var disabled_p = arg_hash['disabled_p'];
	    var text_p = arg_hash['text_p'];
	    var icon = arg_hash['icon'];
	    var click_function_generator =
		arg_hash['click_function_generator'];
	    
	    var b = new bbop.html.button(label, {'generate_id': true});
	    jQuery('#' + ui_user_button_div_id).append(b.to_string());
	    var b_props = {
		icons: { primary: icon},
		disabled: disabled_p,
		text: text_p
	    };
	    var click_fun = click_function_generator(manager);
	    jQuery('#' + b.get_id()).button(b_props).click(click_fun);
	}

	// Check that we're not about to do the impossible.
	if( ! jQuery('#' + ui_user_button_div_id) ){
	    alert('cannot refresh buttons without a place to draw them');
	}else{
	    jQuery('#' + ui_user_button_div_id).empty();
	    jQuery('#' + ui_user_button_div_id).empty();
	    bbop.core.each(anchor.button_definitions, _button_rollout);
	}
    };

    /*
     * Function: draw_meta
     *
     * Draw meta results. Includes selector for drop down.
     * 
     * (Re)draw the count control with the current information in the
     * manager. This also tries to set the selector to the response
     * number (to keep things in sync), unbinds any current "change"
     * event, and adds a new change event.
     * 
     * Parameters:
     *  response - the <bbop.golr.response> returned from the server
     *  manager - <bbop.golr.manager> that we initially registered with
     *
     * Returns:
     *  n/a
     */
    this.draw_meta = function(response, manager){
	
	ll('draw_meta for: ' + ui_meta_div_id);

	///
	/// Section 1: the numbers display.
	///

	// Collect numbers for display.
	var total_c = response.total_documents();
	var first_d = response.start_document();
	var last_d = response.end_document();

	// Draw meta; the current numbers and page--the same for
	// every type of return.
	jQuery('#' + ui_meta_div_id).empty();
	if( total_c == 0 ){
	    jQuery('#' + ui_meta_div_id).append('No results found.');
	}else{

	    // A div for the literal meta results and the count
	    // selector next to them.
	    var mdiv_attrs = {
	    };
	    var mdiv = new bbop.html.tag('div', mdiv_attrs);

	    // The literal return metadata.
	    var dmeta_attrs = {
		'class': 'bbop-js-search-pane-meta'
	    };
	    var dmeta = new bbop.html.tag('div', dmeta_attrs);
	    dmeta.add_to('Total: ' + total_c +
			 '; showing ' + first_d +
			 '-' + last_d);
	    mdiv.add_to(dmeta);

	    ///
	    /// Section 2: results count.
	    ///

	    // Create inputs (the current order is important for proper
	    // for/id creation).
	    var cinputs = [];
	    each([10, 25, 50, 100],
		 function(num, cindex){
		     // Create and store the option.
		     var sel_input_attrs = {
			 'generate_id': true,
			 'value': num
		     };
		     var sel_input =
			 new bbop.html.tag('option', sel_input_attrs, num);
		     var sel_input_id = sel_input.get_id();
		     cinputs.push(sel_input);
		 });
	    // Option container div.
	    var sel_attrs = {
		'id': ui_count_control_div_id
	    };
	    var sel = new bbop.html.tag('select', sel_attrs, cinputs);
	    
	    // Create a text label.
	    var sel_label_attrs = {
		// 'generate_id': true,
		// 'class': 'bbop-widget-search_pane-spinner-element'
	    };
	    var sel_label = new bbop.html.tag('label', sel_label_attrs,
					      'Results count&nbsp;&nbsp;');
	    
	    // Container div.
	    var sel_div_attrs = {
		'generate_id': true,
		'class': 'bbop-js-search-pane-results-count'
	    };
	    var sel_div = new bbop.html.tag('div', sel_div_attrs);
	    
	    // Assemble these elements into the UI.
	    sel_div.add_to(sel_label);
	    sel_div.add_to(sel);
	    mdiv.add_to(sel_div);

	    // Render out the last two sections.
	    jQuery('#' + ui_meta_div_id).append(mdiv.to_string());
	    
	    ///
	    /// Section 3: results count activity, setting.
	    ///

	    // First, unbind so we don't accidentally trigger with any
	    // changes and don't pile up event handlers.
	    jQuery('#' + ui_count_control_div_id).unbind('change');

	    // Next, pull out the number of rows requested.
	    var step = response.row_step();
	    
	    // Set the value to the number.
	    jQuery('#' + ui_count_control_div_id).val(step);
	    
	    // Finally, reactivate the event handler on the select.
	    jQuery('#' + ui_count_control_div_id).change(
		function(event, ui){
		    var sv = jQuery('#' + ui_count_control_div_id).val();
		    if( bbop.core.is_defined(sv) ){
			// Convert to a number.
			var si = parseInt(sv);
			
			// Set manager and to the search.
			manager.set_results_count(si);
			manager.search();
			// We are now searching--show it.
			_spin_up();
		    }
		});

	    ///
	    /// Section 4: the paging buttons.
	    ///
	    
	    var bdiv_attrs = {
		'generate_id': true
	    };
	    var bdiv = new bbop.html.tag('div', bdiv_attrs);
	    jQuery('#' + ui_meta_div_id).append(bdiv.to_string());
	    var bdiv_id = bdiv.get_id();

	    // Now add the raw buttons to the interface, and after this,
	    // activation and adding events.
	    var b_first = new bbop.html.button('First', {'generate_id': true});
	    //jQuery('#' + ui_meta_div_id).append(b_first.to_string());
	    jQuery('#' + bdiv_id).append(b_first.to_string());
	    var b_back = new bbop.html.button('Prev', {'generate_id': true});
	    //jQuery('#' + ui_meta_div_id).append(b_back.to_string());
	    jQuery('#' + bdiv_id).append(b_back.to_string());
	    var b_forward = new bbop.html.button('Next', {'generate_id': true});
	    //jQuery('#' + ui_meta_div_id).append(b_forward.to_string());
	    jQuery('#' + bdiv_id).append(b_forward.to_string());
	    var b_last = new bbop.html.button('Last', {'generate_id': true});
	    //jQuery('#' + ui_meta_div_id).append(b_last.to_string());
	    jQuery('#' + bdiv_id).append(b_last.to_string());

	    // Do the math about what buttons to activate.
	    var b_first_disabled_p = false;
	    var b_back_disabled_p = false;
	    var b_forward_disabled_p = false;
	    var b_last_disabled_p = false;
	    
	    // Only activate paging if it is necessary to the returns.
	    if( ! response.paging_p() ){
		b_first_disabled_p = true;
		b_back_disabled_p = true;
		b_forward_disabled_p = true;
		b_last_disabled_p = true;
	    }
	    
	    // Don't activate back on the first page.
	    if( ! response.paging_previous_p() ){
		b_first_disabled_p = true;
		b_back_disabled_p = true;
	    }
	    
	    // Don't activate next on the last page.
	    if( ! response.paging_next_p() ){
		b_forward_disabled_p = true;
		b_last_disabled_p = true;
	    }
	    
	    // First page button.
	    var b_first_props = {
		icons: { primary: "ui-icon-seek-first"},
		disabled: b_first_disabled_p,
		text: false
	    };
	    jQuery('#' + b_first.get_id()).button(b_first_props).click(
		function(){
		    // Cheat and trust reset by proxy to work.
		    manager.page_first(); 
		    // We are now searching--show it.
		    _spin_up();
		});
	    
	    // Previous page button.
	    var b_back_props = {
		icons: { primary: "ui-icon-seek-prev"},
		disabled: b_back_disabled_p,
		text: false
	    };
	    jQuery('#' + b_back.get_id()).button(b_back_props).click(
		function(){
		    manager.page_previous();
		    // We are now searching--show it.
		    _spin_up();
		});
	    
	    // Next page button.
	    var b_forward_props = {
		icons: { primary: "ui-icon-seek-next"},
		disabled: b_forward_disabled_p,
		text: false
	    };
	    jQuery('#' + b_forward.get_id()).button(b_forward_props).click(
		function(){
		    manager.page_next();
		    // We are now searching--show it.
		    _spin_up();
		});
	    
	    // Last page button.
	    var b_last_props = {
		icons: { primary: "ui-icon-seek-end"},
		disabled: b_last_disabled_p,
		text: false
	    };
	    jQuery('#' + b_last.get_id()).button(b_last_props).click(
		function(){
		    // A little trickier.
		    manager.page_last(total_c);
		    // We are now searching--show it.
		    _spin_up();
		});
	    
	    ///
	    /// Section 5: the button_definition buttons.
	    ///

	    // Spacer.	    
	    // jQuery('#' + ui_meta_div_id).append('&nbsp;&nbsp;&nbsp;' +
	    // 					'&nbsp;&nbsp;&nbsp;');
	    jQuery('#'+ bdiv_id).append('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;');

	    // (R)establish the user button div to the end of the meta
	    // retults.
	    var ubuttons = new bbop.html.tag('span',
					     {'id': ui_user_button_div_id});
	    //jQuery('#' + ui_meta_div_id).append(ubuttons.to_string());
	    jQuery('#' + bdiv_id).append(ubuttons.to_string());

	    // Add all of the defined buttons after the spacing.
	    anchor.draw_user_buttons(manager);
	}
    };

    // Detect whether or not a keyboard event is ignorable.
    function _ignorable_event(event){

	var retval = false;

	if( event ){
	    var kc = event.keyCode;
	    if( kc ){
		if( kc == 39 || // right
                    kc == 37 || // left
                    kc == 32 || // space
                    kc == 20 || // ctl?
                    kc == 17 || // ctl?
                    kc == 16 || // shift
                    //kc ==  8 || // delete
                    kc ==  0 ){ // super
			ll('ignorable key event: ' + kc);
			retval = true;
		    }
            }
	}
	return retval;
    }

    /*
     * Function: draw_query
     *
     * Draw the query widget. This function makes it active
     * as well.
     * 
     * Clicking the reset button will reset the query to ''.
     * 
     * NOTE: Since this is part of the "persistant" interface (i.e. it
     * does not get wiped after every call), we make sure to clear the
     * event listeners when we redraw the function to prevent them from
     * building up.
     * 
     * Parameters:
     *  response - the <bbop.golr.response> returned from the server
     *  manager - <bbop.golr.manager> that we initially registered with
     *
     * Returns:
     *  n/a
     */
    this.draw_query = function(response, manager){

    	ll('draw_query for: ' + ui_query_input_id);

	// Add a smartish listener.
	jQuery('#' + ui_query_input_id).unbind('keyup');
	jQuery('#' + ui_query_input_id).keyup(
	    function(event){

		// If we're left with a legitimate event, handle it.
		if( ! _ignorable_event(event) ){

		    // Can't ignore it anymore, so it goes into the
		    // manager for testing.
		    var tmp_q = manager.get_query();
		    var input_text = jQuery(this).val();
		    manager.set_query(input_text);

		    // If the manager feels like it's right, trigger.
		    if( manager.sensible_query_p() ){
			ll('keeping set query: ' + input_text);
			// Set the query to be more "usable" just
			// before triggering (so the tests can't be
			// confused by our switch).
			manager.set_comfy_query(input_text);
			manager.search();

			// We are now searching--show it.
			_spin_up();
		    }else{
			ll('rolling back query: ' + tmp_q);		    
			manager.set_query(tmp_q);
		    }
		}
	    });

	// Now reset the clear button and immediately set the event.
	jQuery('#' + ui_clear_query_span_id).unbind('click');
	jQuery('#' + ui_clear_query_span_id).click(
	    function(){
		manager.reset_query();
		//anchor.set_query_field(manager.get_query());
		anchor.set_query_field('');
		manager.search();
		// We are now searching--show it.
		_spin_up();
	    });
    };

    /*
     * Function: reset_query
     *
     * Simply reset the query and then redraw (rebind) the query.
     * 
     * Parameters:
     *  response - the <bbop.golr.response> returned from the server
     *  manager - <bbop.golr.manager> that we initially registered with
     *
     * Returns:
     *  n/a
     * 
     * See:
     *  <draw_query>
     */
    this.reset_query = function(response, manager){

    	ll('reset_query for: ' + ui_query_input_id);

	// Reset manager back to the default.
	manager.reset_query();

	anchor.draw_query(response, manager);
    };

    /*
     * Function: draw_sticky_filters
     *
     * (Re)draw the information on the sticky filter set.
     * 
     * Parameters:
     *  response - the <bbop.golr.response> returned from the server
     *  manager - <bbop.golr.manager> that we initially registered with
     *
     * Returns:
     *  n/a
     */
    this.draw_sticky_filters = function(response, manager){
    
	ll('draw_sticky_filters for: ' + ui_div_id);

	// Add in the actual HTML for the pinned filters and buttons.
	var sticky_query_filters = manager.get_sticky_query_filters();
	ll('sticky filters: ' + bbop.core.dump(sticky_query_filters));
	var fq_list_tbl =
	    new bbop.html.table(['', 'Your search is pinned to these filters'],
				[],
			       	{'class': 'bbop-js-search-pane-filter-table'});
	// [{'filter': A, 'value': B, 'negative_p': C, 'sticky_p': D}, ...]
	each(sticky_query_filters,
	     function(fset){

		 //
		 var sfield = fset['filter'];
		 var sfield_val = fset['value'];

		 // Boolean value to a character.
		 var polarity = fset['negative_p'];
		 var polstr = '+';
		 if( polarity ){ polstr = '-'; }

		 // Generate a button with a unique id.
		 var label_str = polstr + ' ' + sfield + ':' + sfield_val;
		 fq_list_tbl.add_to(['<b>'+ polstr +'</b>',
				     sfield + ': ' + sfield_val]);
	     });
	
	// Either add to the display, or display the "empty" message.
	var sfid = '#' + ui_sticky_filters_div_id;
	jQuery(sfid).empty();
	if( sticky_query_filters.length == 0 ){
	    jQuery(sfid).append("No sticky filters.");
	}else{
	    // Attach to the DOM...
	    jQuery(sfid).append(fq_list_tbl.to_string());
	}
    };

    /*
     * Function: draw_current_filters
     *
     * (Re)draw the information on the current filter set.
     * This function makes them active as well.
     * 
     * Parameters:
     *  response - the <bbop.golr.response> returned from the server
     *  manager - <bbop.golr.manager> that we initially registered with
     *
     * Returns:
     *  n/a
     */
    this.draw_current_filters = function(response, manager){
    
	ll('draw_current_filters for: ' + ui_div_id);

	///
	/// Add in the actual HTML for the filters and buttons. While
	/// doing so, tie a unique id to the filter--we'll use that
	/// later on to add buttons and events to them.
	///

	// First, we need to make the filter clear button for the top
	// of the table.
	var b_cf =
	    new bbop.widget.display.text_button_sim('X', 
						    'Clear all user filters',
						    ui_clear_user_filter_span_id);

	var in_query_filters = response.query_filters();
	//var sticky_query_filters = manager.get_sticky_query_filters();
	ll('filters: ' + bbop.core.dump(in_query_filters));
	var fq_list_tbl =
	    new bbop.html.table(['', 'User filters', b_cf.to_string()],
				[],
			       	{'class': 'bbop-js-search-pane-filter-table'});
	var has_fq_p = false; // assume there are no filters to begin with
	var button_hash = {};
	each(in_query_filters,
	     function(field, field_vals){
		 each(field_vals,
		      function(field_val, polarity){

			  // Make note of stickiness, skip adding if sticky.
			  var qfp =
			      manager.get_query_filter_properties(field,
								  field_val);
			  if( ! qfp || qfp['sticky_p'] == false ){
			  
			      // Note the fact that we actually have a
			      // query filter to work with and display.
			      has_fq_p = true;

			      // Boolean value to a character.
			      var polstr = '-';
			      if( polarity ){ polstr = '+'; }

			      // Generate a button with a unique id.
			      var label_str = polstr+' '+ field +':'+field_val;

			      // Argh! Real jQuery buttons are way too slow!
			      // var b = new bbop.html.button('remove filter',
			      // 		  {'generate_id': true});

			      // Is the "button" a span or an image?
			      var b = bbop.widget.display.clickable_object(
				  ui_icon_remove_label,
				  ui_icon_remove_source,
				  null); // generate_id

			      // Tie the button it to the filter for
			      // jQuery and events attachment later on.
			      var bid = b.get_id();
			      button_hash[bid] = [polstr, field, field_val];
			  
			      //ll(label_str +' '+ bid);
			      //fq_list_tbl.add_to(label_str +' '+ b.to_string());
			      fq_list_tbl.add_to(['<b>'+ polstr +'</b>',
						  field + ': ' + field_val,
						  b.to_string()]);
			      //label_str +' '+ b.to_string());
			  }
		      });
	     });

	// Either add to the display, or display the "empty" message.
	var cfid = '#' + ui_current_filters_div_id;
	jQuery(cfid).empty();
	if( ! has_fq_p ){
	    jQuery(cfid).append("No current user filters.");
	}else{

	    // With this, the buttons will be attached to the
	    // DOM...
	    jQuery(cfid).append(fq_list_tbl.to_string());
	    
	    // First, lets add the reset for all of the filters.
	    jQuery('#' + b_cf.get_id()).click(
		function(){
       		    manager.reset_query_filters();
       		    manager.search();
		    // We are now searching--show it.
		    _spin_up();
		}		
	    );

	    // Now let's go back and add the buttons, styles,
	    // events, etc. to the filters.
	    each(button_hash,
		 function(button_id){
		     var bid = button_id;

		     // // Get the button.
		     // var bprops = {
		     // 	 icons: { primary: "ui-icon-close"},
		     // 	 text: false
		     // };
		     // Create the button and immediately add the event.
		     //jQuery('#' + bid).button(bprops).click(
		     jQuery('#' + bid).click(
			 function(){
			     var tid = jQuery(this).attr('id');
			     var button_props = button_hash[tid];
			     var polstr = button_props[0];
			     var field = button_props[1];
			     var value = button_props[2];

			     // Change manager and fire.
			     // var lstr = polstr +' '+ field +' '+ value;
			     // alert(lstr);
			     // manager.remove_query_filter(field,value,
			     // 				 [polstr, '*']);
			     manager.remove_query_filter(field, value);
			     manager.search();
			     // We are now searching--show it.
			     _spin_up();
			 });
		 });
	}
    };

    /*
     * Function: draw_accordion
     *
     * (Re)draw the information in the accordion controls/filters.
     * This function makes them active as well.
     * 
     * Parameters:
     *  response - the <bbop.golr.response> returned from the server
     *  manager - <bbop.golr.manager> that we initially registered with
     *
     * Returns:
     *  n/a
     */
    this.draw_accordion = function(response, manager){
    
	ll('draw_accordion for: ' + ui_div_id);

	// Make sure that accordion has already been inited.
	if( typeof(filter_accordion_widget) == 'undefined' ){
	    throw new Error('Need to init accordion to use it.');
	}

	// We'll need this in a little bit for calculating when to
	// display the "more" option for the field filters.
	var real_facet_limit = manager.get_facet_limit();
	var curr_facet_limit = real_facet_limit -1; // the facets we'll show

	// We want this so we can filter out any facets that have the
	// same count as the current response total--these facets are
	// pretty much information free.
	var total_docs = response.total_documents();

	// A helper function for when no filters are
	// displayed.
	function _nothing_to_see_here(in_field){
	    var section_id = filter_accordion_widget.get_section_id(in_field);
	    jQuery('#' + section_id).empty();
	    jQuery('#' + section_id).append('Nothing to filter.');
	}

	// Hash where we collect our button information.
	// button_id -> [source, filter, count, polarity];
	var button_hash = {};

	// And a hash to store information to be able to generate the
	// complete filter shields.
	// span_id -> filter_id
	var overflow_hash = {};

	// Cycle through each facet field; all the items in each,
	// create the lists and buttons (while collectong data useful
	// in creating the callbacks) and put them into the accordion.
	each(response.facet_field_list(),
	     function(in_field){

		 var facet_bd = response.facet_field(in_field);
		 if( bbop.core.is_empty(facet_bd) ){
		     
		     // No filters means nothing in the box.
		     _nothing_to_see_here(in_field);

		 }else{
		     
		     // Create ul lists of the facet contents.
		     var tbl_id = mangle + 'filter-list-' + in_field;
		     var facet_list_tbl_attrs = {
			 id: tbl_id
		     };

		     var facet_list_tbl =
			 new bbop.html.table([], [], facet_list_tbl_attrs);
		     
		     ll("consider:" + in_field + ": " +
			response.facet_field(in_field).length);

		     // BUG/TODO:
		     // Count the number of redundant (not shown)
		     // facets so we can at least give a face to this
		     // bug/problem.
		     // Also filter out "empty filters".
		     var redundant_count = 0;
		     // Now go through and get filters and counts.
		     var good_count = 0; // only count when good
		     var overflow_p = false; // true when at 24 -> 25
		     each(response.facet_field(in_field),
			  function(ff_field, ff_index){

			      // Pull out info early so we can test it
			      // for information content.
			      var f_name = ff_field[0];
			      var f_count = ff_field[1];
			      
			      // ll(in_field + ": " + f_name + ": " +
			      // 	 [f_count,
			      // 	  total_docs,
			      // 	  ff_index,
			      // 	  good_count,
			      // 	  redundant_count,
			      // 	  real_facet_limit].join(', '));
			      			      
			      // TODO: The field is likely redundant
			      // (BUG: not always true in closures),
			      // so eliminate it.
			      if( f_count == total_docs ){
				  //ll("\tnothing here");
				  redundant_count++;
			      }else if( ! f_name || f_name == "" ){
				  // Straight out skip if it is an
				  // "empty" facet field.
			      }else if( ff_index < real_facet_limit -1 ){
				  //ll("\tgood row");
				  good_count++;

				  // Create buttons and store them for later
				  // activation with callbacks to
				  // the manager.
				  var b_plus =
				      bbop.widget.display.clickable_object(
					  ui_icon_positive_label,
					  ui_icon_positive_source,
					  null); // generate_id
				  var b_minus =
				      bbop.widget.display.clickable_object(
					  ui_icon_negative_label,
					  ui_icon_negative_source,
					  null); // generate_id
				  
				  // Store in hash for later keying to
				  // event.
				  button_hash[b_plus.get_id()] =
				      [in_field, f_name, f_count, '+'];
				  button_hash[b_minus.get_id()] =
				      [in_field, f_name, f_count, '-'];
				  
				  // // Add the label and buttons to the
				  // // appropriate ul list.
				  //facet_list_ul.add_to(
				  // fstr,b_plus.to_string(),
				  //   b_minus.to_string());
				  // Add the label and buttons to the table.
				  facet_list_tbl.add_to([f_name,
							 '('+ f_count+ ')',
							 b_plus.to_string(),
							 b_minus.to_string()
							]);
			      }
			
			      // This must be logically separated from
			      // the above since we still want to show
			      // more even if all of the top 25 are
			      // redundant.
			      if( ff_index == real_facet_limit -1 ){
				  // Add the more button if we get up to
				  // this many facet rows. This should
				  // only happen on the last possible
				  // iteration.
				  
				  overflow_p = true;
				  //ll( "\tadd [more]");
				  
				  // Since this is the overflow item,
				  // add a span that can be clicked on
				  // to get the full filter list.
				  //ll("Overflow for " + in_field);
				  var bgn = bbop.widget.display.text_button_sim;
				  var b_over =
				      new bgn('more...',
					      'Display the complete list');
				  facet_list_tbl.add_to([b_over.to_string(),
				  			 '', '']);
				  overflow_hash[b_over.get_id()] = in_field;
			      }
			  });

		     // There is a case when we have filtered out all
		     // avilable filters (think db source).
		     if( good_count == 0 && ! overflow_p ){
			 _nothing_to_see_here(in_field);
		     }else{
			 // Otherwise, now add the ul to the
			 // appropriate section of the accordion in
			 // the DOM.
			 var sect_id =
			     filter_accordion_widget.get_section_id(in_field);
			 jQuery('#' + sect_id).empty();

			 // TODO/BUG:
			 // Give warning to the redundant facets.
			 var warn_txt = null;
			 if( redundant_count == 1 ){
			     warn_txt = "field is";
			 }else if( redundant_count > 1 ){
			     warn_txt = "fields are";
			 }
			 if( warn_txt ){
			     jQuery('#' + sect_id).append(
				 "<small> The top (" + redundant_count +
				     ") redundant " + warn_txt + " not shown" +
				     "</small>");
							  
			 }

			 // Add facet table.
			 var final_tbl_str = facet_list_tbl.to_string();
			 jQuery('#' + sect_id).append(final_tbl_str);
		     }
		 }
	     });

	// Okay, now introducing a function that we'll be using a
	// couple of times in our callbacks. Given a button id (from
	// a button hash) and the [field, filter, count, polarity]
	// values from the props, make a button-y thing an active
	// filter.
	function filter_select_live(button_id, create_time_button_props){
	    //var bid = button_id;
	    //var in_field = create_time_button_props[0];	 
	    //var in_filter = create_time_button_props[1];
	    //var in_count = create_time_button_props[2];
	    var in_polarity = create_time_button_props[3];

	    // Decide on the button graphical elements.
	    var b_ui_icon = 'ui-icon-plus';
	    if( in_polarity == '-' ){
		b_ui_icon = 'ui-icon-minus';
	    }
	    var b_ui_props = {
		icons: { primary: b_ui_icon},
		text: false
	    };

	    // Create the button and immediately add the event.
	    //jQuery('#' + button_id).button(b_ui_props).click(
	    jQuery('#' + button_id).click(
		function(){
		    var tid = jQuery(this).attr('id');
		    var call_time_button_props = button_hash[tid];
		    var call_field = call_time_button_props[0];	 
		    var call_filter = call_time_button_props[1];
		    //var in_count = button_props[2];
		    var call_polarity = call_time_button_props[3];
		    
		    // Change manager and fire.
		    // var bstr =call_field+' '+call_filter+' '+call_polarity;
		    // alert(bstr);
		    manager.add_query_filter(call_field, call_filter,
			  		     [call_polarity]);
		    manager.search();
		    // We are now searching--show it.
		    _spin_up();
		});
	}

	// Now let's go back and add the buttons, styles,
	// events, etc. in the main accordion section.
	each(button_hash, filter_select_live);

	// Next, tie the events to the "more" spans.
	each(overflow_hash,
	     function(button_id, filter_name){
		 jQuery('#' + button_id).click(

		     // On click, set that one field to limitless in
		     // the manager, setup a shield, and wait for the
		     // callback.
		     function(){

			 // Recover the field name.
			 var tid = jQuery(this).attr('id');
			 var call_time_field_name = overflow_hash[tid];
			 //alert(call_time_field_name);

			 // Set the manager to no limit on that field and
			 // only rturn the information that we want.
			 manager.set_facet_limit(0);
			 manager.set_facet_limit(call_time_field_name, -1);
			 var curr_row = manager.get('rows');
			 manager.set('rows', 0);

			 // Create the shield and pop-up the
			 // placeholder.
			 var fs = bbop.widget.display.filter_shield;
			 var filter_shield = new fs(ui_spinner_shield_source,
						    ui_spinner_shield_message); 
			 filter_shield.start_wait();

			 // Open the populated shield.
			 function draw_shield(resp){

			    // ll("shield what: " + bbop.core.what_is(resp));
			    // ll("shield resp: " + bbop.core.dump(resp));

			     // First, extract the fields from the
			     // minimal response.
			     var fina = call_time_field_name;
			     var flist = resp.facet_field(call_time_field_name);

			     // Draw the proper contents of the shield.
			     filter_shield.draw(fina, flist, manager);
			 }
			 manager.fetch(draw_shield);

			 // Reset the manager to more sane settings.
			 manager.reset_facet_limit();
			 manager.set('rows', curr_row);
		     });
	     });

	ll('Done current accordion for: ' + ui_div_id);
    };

    /*
     * Function: draw_results
     *
     * Draw results using hints from the golr class configuration.
     * 
     * Parameters:
     *  response - the <bbop.golr.response> returned from the server
     *  manager - <bbop.golr.manager> that we initially registered with
     *
     * Returns:
     *  n/a
     */
    this.draw_results = function(response, manager){
	
	ll('draw_results for: ' + ui_results_table_div_id);

	//ll('final_table a: ' + final_table._is_a);
	//ll('final_table b: ' + final_table.to_string);
	//ll('final_table c: ' + final_table.to_string());

	// Clear whatever is there.
	var urtdi = ui_results_table_div_id;
	jQuery('#' + urtdi).empty();

	// Display product when not empty.
	var docs = response.documents();
	if( ! bbop.core.is_empty(docs) ){
	    var final_table = new bbop.widget.display.results_table_by_class(
		anchor.class_conf,
		response,
		anchor.linker,
		anchor.handler,
		urtdi,
		show_checkboxes_p);

	    // Capture the current name state of the control and
	    // group.
	    ui_results_selection_control_id = final_table.toggle_id();
	    ui_results_selection_item_name = final_table.item_name();

	    // Since we already added to the DOM in the final_table
	    // instantiation above, go ahead and locally add the group
	    // toggle if the checkboxes are defined.
	    if( ui_results_selection_control_id &&
		ui_results_selection_item_name ){
		    jQuery('#' + ui_results_selection_control_id).click(
			function(){
			    var cstr = 'input[id=' +
				ui_results_selection_control_id +
				']';
			    var nstr = 'input[name=' +
				ui_results_selection_item_name +
				']';
			    if( jQuery(cstr).prop('checked') ){
				jQuery(nstr).prop('checked', true);
			    }else{
				jQuery(nstr).prop('checked', false);
			    }
			});
	    }
	}

	// Our search obviously came back.
	_spin_down();

	// If it looks like we enabled the checkboxes, go ahead and
	// activate the group toggle for them.
	
    };

    /*
     * Function: draw_error
     *
     * Somehow report an error to the user.
     * 
     * Parameters:
     *  error_message - a string(?) describing the error
     *  manager - <bbop.golr.manager> that we initially registered with
     *
     * Returns:
     *  n/a
     */
    this.draw_error = function(error_message, manager){
	ll("draw_error: " + error_message);
	alert("Runtime error: " + error_message);
	_spin_down();
    };

    /*
     * Function: set_buttons
     *
     * Set the list of buttons for display by changing the button
     * definition hash list.
     * 
     * If no buttons are set, the list is cleared.
     * 
     * Parameters:
     *  button_def_list - *[optional]*
     *
     * Returns:
     *  n/a
     */
    this.set_buttons = function(button_def_list){
	if( ! button_def_list ){
	    button_def_list = [];
	}
	ll("changing buttons: to " + button_def_list.length +
	   " from " + anchor.button_definitions.length);
	anchor.button_definitions = button_def_list;
    };

    /*
     * Function: set_query_field
     *
     * Set the text in the search query field box.
     * 
     * If no query is set, the field is cleared.
     * 
     * Parameters:
     *  query - *[optional]* string
     *
     * Returns:
     *  true or false on whether the task was accomplished
     */
    this.set_query_field = function(query){
	var retval = false;
	if( ! query ){
	    query = '';
	}
	if( jQuery('#' + ui_query_input_id) ){
	    ll("changing query search field: to " + query);
	    jQuery('#' + ui_query_input_id).val(query);
	    //jQuery('#' + ui_query_input_id).keyup();
	    retval = true;
	}
	return retval;
    };
};
/*
 * Package: spinner.js
 * 
 * Namespace: bbop.widget.spinner
 * 
 * BBOP object to produce a self-constructing/self-destructing
 * spinner. It can display various spinner/throbber images and can
 * have a set timeout to deal with annoying servers and exotic race
 * conditions.
 * 
 * The class of the spinner image is "bbop-widget-spinner".
 * 
 * Visibility is controlled by the application and removal of
 * "bbop-js-spinner-hidden".
 * 
 * This is a completely self-contained UI.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.widget == "undefined" ){ bbop.widget = {}; }

/*
 * Constructor: spinner
 * 
 * Contructor for the bbop.widget.spinner object.
 * 
 * A trivial invocation might be something like:
 * : var s = new bbop.widget.spinner("inf01", "http://localhost/amigo2/images/waiting_ajax.gif");
 * : s.hide();
 * : s.show();
 * 
 * Or, in a slightly different use case:
 * 
 * : var s = new bbop.widget.spinner("inf01", "http://localhost/amigo2/images/waiting_ajax.gif", {'timout': 5});
 * : s.start_wait();
 * 
 * The optional hash arguments look like:
 *  timeout - the number of seconds to wait before invoking <clear_waits>; 0 indicates waiting forever; defaults to 5
 *  visible_p - whether or not the spinner is visible on initialization; true|false; defaults to true
 *  classes - a string of space-separated classes that you want added to the spinner image
 * 
 * Arguments:
 *  host_elt_id - string id of the place to place the widget
 *  img_src - the URL for the image to use in the spinner
 *  argument_hash - *[optional]* optional hash of optional arguments
 * 
 * Returns:
 *  self
 */
bbop.widget.spinner = function(host_elt_id, img_src, argument_hash){
    
    this._is_a = 'bbop.widget.spinner';

    var anchor = this;

    // Per-UI logger.
    var logger = new bbop.logger();
    logger.DEBUG = false;
    //logger.DEBUG = true;
    function ll(str){ logger.kvetch('W (spinner): ' + str); }

    // Our argument default hash.
    var default_hash = {
	'timeout': 5,
	'visible_p': true,
	'classes': ''
    };
    var folding_hash = argument_hash || {};
    var arg_hash = bbop.core.fold(default_hash, folding_hash);

    // Spin out arguments.
    var timeout = arg_hash['timeout'];
    var visible_p = arg_hash['visible_p'];
    var classes = arg_hash['classes'];

    ///
    /// Part 1: Append the image into the given element id.
    ///

    // Use the incoming arguments to help determine the default
    // classes on the element.'
    var spinner_classes = ['bbop-js-spinner'];
    if( ! visible_p ){
	spinner_classes.push('bbop-js-spinner-hidden');
    }
    if( classes && classes != '' ){
	spinner_classes.push(classes);
    }

    // Create new element.
    var spinner_elt =
	new bbop.html.image({'generate_id': true,
			     'src': img_src,
			     'title': "Please wait...",
			     'class': spinner_classes.join(' '),
			     'alt': "(waiting...)"});
    var spinner_elt_id = spinner_elt.get_id();

    // Append img to end of given element.
    jQuery('#' + host_elt_id).append(spinner_elt.to_string());
    
    ///
    /// Part 2: Dynamic display management.
    ///

    // Counts and accounting.
    var current_waits = 0;
    var timeout_queue = [];

    /*
     * Function: show
     * 
     * Show the spinner if it is hidden (regardless of current waits).
     * 
     * Parameters:
     *  n/a
     * 
     * Returns
     *  n/a
     */
    this.show = function(){
	ll("show");
	jQuery('#' + spinner_elt_id).removeClass('bbop-js-spinner-hidden');	

	// If the timeout is defined, push a timer onto
	// the queue.
	function _on_timeout(){
	    anchor.finish_wait();
	}
	if( timeout > 0 ){
	    setTimeout(_on_timeout, (timeout * 1000));
	}
	// foo=setTimeout(function(){}, 1000);
	// clearTimeout(foo);
    };

    /*
     * Function: hide
     * 
     * Hide the spinner if it is showing (regardless of current waits).
     * 
     * Parameters:
     *  n/a
     * 
     * Returns
     *  n/a
     */
    this.hide = function(){
	ll("hide");
	jQuery('#' + spinner_elt_id).addClass('bbop-js-spinner-hidden');	
    };

    /*
     * Function: start_wait
     * 
     * Displays the initial spinner if it is not already displayed and
     * adds one to the wait count.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns
     *  n/a
     */
    this.start_wait = function(){

	ll("Start outstanding waits: " + current_waits);

	// 
	if( current_waits == 0 ){
	    anchor.show();
	}

	current_waits++;
    };

    /*
     * Function: finish_wait
     * 
     * Removes one from the wait count and hides the spinner if the
     * number of outstanding waits has reached zero.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns
     *  n/a
     */
    this.finish_wait = function(){

	ll("Finish outstanding waits: " + current_waits);

	// Stay at least at 0--we might have stragglers or incoming
	// after a reset.
	if( current_waits > 0 ){
	    current_waits--;	    
	}

	// Gone if we are not waiting for anything.
	if( current_waits == 0 ){
	    anchor.hide();
	}
    };

    /*
     * Function: clear_waits
     * 
     * Hides the spinner and resets all the waiting counters. Can be
     * used during things like server errors or collisions.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns
     *  n/a
     */
    this.clear_waits = function(){
	current_waits = 0;
	anchor.hide();
    };
};
/*
 * Package: filter_table.js
 * 
 * Namespace: bbop.widget.filter_table
 * 
 * Create a dynamic filter for removing rows from a table (where the
 * rows are inside of a tbody).
 * 
 * The repaint_func argument takes the table id as its argument. If a
 * function is not specified, the default function will do nothing.
 */

// YANKED: ...apply the classes "even_row" and "odd_row" to the table.

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.widget == "undefined" ){ bbop.widget = {}; }

/*
 * Method: filter_table
 * 
 * The table needs to keep the row information in a tbody, not just at
 * the top level.
 * 
 * Arguments:
 *  elt_id - the element to inject the filter into
 *  table_id - the table that we will operate on
 *  img_src - *[optional]* img source URL for the spinner image (defaults to no spinner)
 *  repaint_func - the repaint function to run after filtering (see above)
 *  label - *[optional]* the label to use for the filter
 * 
 * Returns:
 *  n/a
 */
bbop.widget.filter_table = function(elt_id, table_id, img_src,
				    repaint_func, label){
    this._is_a = 'bbop.widget.filter_table';

    var anchor = this;
    
    var logger = new bbop.logger();
    //logger.DEBUG = true;
    logger.DEBUG = false;
    function ll(str){ logger.kvetch(str); }

    ll('init filter_table in ' + elt_id + ' for ' + table_id);

    // Sort out spinner image source.
    anchor.img_src = null;
    if( img_src ){
	anchor.img_src = img_src;
    }

    // Sort out repaint function.
    anchor.repaint_func = 
    	function (tid){};	
    // function (tid){
    //     jQuery('table#' + tid + ' tr:even').attr('class', 'even_row');
    //     jQuery('table#' + tid + ' tr:odd').attr('class', 'odd_row');
    // };
    if( repaint_func ){
    	anchor.repaint_func = repaint_func;
    }

    // Sort out label.
    anchor.label = 'Filter:';
    if( label ){
	anchor.label = label;
    }

    ll('finished args');

    // Create a label, input field, and a clear button.
    var input_attrs = {
	'type': 'text',
	'class': 'form-control bbop-js-filter-table-input',
	'value': '',
	'generate_id': true
    };
    var input = new bbop.html.input(input_attrs);

    var lbl_attrs = {
	'for': input.get_id(),
	'generate_id': true
    };
    var lbl = new bbop.html.tag('label', lbl_attrs, anchor.label);

    var clear_button_attrs ={
	'type': 'button',
	'class': 'btn btn-danger',
	'title': 'Clear filter',
	'generate_id': true
    };
    var clear_button =
	//new bbop.widget.display.text_button_sim('&times;', 'Clear filter');
	new bbop.html.button('&times;', clear_button_attrs);

    var cont_attrs = {
	'class': 'form-inline'
    };
    var cont = new bbop.html.tag('div', cont_attrs, [lbl, input,
						     clear_button]);

    ll('widget gen done');

    // And add them to the DOM at the location.
    jQuery('#' + elt_id).empty();
    jQuery('#' + elt_id).append(cont.to_string());

    // Also, attach a spinner.
    var spinner = null;
    if( anchor.img_src ){
	jQuery('#' + elt_id).append('&nbsp;&nbsp;');
	spinner = new bbop.widget.spinner(elt_id, anchor.img_src,
					 {
					     visible_p: false
					 });
    }
    
    ll('widget addition done');

    // Make the clear button active.
    jQuery('#' + clear_button.get_id()).click(
	function(){
	    ll('click call');
	    if( spinner ){ spinner.show(); }
            jQuery('#' + input.get_id()).val('');
	    trs.show();
	    // Recolor after filtering.
	    anchor.repaint_func(table_id);
	    if( spinner ){ spinner.hide(); }
	});

    // Cache information about the table.
    var trs = jQuery('#' + table_id + ' tbody > tr');
    var tds = trs.children();

    // Make the table filter active.
    jQuery('#' + input.get_id()).keyup(
	function(){

	    if( spinner ){ spinner.show(); }

            var stext = jQuery(this).val();

	    ll('keyup call: (' + stext + '), ' + trs);

	    if( ! bbop.core.is_defined(stext) || stext == "" ){
		// Restore when nothing found.
		trs.show();
	    }else{
		// Want this to be insensitive.
		stext = stext.toLowerCase();

		// All rows (the whole table) gets hidden.
		trs.hide();

		// jQuery filter to match element contents against
		// stext.
		function _match_filter(){
		    var retval = false;
		    var lc = jQuery(this).text().toLowerCase();
		    if( lc.indexOf(stext) >= 0 ){
			retval = true;
		    }
		    return retval;
		}

		// If a td has a match, the parent (tr) gets shown.
		// Or: show only matching rows.
		tds.filter(_match_filter).parent("tr").show();
            }

	    // Recolor after filtering.
	    anchor.repaint_func(table_id);

	    if( spinner ){ spinner.hide(); }
	});
};
/*
 * Package: browse.js
 * 
 * Namespace: bbop.widget.browse
 * 
 * BBOP object to draw various UI elements that have to do with
 * autocompletion.
 * 
 * This is a completely self-contained UI and manager.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.widget == "undefined" ){ bbop.widget = {}; }

/*
 * Constructor: browse
 * 
 * Contructor for the bbop.widget.browse object.
 * 
 * This is a specialized (and widgetized) subclass of
 * <bbop.golr.manager.jquery>.
 * 
 * While everything in the argument hash is technically optional,
 * there are probably some fields that you'll want to fill out to make
 * things work decently. The options for the argument hash are:
 * 
 *  topology_graph_field -  the field for the topology graph
 *  transitivity_graph_field - the field for the transitivity graph
 *  info_button_callback - functio to call when info clicked, gets doc
 *  base_icon_url - the url base that the fragments will be added to
 *  image_type - 'gif', 'png', etc.
 *  current_icon - the icon fragment for the current term
 *  info_icon - the icon fragment for the information icon
 *  info_alt - the alt text and title for the information icon
 * 
 * The basic formula for the icons is: base_icon_url + '/' + icon +
 * '.' + image_type; then all spaces are turned to underscores and all
 * uppercase letters are converted into lowercase letters.
 * 
 * The functions for the callbacks look like function(<term acc>,
 * <json data for the specific document>){}. If no function is given,
 * an empty function is used.
 * 
 * Arguments:
 *  golr_loc - string url to GOlr server;
 *  golr_conf_obj - a <bbop.golr.conf> object
 *  interface_id - string id of the element to build on
 *  in_argument_hash - *[optional]* optional hash of optional arguments
 * 
 * Returns:
 *  this object
 */
bbop.widget.browse = function(golr_loc, golr_conf_obj, interface_id,
			      in_argument_hash){

    // Per-UI logger.
    var logger = new bbop.logger();
    logger.DEBUG = true;
    function ll(str){ logger.kvetch('B (widget): ' + str); }

    bbop.golr.manager.jquery.call(this, golr_loc, golr_conf_obj);
    this._is_a = 'bbop.widget.browse';
    // ll("what_is (post: this.update): " + bbop.core.what_is(this.update));

    // 
    var anchor = this;
    var loop = bbop.core.each;
    
    // Our argument default hash.
    var default_hash =
	{
	    'topology_graph_field' : 'topology_graph_json',
	    'transitivity_graph_field' : 'transitivity_graph_json',
	    //'transitivity_graph_field' : 'regulates_transitivity_graph_json',
	    'info_button_callback' : function(){},
	    'base_icon_url' : null,
	    'image_type' : 'gif',
	    'current_icon' : 'this',
	    'info_icon' : 'info',
	    'info_alt' : 'Click for more information.'
	};
    var folding_hash = in_argument_hash || {};
    var arg_hash = bbop.core.fold(default_hash, folding_hash);

    // There should be a string interface_id argument.
    this._interface_id = interface_id;
    this._info_button_callback = arg_hash['info_button_callback'];
    var topo_graph_field = arg_hash['topology_graph_field'];
    var trans_graph_field = arg_hash['transitivity_graph_field'];
    var base_icon_url = arg_hash['base_icon_url'];
    var image_type = arg_hash['image_type'];
    var current_icon = arg_hash['current_icon'];
    var info_icon = arg_hash['info_icon'];
    var info_alt = arg_hash['info_alt'];
   
    // The current acc that we are interested in.
    this._current_acc = null;

    // Successful callbacks call draw_rich_layout.
    anchor.register('search', 'do', draw_rich_layout);

    // Recursively draw a rich layout using nested uls.
    function draw_rich_layout(resp){
	
	///
	/// Get the rich layout from the returned document if
	/// possible. Note the use of JSON, supplied by jQuery,
	/// instead of out internal method bbop.json.parse.
	///
	var doc = resp.documents()[0];

	var topo_graph = new bbop.model.bracket.graph();
	topo_graph.load_json(JSON.parse(doc[topo_graph_field]));

	var trans_graph = new bbop.model.graph();
	trans_graph.load_json(JSON.parse(doc[trans_graph_field]));

	//ll('to: ' + doc['topology_graph']);
	//ll('tr: ' + doc['transitivity_graph']);
	//ll('ro: ' + anchor._current_acc);
	//ll('g: ' + topo_graph.get_parent_nodes(anchor._current_acc));
	var rich_layout = topo_graph.rich_bracket_layout(anchor._current_acc,
							 trans_graph);
	//ll("rl: " + bbop.core.dump(rich_layout));

	///
	/// Next, produce the raw HTML skeleton.
	/// TODO: Keep a cache of the interesting ids for adding
	/// events later.
	///

	// I guess we'll just start by making the list.
	var tl_attrs = {
	    'class': 'bbop-js-ui-browse'
	};
	var top_level = new bbop.html.list([], tl_attrs);

	// Store the navigation anf info buttons.
	var nav_button_hash = {};
	var info_button_hash = {};

	// Cycle down through the brackets, adding spaces every time
	// we go down another level.
	var spacing = '&nbsp;&nbsp;&nbsp;&nbsp;';
	var spaces = spacing;
	loop(rich_layout, // for every level
	     function(layout_level){
		 loop(layout_level, // for every item at this level
		      function(level_item){			  

			  var nid = level_item[0];
			  var lbl = level_item[1];
			  var rel = level_item[2];
			  
			  // For various sections, decide to run image
			  // (img) or text code depending on whether
			  // or not it looks like we have a real URL.
			  var use_img_p = true;
			  if( base_icon_url == null || base_icon_url == '' ){
			      use_img_p = false;
			  }

			  // Clickable acc span.
			  // No images, so the same either way. Ignore
			  // it if we're current.
			  var nav_b = null;
			  if(anchor._current_acc == nid){
			      var inact_attrs = {
				  'class': 'bbop-js-text-button-sim-inactive',
				  'title': 'Current term.'
			      };
			      nav_b = new bbop.html.span(nid, inact_attrs);
			  }else{
			      var tbs = bbop.widget.display.text_button_sim;
			      var bttn_title =
				  'Reorient neighborhood onto this node (' +
				  nid + ').';
			      nav_b = new tbs(nid, bttn_title);
			      nav_button_hash[nav_b.get_id()] = nid;
			  }

			  // Clickable info span. A little difference
			  // if we have images.
			  var info_b = null;
			  if( use_img_p ){
			      // Do the icon version.
			      var imgsrc = bbop.core.resourcify(base_icon_url,
								info_icon,
								image_type);
			      info_b =
				  new bbop.html.image({'alt': info_alt,
						       'title': info_alt,
				  		       'src': imgsrc,
				  		       'generate_id': true});
			  }else{
			      // Do a text-only version.
			      info_b =
				  new bbop.html.span('<b>[i]</b>',
						     {'generate_id': true});
			  }
			  info_button_hash[info_b.get_id()] = nid;

			  // "Icon". If base_icon_url is defined as
			  // something try for images, otherwise fall
			  // back to this text ick.
			  var icon = null;
			  if( use_img_p ){
			      // Do the icon version.
			      var ialt = '[' + rel + ']';
			      var isrc = null;
			      if(anchor._current_acc == nid){
				  isrc = bbop.core.resourcify(base_icon_url,
			      				      current_icon,
							      image_type);
			      }else{
				  isrc = bbop.core.resourcify(base_icon_url,
			      				      rel, image_type);
			      }
			      icon =
				  new bbop.html.image({'alt': ialt,
						       'title': rel,
				  		       'src': isrc,
				  		       'generate_id': true});
			  }else{
			      // Do a text-only version.
			      if(anchor._current_acc == nid){
				  icon = '[[->]]';
			      }else if( rel && rel.length && rel.length > 0 ){
				  icon = '[' + rel + ']';
			      }else{
				  icon = '[???]';
			      }
			  }

			  // Stack the info, with the additional
			  // spaces, into the div.
			  top_level.add_to(spaces,
					   icon,
					   nav_b.to_string(),
					   lbl,
					   info_b.to_string());
		      }); 
		 spaces = spaces + spacing;
	     }); 

	// Add the skeleton to the doc.
	jQuery('#' + anchor._interface_id).empty();
	jQuery('#' + anchor._interface_id).append(top_level.to_string());

	///
	/// Finally, attach any events to the browser HTML doc.
	///

	// Navigation.
	loop(nav_button_hash,
	     function(button_id, node_id){

		 jQuery('#' + button_id).click(
		     function(){
			 var tid = jQuery(this).attr('id');
			 var call_time_node_id = nav_button_hash[tid];
			 //alert(call_time_node_id);
			 anchor.draw_browser(call_time_node_id);
		     });
	     });

	// Information.
	loop(info_button_hash,
	     function(button_id, node_id){

		 jQuery('#' + button_id).click(
		     function(){
			 var tid = jQuery(this).attr('id');
			 var call_time_node_id = info_button_hash[tid];
			 var call_time_doc = resp.get_doc(call_time_node_id);
			 anchor._info_button_callback(call_time_node_id,
						      call_time_doc);
		     });
	     });
    }
	
    /*
     * Function: draw_browser
     * 
     * Bootstraps the process.
     * 
     * Parameters:
     *  term_acc - acc of term we want to have as the term of interest
     * 
     * Returns
     *  n/a
     */
    //bbop.widget.browse.prototype.draw_browser = function(term_acc){
    // this._current_acc = term_acc;
    // this.set_id(term_acc);
    // this.update('search');
    this.draw_browser = function(term_acc){
	anchor._current_acc = term_acc;
	anchor.set_id(term_acc);
	anchor.update('search');
    };
    
};
bbop.core.extend(bbop.widget.browse, bbop.golr.manager.jquery);
/*
 * Package: search_box.js
 * 
 * Namespace: bbop.widget.search_box
 * 
 * BBOP object to draw various UI elements that have to do with
 * autocompletion.
 * 
 * This is a completely self-contained UI and manager.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.widget == "undefined" ){ bbop.widget = {}; }

/*
 * Constructor: search_box
 * 
 * Contructor for the bbop.widget.search_box object.
 * 
 * This is a specialized (and widgetized) subclass of
 * <bbop.golr.manager.jquery>.
 * 
 * The function for the callback argument should either accept a
 * JSONized solr document representing the selected item or null
 * (nothing found).
 * 
 * While everything in the argument hash is technically optional,
 * there are probably some fields that you'll want to fill out to make
 * things work decently. The options for the argument hash are:
 * 
 *  fill_p - whether or not to fill the input with the val on select (default true)
 *  label_template - string template for dropdown, can use any document field
 *  value_template - string template for selected, can use any document field
 *  additional_results_class - class to add to the pop-up autocomplete ul tag when there are more results than are shown in the results
 *  minimum_length - wait for this many characters to start (default 3)
 *  list_select_callback - function takes a json solr doc on dropdown selection
 * 
 * To get a better idea on how to use the templates, see the demo page
 * at http://cdn.berkeleybop.org/jsapi/bbop-js/demo/index.html and
 * read the documentation for <bbop.template>.
 * 
 * Arguments:
 *  golr_loc - string url to GOlr server;
 *  golr_conf_obj - a <bbop.golr.conf> object
 *  interface_id - string id of the element to build on
 *  in_argument_hash - *[optional]* optional hash of optional arguments
 * 
 * Returns:
 *  this object
 */
bbop.widget.search_box = function(golr_loc,
				  golr_conf_obj,
				  interface_id,
				  in_argument_hash){
    bbop.golr.manager.jquery.call(this, golr_loc, golr_conf_obj);
    this._is_a = 'bbop.widget.search_box';

    // Aliases.
    var anchor = this;
    var loop = bbop.core.each;
    
    // Per-UI logger.
    var logger = new bbop.logger();
    logger.DEBUG = true;
    function ll(str){ logger.kvetch('W (auto): ' + str); }

    // Our argument default hash.
    var default_hash =
	{
	    'fill_p': true,
	    'label_template': '{{id}}',
	    'value_template': '{{id}}',
	    'additional_results_class': '',
	    'minimum_length': 3, // wait for three characters or more
	    'list_select_callback': function(){}
	};
    var folding_hash = in_argument_hash || {};
    var arg_hash = bbop.core.fold(default_hash, folding_hash);

    // There should be a string interface_id argument.
    this._interface_id = interface_id;
    this._fill_p = arg_hash['fill_p'];
    this._list_select_callback = arg_hash['list_select_callback'];
    var label_tt = new bbop.template(arg_hash['label_template']);
    var value_tt = new bbop.template(arg_hash['value_template']);
    var ar_class = arg_hash['additional_results_class'];
    var minlen = arg_hash['minimum_length'];
    // The document  return counts. Need  tri-state here since 0  is a
    // legit return.
    var result_count = null;
    var return_count = null;

    // The all-important argument hash. See:
    // http://jqueryui.com/demos/autocomplete/#method-widget
    var auto_args = {
	minLength: minlen,
	// Function for a successful data hit.
	// The data getter, which is making it all more complicated
	// than it needs to be...we need to close around those
	// callback hooks so we have to do it inplace here.
	source: function(request_data, response_hook) {
	    anchor.jq_vars['success'] = function(json_data){
		var retlist = [];
		var resp = new bbop.golr.response(json_data);

		// Reset the last return; remember: tri-state.
		result_count = null;
		return_count = null;

		if( resp.success() ){

		    // Get best shot at document counts.
		    result_count = resp.total_documents();
		    return_count = resp.documents().length;

		    loop(resp.documents(),
			 function(doc){

			     // First, try and pull what we can out of our
			     var lbl = label_tt.fill(doc);

			     // Now the same thing for the return/value.
			     var val = value_tt.fill(doc);

			     // Add the discovered items to the return
			     // save.
			     var item = {
				 'label': lbl,
				 'value': val,
				 'document': doc
			     };
			     retlist.push(item);
			 });
		}
		response_hook(retlist);
	    };

	    // Get the selected term into the manager and fire.
	    //anchor.set_query(request_data.term);
	    anchor.set_comfy_query(request_data.term);
	    anchor.JQ.ajax(anchor.get_query_url(), anchor.jq_vars);
	},
	// What to do when an element is selected.
	select: function(event, ui){

	    // Prevent default selection input filling action (from
	    // jQuery UI) when non-default marked.
	    if( ! anchor._fill_p ){
		event.preventDefault();		
	    }

	    var doc_to_apply = null;
	    if( ui.item ){
		doc_to_apply = ui.item.document;
	    }

	    // Only do the callback if it is defined.
	    if( doc_to_apply && 
		bbop.core.is_defined(anchor._list_select_callback) ){
		anchor._list_select_callback(doc_to_apply);
	    }
	},
	// What to do when a search is completed.
	response: function(event, ui){
	    // if(	result_count != null && return_count != null ){ // possible
	    // 	if( result_count > return_count ){
	    // 	    //console.log('incomplete listing');
	    // 	    var item = {
	    // 		'label': '...',
	    // 		'value': null,
	    // 		'document': null
	    // 	    };
	    // 	    ui.content.push(item);
	    // 	}else{
	    // 	    //console.log('complete listing');
	    // 	}
	    // }
	}
    };

    // Set the ball rolling (attach jQuery autocomplete to doc).
    var jac = jQuery('#' + anchor._interface_id).autocomplete(auto_args);

    // Add our render override.
    // Extension point to get the additional
    jac.data('ui-autocomplete')._renderMenu = function(ul, items){

	// Allow standard menu construction delegation.
	var anchor = this;
	loop(items, function(item){
	    anchor._renderItemData(ul, item);
	});
	
	// Add a special class to the UL if there are results that
	// are not shown.
	if( ar_class && ar_class != '' ){
	    jQuery(ul).removeClass(ar_class); // default no
	    if( result_count != null && return_count != null ){ // possible
		console.log('res_c: ' + result_count);
		console.log('ret_c: ' + return_count);
		if( result_count > return_count ){
		    // If 
		    jQuery(ul).addClass(ar_class);
		}
	    }
	}
    };

    /*
     * Function: destroy
     * 
     * Remove the autocomplete and functionality from the DOM.
     * 
     * Arguments:
     *  n/a
     * 
     * Returns:
     *  n/a
     */
    this.destroy = function(){
	jQuery('#' + anchor._interface_id).autocomplete('destroy');
    };

    /*
     * Function: content
     * 
     * Get the current text contents of the search box.
     * 
     * Arguments:
     *  n/a
     * 
     * Returns:
     *  string
     */
    this.content = function(){
	return jQuery('#' + anchor._interface_id).val();
    };

};
bbop.core.extend(bbop.widget.search_box, bbop.golr.manager.jquery);
/*
 * Package: dialog.js
 * 
 * Namespace: bbop.widget.dialog
 * 
 * BBOP object to produce a self-constructing/self-destructing
 * jQuery popup dialog.
 * 
 * This is a completely self-contained UI.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.widget == "undefined" ){ bbop.widget = {}; }

/*
 * Constructor: dialog
 * 
 * Contructor for the bbop.widget.dialog object.
 * 
 * The optional hash arguments look like:
 * 
 * Arguments:
 *  item - string or bbop.html to display.
 *  in_argument_hash - *[optional]* optional hash of optional arguments
 * 
 * Returns:
 *  self
 */
bbop.widget.dialog = function(item, in_argument_hash){
    
    this._is_a = 'bbop.widget.dialog';

    var anchor = this;

    // Per-UI logger.
    var logger = new bbop.logger();
    logger.DEBUG = true;
    function ll(str){ logger.kvetch('W (dialog): ' + str); }

    // Our argument default hash.
    var default_hash = {
	//modal: true,
	//draggable: false,
	width: 300, // the jQuery default anyways
	title: '',
	buttons: null,
	close:
	function(){
	    // TODO: Could maybe use .dialog('destroy') instead?
	    jQuery('#' + div_id).remove();
	}
    };
    var folding_hash = in_argument_hash || {};
    var arg_hash = bbop.core.fold(default_hash, folding_hash);

    // Not an argument for the dialog, so remove it.
    var title = arg_hash['title'];
    delete arg_hash['title'];

    ///
    /// Actually draw.
    ///

    // Coerce our argument into a string.
    var str = item || 'Nothing here...';
    if( bbop.core.what_is(item) != 'string' ){
	str = item.to_string();
    }

    // Create new div.
    var div = new bbop.html.tag('div', {'generate_id': true, title: title});
    var div_id = div.get_id();

    // Append div to end of body.
    jQuery('body').append(div.to_string());
    
    // Add text to div.
    jQuery('#' + div_id).append(str);
    
    // Boink!
    var dia = jQuery('#' + div_id).dialog(arg_hash);
};
/*
 * Package: term_shield.js
 * 
 * Namespace: bbop.widget.term_shield
 * 
 * BBOP object to produce a self-constructing/self-destructing term
 * information shield.
 * 
 * This is a completely self-contained UI and manager.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.widget == "undefined" ){ bbop.widget = {}; }

/*
 * Constructor: term_shield
 * 
 * Contructor for the bbop.widget.term_shield object.
 * 
 * This is (sometimes) a specialized (and widgetized) subclass of
 * <bbop.golr.manager.jquery>.
 * 
 * To actually do much useful, you should set the personality of the
 * widget.
 * 
 * The optional hash arguments look like:
 * 
 *  linker - a "linker" object
 *  width - defaults to 700
 * 
 * Arguments:
 *  golr_loc - string url to GOlr server; not needed if local
 *  golr_conf_obj - a <bbop.golr.conf> object
 *  in_argument_hash - *[optional]* optional hash of optional arguments
 * 
 * Returns:
 *  self
 */
bbop.widget.term_shield = function(golr_loc, golr_conf_obj, in_argument_hash){
    
    bbop.golr.manager.jquery.call(this, golr_loc, golr_conf_obj);
    this._is_a = 'bbop.widget.term_shield';

    var anchor = this;

    // Per-UI logger.
    var logger = new bbop.logger();
    logger.DEBUG = true;
    function ll(str){ logger.kvetch('W (term_shield): ' + str); }

    // Our argument default hash.
    var default_hash = {
	'linker_function': function(){},
	'width': 700
    };
    var folding_hash = in_argument_hash || {};
    var arg_hash = bbop.core.fold(default_hash, folding_hash);
    var width = arg_hash['width'];
    var linker = arg_hash['linker_function'];

    // Draw a locally help Solr response doc.
    function _draw_local_doc(doc){
	
	//ll(doc['id']);

	var personality = anchor.get_personality();
	var cclass = golr_conf_obj.get_class(personality);

	var txt = 'Nothing here...';
	if( doc && cclass ){

	    var tbl = new bbop.html.table();
	    var results_order = cclass.field_order_by_weight('result');
	    var each = bbop.core.each; // convenience
	    each(results_order,
		 function(fid){
		     // 
		     var field = cclass.get_field(fid);
		     var val = doc[fid];

		     // Determine if we have a list that we're working
		     // with or not.
		     if( field.is_multi() ){

			 if( val ){
			     val = val.join(', ');
			 }else{
			     val = 'n/a';
			 }

		     }else{

			 // When handling just the single value, see
			 // if we can link out the value.
			 var link = null;
			 if( val ){
			     //link = linker.anchor({id: val});
			     //link = linker.anchor({id: val}, 'term');
			     link = linker.anchor({id: val}, fid);
			     if( link ){ val = link; }
			 }else{
			     val = 'n/a';
			 }
		     }

		     tbl.add_to([field.display_name(), val]);
		 });
	    txt = tbl.to_string();
	}

	// Create div.
	var div = new bbop.html.tag('div', {'generate_id': true});
	var div_id = div.get_id();

	// Append div to body.
	jQuery('body').append(div.to_string());

	// Add text to div.
	jQuery('#' + div_id).append(txt);

	// Modal dialogify div; include self-destruct.
	var diargs = {
	    modal: true,
	    draggable: false,
	    width: width,
	    close:
	    function(){
		// TODO: Could maybe use .dialog('destroy') instead?
		jQuery('#' + div_id).remove();
	    }	    
	};
	var dia = jQuery('#' + div_id).dialog(diargs);
    }

    // Get a doc by id from a remote server then display it when it
    // gets local.
    // TODO: spinner?
    function _draw_remote_id(id_string){
	function _process_resp(resp){
	    var doc = resp.get_doc(0);
	    _draw_local_doc(doc);
	}
	anchor.register('search', 'do', _process_resp);
	anchor.set_id(id_string);
	//ll('FOO: ' + id_string);
	anchor.search();
    }

    /*
     * Function: draw
     * 
     * Render a temporary modal information shield. 
     * 
     * Arguments:
     *  item - either a document id or a Solr-returned document
     * 
     * Returns:
     *  n/a
     */
    this.draw = function(item){
    // Call the render directly if we already have a document,
    // otherwise, if it seems like a string (potential id), do a
    // callback on it and pull the doc out.
	if( bbop.core.what_is(item) == 'string' ){
	    _draw_remote_id(item);
	}else{
	    _draw_local_doc(item);
	}
    };
    
};
bbop.core.extend(bbop.widget.term_shield, bbop.golr.manager.jquery);
/*
 * Package: list_select_shield.js
 * 
 * Namespace: bbop.widget.list_select_shield
 * 
 * BBOP object to produce a self-constructing/self-destructing term
 * information shield.
 * 
 * A simple invocation could be:
 * 
 * : new bbop.widget.list_select_shield({title: 'foo', blurb: 'explanation', list_of_lists: [[['a', 'b'], ['c', 'd', true]], [[1, 2], [3, 4]]], title_list: ['title 1', 'title 2'], action: function(selected_args){ alert(selected_args.join(', '));}})
 * 
 * This is a completely self-contained UI and manager.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.widget == "undefined" ){ bbop.widget = {}; }

/*
 * Constructor: list_select_shield
 * 
 * Contructor for the bbop.widget.list_select_shield object.
 * 
 * The purpose of this object to to create a popup that 1) display
 * multiple lists for the user to select from and 2) triggers an
 * action (by function argument) to act on the list selections.
 * 
 * The "list_of_lists" argument is a list of lists structured like:
 * : [[[label, value, nil|true|false], ...], ...]
 * 
 * Items that are true will appear as pre-checked when the lists come
 * up.
 * 
 * The "action" argument is a function that takes a list of selected
 * values.
 * 
 * The argument hash looks like:
 *  title - *[optional]* the title to be displayed 
 *  blurb - *[optional]* a text chunk to explain the point of the action
 *  title_list - a list of titles/explanations for the lists
 *  list_of_lists - a list of lists (see above)
 *  action - *[optional] * the action function to be triggered (see above, defaults to no-op)
 *  width - *[optional]* width as px integer (defaults to 800)
 * 
 * Arguments:
 *  in_argument_hash - hash of arguments (see above)
 * 
 * Returns:
 *  self
 */
bbop.widget.list_select_shield = function(in_argument_hash){    
    this._is_a = 'bbop.widget.list_select_shield';

    var anchor = this;

    // Per-UI logger.
    var logger = new bbop.logger();
    logger.DEBUG = true;
    function ll(str){ logger.kvetch('W (list_select_shield): ' + str); }

    // Aliases.
    var each = bbop.core.each;
    var uuid = bbop.core.uuid;
    
    // Our argument default hash.
    var default_hash = {
	'title': '',
	'blurb': '',
	'title_list': [],
	'list_of_lists': [],
	'action': function(){},
	'width': 800
    };
    var folding_hash = in_argument_hash || {};
    var arg_hash = bbop.core.fold(default_hash, folding_hash);
    var title = arg_hash['title'];
    var blurb = arg_hash['blurb'];
    var title_list = arg_hash['title_list'];
    var list_of_lists = arg_hash['list_of_lists'];
    var action = arg_hash['action'];
    var width = arg_hash['width'];

    // Cache the group names as we go so we can pull them out later
    // when we scan for checked items.
    var group_cache = [];
    function _draw_radio_list(list){

	var list_cache = [];
	var rdo_grp = 'bbop_js_lss_' + uuid();
	group_cache.push(rdo_grp);

	each(list,
	     function(item){

		 var lbl = item[0];
		 var val = item[1];
		 var ckt = item[2] || false;

		 //ll('lbl: ' + lbl);
		 //ll('val: ' + val);
		 //ll('ckt: ' + ckt);

		 // Radio button.	 
		 var rdo_attrs = {
		     'generate_id': true,
		     'name': rdo_grp,
		     'type': 'radio',
		     'value': val
		 };
		 if( ckt ){
		     rdo_attrs['checked'] = 'checked';
		 }
		 var rdo = new bbop.html.input(rdo_attrs);
		 //ll('rdo: ' + rdo.to_string());

		 // Label for it.
		 var rdo_lbl_attrs = {
		     'for': rdo.get_id()
		 };
		 var rdo_lbl = new bbop.html.tag('label', rdo_lbl_attrs,
						 '&nbsp;' + lbl);
		 //ll('rdo_lbl: ' + rdo_lbl.to_string());

		 // And a span to capture both.
		 var rdo_span_attrs = {
		 };
		 var rdo_span = new bbop.html.span('', rdo_span_attrs);
		 //ll('rdo_span (1): ' + rdo_span.to_string());
		 rdo_span.add_to(rdo);
		 //ll('rdo_span (2): ' + rdo_span.to_string());
		 rdo_span.add_to(rdo_lbl);
		 //ll('rdo_span (3): ' + rdo_span.to_string());

		 // Now /this/ goes into the list.
		 list_cache.push(rdo_span);
	     });

	// Now we have a list of all the items, put them into a UL
	// element.
	var ul_list_attrs = {
	    'generate_id': true,
	    'class': 'bbop-js-ui-list-select-shield-list'
	};
	var ul_list = new bbop.html.list(list_cache, ul_list_attrs);

	// ...and send it back.
	return ul_list;
    }

    // Append super container div to body.
    var div = new bbop.html.tag('div', {'generate_id': true});
    var div_id = div.get_id();
    jQuery('body').append(div.to_string());

    // Add title and blurb to div.
    jQuery('#' + div_id).append('<p>' + blurb + '</p>');

    // Add the table of lists to div.
    var cont_table_attrs = {
	'class': 'bbop-js-ui-list-select-shield-table'
    };
    var tbl = new bbop.html.table(title_list, [], cont_table_attrs);
    var lol_cache = []; // not funny: list of lists
    each(list_of_lists,
	 function(sub_list){
	     lol_cache.push(_draw_radio_list(sub_list));
	 });
    tbl.add_to(lol_cache);
    jQuery('#' + div_id).append(tbl.to_string());

    // Finally, add a clickable button to that calls the action
    // function. (Itself embedded in a container div to help move it
    // around.)
    var cont_div_attrs = {
	'class': 'bbop-js-ui-dialog-button-right',
	'generate_id': true
    };
    var cont_div = new bbop.html.tag('div', cont_div_attrs);
    var cont_btn_attrs = {
	//'class': 'bbop-js-ui-dialog-button-right'
    };
    var cont_btn = new bbop.widget.display.text_button_sim('Continue',
							   'Click to continue',
							   null,
							   cont_btn_attrs);
    cont_div.add_to(cont_btn);
    jQuery('#' + div_id).append(cont_div.to_string());

    // Since we've technically added the button, back it clickable
    // Note that this is very much radio button specific.
    jQuery('#' + cont_btn.get_id()).click(
	function(){
	    // Jimmy values out from above by cycling over the
	    // collected groups.
	    var selected = [];
	    each(group_cache,
		 function(gname){
		     var find_str = 'input[name=' + gname + ']';
		     var val = null;
		     jQuery(find_str).each(
			 function(){
			     if( this.checked ){
				 val = jQuery(this).val();
			     }
			     // }else{
			     // 	 selected.push(null);
			     //}
			 });
		     selected.push(val);
		 });

	    // Calls those values with our action function.
	    action(selected);

	    // And destroy ourself.
	    jQuery('#' + div_id).remove();
	});

    // Modal dialogify div; include self-destruct.
    var diargs = {
	'title': title,
	'modal': true,
	'draggable': false,
	'width': width,
	'close':
	function(){
	    // TODO: Could maybe use .dialog('destroy') instead?
	    jQuery('#' + div_id).remove();
	}	    
    };
    var dia = jQuery('#' + div_id).dialog(diargs);
};
/*
 * Package: drop_select_shield.js
 * 
 * Namespace: bbop.widget.drop_select_shield
 * 
 * BBOP object to produce a self-constructing/self-destructing DnD
 * selection and ordering shield.
 * 
 * A simple invocation could be:
 * 
 * : new bbop.widget.drop_select_shield({title: 'foo', blurb: 'explanation', pool_list: [['a', 'b'], ['c', 'd']], selected_list [['a', 'b']], action: function(selected_items){ alert(selected_items.join(', '));}})
 * 
 * This is a completely self-contained UI and manager.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.widget == "undefined" ){ bbop.widget = {}; }

/*
 * Constructor: drop_select_shield
 * 
 * Contructor for the bbop.widget.drop_select_shield object.
 * 
 * The purpose of this object to to create a popup that 1) displays a
 * drag selectable and reorderable list of items and 2) define an
 * action (by function argument) to act on the selection.
 * 
 * The list arguments take the form of: ["label", "id"].
 * 
 * The "action" argument is a function that takes a list of selected
 * ids.
 * 
 * The argument hash looks like:
 *  title - *[optional]* the title to be displayed 
 *  blurb - *[optional]* a text chunk to explain the point of the action
 *  pool_list - a list of lists (see above)
 *  selected_list - a list of lists (see above)
 *  action_label - *[optional] * defaults to "Select"
 *  action - *[optional] * the action function to be triggered (see above, defaults to no-op)
 *  width - *[optional]* width as px integer (defaults to 800)
 * 
 * Arguments:
 *  in_argument_hash - hash of arguments (see above)
 * 
 * Returns:
 *  self
 */
bbop.widget.drop_select_shield = function(in_argument_hash){    
    this._is_a = 'bbop.widget.drop_select_shield';

    var anchor = this;

    // Per-UI logger.
    var logger = new bbop.logger();
    logger.DEBUG = true;
    function ll(str){ logger.kvetch('W (drop_select_shield): ' + str); }

    // Aliases.
    var each = bbop.core.each;
    var uuid = bbop.core.uuid;
    
    // Our argument default hash.
    var default_hash = {
	'title': '',
	'blurb': '',
	'pool_list': [],
	'selected_list': [],
	'action_label': 'Select',
	'action': function(){},
	'width': 800
    };
    var folding_hash = in_argument_hash || {};
    var arg_hash = bbop.core.fold(default_hash, folding_hash);
    var title = arg_hash['title'];
    var blurb = arg_hash['blurb'];
    var pool_list = arg_hash['pool_list'];
    var selected_list = arg_hash['selected_list'];
    var action_label = arg_hash['action_label'];
    var action = arg_hash['action'];
    var width = arg_hash['width'];

    // Create a random class that we'll use as a connector later.
    var rclass = 'bbop-js-ui-dss-rclass-'+ bbop.core.randomness(20);

    // Get the pool and selected lists into html form for loading into
    // the frame table.
    var li_attrs = {
	'class': 'ui-state-default bbop-js-ui-hoverable'
	//'class': 'bbop-js-ui-hoverable'
    };
    var ul_src_list_attrs = {
    	'generate_id': true,
	'class': 'bbop-js-ui-drop-select-shield ' + rclass
    };
    var pool_ul_list = new bbop.html.list([], ul_src_list_attrs);
    each(pool_list,
    	 function(item){	     
    	     var lbl = item[0];
    	     var val = item[1];
    	     //ll('lbl: ' + lbl);
    	     //ll('val: ' + val);
	     li_attrs['value'] = val;
	     var cntnt = '' +
		 '<span class="ui-icon ui-icon-arrow-4"></span> ' +
		 '' + lbl + ' (' + val + ')' + 
		 '';
	     var li_elt = new bbop.html.tag('li', li_attrs, cntnt);
	     pool_ul_list.add_to(li_elt);
    	 });
    var ul_target_list_attrs = {
    	'generate_id': true,
	'class':
	'bbop-js-ui-drop-select-shield bbop-js-ui-drop-select-shield-target ' +
	    rclass
    };
    var selected_ul_list = new bbop.html.list([], ul_target_list_attrs);
    each(selected_list,
    	 function(item){
    	     var lbl = item[0];
    	     var val = item[1];
    	     //ll('lbl: ' + lbl);
    	     //ll('val: ' + val);
	     li_attrs['value'] = val;
	     var cntnt = '' +
		 '<span class="ui-icon ui-icon-arrow-4"></span> ' +
		 '' + lbl + ' (' + val + ')' + 
		 '';
	     var li_elt = new bbop.html.tag('li', li_attrs, cntnt);
	     selected_ul_list.add_to(li_elt);
    	 });

    // Append super container div to body.
    var div = new bbop.html.tag('div', {'generate_id': true});
    var div_id = div.get_id();
    jQuery('body').append(div.to_string());

    // Add title and blurb to div.
    jQuery('#' + div_id).append('<p>' + blurb + '</p>');

    // Add the table frame to the div.
    var tbl = new bbop.html.table(['Available pool', 'Selected fields'],
				  [[pool_ul_list, selected_ul_list]],
				  {'class':
				   'bbop-js-ui-drop-select-shield-frame'});
    jQuery('#' + div_id).append(tbl.to_string());

    // Make the lists operable.
    var pul_id = pool_ul_list.get_id();
    var sul_id = selected_ul_list.get_id();
    jQuery('#'+pul_id+',#'+sul_id ).sortable(
	{connectWith: '.' + rclass}
    ).disableSelection();

    // Helper function to pull the values.
    // Currently, JQuery adds a lot of extra non-attributes li
    // tags when it creates the DnD, so filter those out to
    // get just the fields ids.
    function _get_selected(){
    	var ret_list = [];
	var selected_strings =
	    jQuery('#'+ sul_id).sortable('toArray', {'attribute': 'value'});
    	each(selected_strings,
    	     function(in_thing){
		 if( in_thing && in_thing != '' ){
		     ret_list.push(in_thing);
		 }
	     });
	return ret_list;
    }

    // Buttons for final dialog.
    var mod_buttons = {};
    mod_buttons[action_label] =
    	function(event){
    	    var final_selected = _get_selected();

    	    // Calls those values with our action function.
    	    action(final_selected);

    	    // And destroy ourself.
    	    jQuery('#' + div_id).remove();
    	};
    mod_buttons['Cancel'] =
	function(event, selected_items){
    	    jQuery('#' + div_id).remove();
	};

    // Modal dialogify div; include self-destruct.
    var diargs = {
	'title': title,
	'modal': true,
	'draggable': false,
	'width': width,
	'buttons': mod_buttons,
	'close':
	function(){
	    //jQuery(this).dialog('destroy');
	    jQuery(this).remove();
	}	    
    };
    var dia = jQuery('#' + div_id).dialog(diargs);    
};
/*
 * Package: search_pane.js
 * 
 * Namespace: bbop.widget.search_pane
 * 
 * BBOP object to produce a self-constructing/self-destructing term
 * general filtering search tool for an index. This is a completely
 * self-contained UI and manager.
 * 
 * The function ".establish_display()" must be run *after* an initial
 * personality is set. Also, in many use cases, you'll want to have a
 * line like the following before running ".establish_display()":
 * sp_widget.add_query_filter('document_category', 'annotation',
 * ['*']);
 * 
 * Also, establish_display() literally just establishes the physical
 * presence of the display. To actually populate it with data once you
 * start, a seeding call to the .reset() or .search() is necessary.
 * 
 * The search pane will display one less filter row than is set with
 * .set_facet_limit(), it will use this runover to decide whether or
 * not to display the "more" option for the filters.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.widget == "undefined" ){ bbop.widget = {}; }

/*
 * Constructor: search_pane
 * 
 * Contructor for the bbop.widget.search_pane object.
 * 
 * This is a specialized (and widgetized) subclass of
 * <bbop.golr.manager.jquery>.
 * 
 * Sticky filters (see manager documentation) are "hidden" from the
 * user in all displays.
 * 
 * The optional hash arguments look like:
 * 
 *  linker - the linker to be used; null function otherwise
 *  handler - special field handler to be used; null function otherwise
 *  show_filterbox_p - show currents filters and accordion (default true)
 *  show_pager_p - show the results pager (default true)
 *  show_checkboxes_p - show/enable the item select checkboxes (default true)
 *  spinner_search_source - source for the spinner used during typical searching
 *  spinner_shield_source - source for the spinner used shield waiting
 *  spinner_shield_message - message to display on the spinner shield while waiting
 *  icon_clear_label - (default: text button based on 'X')
 *  icon_clear_source - (default: '')
 *  icon_reset_label - (default: text button based on 'X')
 *  icon_reset_source - (default: '')
 *  icon_positive_label - (default: text button based on '+')
 *  icon_positive_source - (default: '')
 *  icon_negative_label - (default: text button based on '-')
 *  icon_negative_source - (default: '')
 *  icon_remove_label - (default: text button based on 'X')
 *  icon_remove_source - (default: '')
 * 
 * Arguments:
 *  golr_loc - string url to GOlr server; not needed if local
 *  golr_conf_obj - a <bbop.golr.conf> object
 *  interface_id - string id of the element to build on
 *  in_argument_hash - *[optional]* optional hash of optional arguments
 * 
 * Returns:
 *  self
 */
bbop.widget.search_pane = function(golr_loc, golr_conf_obj, interface_id,
				   in_argument_hash){

    // Per-UI logger.
    var logger = new bbop.logger();
    logger.DEBUG = true;
    function ll(str){ logger.kvetch('SP (widget): ' + str); }    

    bbop.golr.manager.jquery.call(this, golr_loc, golr_conf_obj);
    this._is_a = 'bbop.widget.search_pane';
    // ll("what_is (post: this.update): " + bbop.core.what_is(this.update));

    // ...
    var anchor = this;

    // We need to keep a handle on the live_search ui component so we
    // can manipulate the buttons after the fact.
    this.ui = null;
    this.user_buttons = [];

    // It's also good to know if the display has actually been
    // established yet (e.g. the user-defined buttons being added
    // before can have the redraw not happen, since there is nothing
    // there yet and they will be draw naturally when the display
    // finally is.
    this.established_p = false;

    // A special set for a single run after the first reset.
    this.initial_reset_p = true;
    this.initial_reset_callback =
	function(response, manager){ ll('empty first run'); };

    // Our argument default hash.
    function _button_wrapper(str, title){
	var b = new bbop.widget.display.text_button_sim(str, title, '');
	return b.to_string();
    }
    var default_hash =
    	{
    	    //'layout_type' : 'two-column',
	    'linker': new bbop.linker(),
	    'handler': new bbop.handler(),
    	    'show_searchbox_p' : true,
    	    'show_filterbox_p' : true,
    	    'show_pager_p' : true,
    	    'show_checkboxes_p' : true,
    	    'spinner_search_source' : '',
    	    'spinner_shield_source' : '',
    	    'spinner_shield_message' : null,
	    'icon_clear_label': _button_wrapper('X', 'Clear text from query'),
	    'icon_clear_source': '',
	    'icon_reset_label': _button_wrapper('!','Reset user query filters'),
	    'icon_reset_source': '',
	    'icon_positive_label': _button_wrapper('+', 'Add positive filter'),
	    'icon_positive_source': '',
	    'icon_negative_label': _button_wrapper('-', 'Add negative filter'),
	    'icon_negative_source': '',
	    'icon_remove_label':_button_wrapper('X','Remove filter from query'),
	    'icon_remove_source': ''
    	};
    var folding_hash = in_argument_hash || {};
    var arg_hash = bbop.core.fold(default_hash, folding_hash);

    // Pull args into variables.
    //var base_icon_url = arg_hash['base_icon_url'];
    //var image_type = arg_hash['image_type'];
    //var layout_type = arg_hash['layout_type'];
    var linker = arg_hash['linker'];
    var handler = arg_hash['handler'];
    var show_searchbox_p = arg_hash['show_searchbox_p'];
    var show_filterbox_p = arg_hash['show_filterbox_p'];
    var show_pager_p = arg_hash['show_pager_p'];
    var show_checkboxes_p = arg_hash['show_checkboxes_p'];
    var spinner_search_source = arg_hash['spinner_search_source'];
    var spinner_shield_source = arg_hash['spinner_shield_source'];
    var spinner_shield_message = arg_hash['spinner_shield_message'];
    var icon_clear_label = arg_hash['icon_clear_label'];
    var icon_clear_source = arg_hash['icon_clear_source'];
    var icon_reset_label = arg_hash['icon_reset_label'];
    var icon_reset_source = arg_hash['icon_reset_source'];
    var icon_positive_label = arg_hash['icon_positive_label'];
    var icon_positive_source = arg_hash['icon_positive_source'];
    var icon_negative_label = arg_hash['icon_negative_label'];
    var icon_negative_source = arg_hash['icon_negative_source'];
    var icon_remove_label = arg_hash['icon_remove_label'];
    var icon_remove_source = arg_hash['icon_remove_source'];

    /*
     * Function: establish_display
     * 
     * Completely redraw the display.
     * 
     * Required to display after setting up the manager.
     * 
     * Also may be useful after a major change to the manager to reset
     * it.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns
     *  n/a
     */
    this.establish_display = function(){
	
    	// Blow away whatever was there completely.
    	jQuery('#' + interface_id).empty();

    	// Can only make a display if there is a set
    	// personality--there is no general default and it is an
    	// error.
    	var personality = anchor.get_personality();
    	var cclass = golr_conf_obj.get_class(personality);
    	if( ! personality || ! cclass ){
    	    ll('ERROR: no usable personality set');
    	    throw new Error('ERROR: no useable personality set');
    	}

    	///
    	/// Setup UI and bind it to events.
    	///
	
	anchor.ui = new bbop.widget.display.live_search(interface_id, cclass);
	// And add the correct handlers.
	anchor.ui.set_linker(linker);
	anchor.ui.set_handler(handler);

	// Try to add any buttons that we have loafing around into the
	// initial setup.
	anchor.ui.set_buttons(anchor.user_buttons);

	// IF want to show the checkboxes, get them in now.
	if( show_checkboxes_p ){
	    anchor.ui.show_checkboxes_p(true);
	}

	///
    	/// Things to do on every reset event. Essentially re-draw
    	/// everything.
	///

    	if( show_searchbox_p ){ // conditionally display search box stuff
    	    anchor.register('reset', 'reset_query', anchor.ui.reset_query, -1);
	}
    	if( show_filterbox_p ){ // conditionally display filter stuff
    	    anchor.register('reset', 'sticky_first',
    			    anchor.ui.draw_sticky_filters, -1);
    	    anchor.register('reset', 'curr_first',
    			    anchor.ui.draw_current_filters, -1);
    	    anchor.register('reset', 'accordion_first',
    			    anchor.ui.draw_accordion, -1);
    	}
    	// We're always showing meta and results.
    	anchor.register('reset', 'meta_first', anchor.ui.draw_meta, -1);
    	anchor.register('reset', 'results_first', anchor.ui.draw_results, -1);
	
	// Finally, we're going to add a first run behavior here.
	// We'll wrap the user-defined function into a 
	function _initial_runner(response, manager){
	    // I can't just remove the callback from the register
	    // after the first run because it would be reconstituted
	    // every time it was reset (established).
	    if( anchor.initial_reset_p ){
		anchor.initial_reset_p = false;
		anchor.initial_reset_callback(response, manager);
		//ll('unregister: ' + anchor.unregister('reset', 'first_run'));
	    }
	}
    	anchor.register('reset', 'initial_reset', _initial_runner, -100);

	///
    	/// Things to do on every search event.
	///

    	if( show_searchbox_p ){ // conditionally display search box stuff
	    // TODO: I worry a little about this being rebound after
	    // every keyboard event, but rationally, considering the
	    // rebinds and redraws that are happening down in the
	    // accordion, that seems a little silly.
    	    anchor.register('search', 'draw_query', anchor.ui.draw_query, -1);
	}
    	if( show_filterbox_p ){ // conditionally display filter stuff
    	    anchor.register('search','sticky_filters_std',
    			    anchor.ui.draw_sticky_filters);
    	    anchor.register('search','curr_filters_std',
    			    anchor.ui.draw_current_filters);
    	    anchor.register('search', 'accordion_std',
			    anchor.ui.draw_accordion);
    	}
    	// These will always be updated after a search.
    	anchor.register('search', 'meta_usual', anchor.ui.draw_meta);
    	anchor.register('search', 'results_usual', anchor.ui.draw_results);
	
    	// Things to do on an error.
    	anchor.register('error', 'results_unusual', anchor.ui.draw_error);	
	
    	// Setup the gross frames for the filters and results.
    	if( show_searchbox_p ){ // conditionally display search box stuff
    	    anchor.ui.setup_query('Free-text filtering',
				  icon_clear_label,
				  icon_clear_source);
	}
    	if( show_filterbox_p ){ // conditionally display filter stuff
    	    anchor.ui.setup_sticky_filters();
    	    anchor.ui.setup_current_filters(icon_remove_label,
					    icon_remove_source);
    	    anchor.ui.setup_accordion(icon_positive_label,
				      icon_positive_source,
				      icon_negative_label,
				      icon_negative_source,
				      spinner_shield_source,
				      spinner_shield_message);
	}
    	anchor.ui.setup_results({'meta': show_pager_p,
				 'spinner_source': spinner_search_source});
	
    	// // Start the ball with a reset event.
    	//anchor.reset();

	// The display has been established.
	anchor.established_p = true;
    };

    /*
     * Function: get_selected_items
     * 
     * The idea is to return a list of the items selected (with
     * checkboxes) in the display. This means that there are three
     * possibilities. 1) We are not using checkboxes or the display
     * has not been established, so we return null; 2) no or all items
     * have been selected, so we get back an empty list (all == none
     * in our view); 3) a subset list of strings (ids).
     * 
     * NOTE: Naturally, does not function until the display is established.
     * 
     * Parameters:
     *  n/a
     *
     * Returns
     *  string list or null
     */
    this.get_selected_items = function(){
	var retval = null;

	// 
	var gname = anchor.ui.selected_name();
	if( gname ){
	    retval = [];

	    // Cycle through and pull out the values of the checked
	    // ones.
	    var total_count = 0;
	    var nstr = 'input[name=' + gname + ']';
	    jQuery(nstr).each(
		function(){
		    if( this.checked ){
			var val = jQuery(this).val();
			retval.push(val);
		    }
		    total_count++;
		});

	    // If we are selecting all of the items on this page, that
	    // is the same as not selecting any in our world, so reset
	    // and warn.
	    if( total_count > 0 && total_count == retval.length ){
		alert('You can "select" all of the items on a results page by not selecting any (all being the default). This will also get your results processed faster and cause significantly less overhead on the servers.');
		retval = [];
	    }	    
	}

	return retval;
    };

    /*
     * Function: add_button
     * 
     * Add a user-defined button to the display.
     * 
     * NOTE: Does not function until the display is established.
     * 
     * Parameters:
     *  button_definition_hash - ""
     *
     * Returns
     *  n/a
     */
    this.add_button = function(button_definition_hash){
	// Add to our locally stored buttons.
	anchor.user_buttons.push(button_definition_hash);

	if( anchor.established_p && anchor.ui ){
	    anchor.ui.set_buttons(anchor.user_buttons);
	    anchor.ui.draw_user_buttons(anchor);	    
	}
    };

     /*
     * Function: clear_buttons
     * 
     * Remove all user-defined buttons from the display.
     * 
     * NOTE: Does not function until the display is established.
     * 
     * Parameters:
     *  n/a
     *
     * Returns
     *  n/a
     */
    this.clear_buttons = function(){
	// Clear our locally stored buttons.
	anchor.user_buttons = [];

	if( anchor.established_p && anchor.ui ){
	    anchor.ui.set_buttons(anchor.user_buttons);
	    anchor.ui.draw_user_buttons(anchor);	    
	}
    };

    /*
     * Function: set_query_field_text
     * 
     * Push text into the search box. Does not affect the state of the
     * manager in any way.
     * 
     * NOTE: Does not function until the display is established.
     * 
     * Parameters:
     *  query - the text to put into the search box
     *
     * Returns
     *  true or false on whether the task was accomplished
     */
    this.set_query_field_text = function(query){
	var retval = false;	
	if( anchor.established_p && anchor.ui ){
	    retval = anchor.ui.set_query_field(query);
	}
	return retval;
    };

    /*
     * Function: set_initial_reset_callback
     * 
     * Add a callback to be run after the initial reset is finished.
     * 
     * Parameters:
     *  response - the usual
     *  manager - the usual
     *
     * Returns
     *  n/a
     */
    this.set_initial_reset_callback = function(callback){
	anchor.initial_reset_callback = callback;
    };

    // // Now let's run the above function as the initializer.
    // anchor.establish_display();
};
bbop.core.extend(bbop.widget.search_pane, bbop.golr.manager.jquery);
/*
 * Package: live_filters.js
 * 
 * Namespace: bbop.widget.live_filters
 * 
 * BBOP JS object to allow the live probing of a GOlr personality.
 * 
 * Very much like a separated accordion and filter from the search
 * pane.
 * 
 * This is a Bootstrap 3 widget.
 * 
 * See Also:
 *  <search_pane.js>
 *  <live_search.js>
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.widget == "undefined" ){ bbop.widget = {}; }

/*
 * Constructor: live_filters
 * 
 * Contructor for the bbop.widget.live_filters object.
 * 
 * Widget interface to interactively explore a search personality with
 * no direct side effects.
 *
 * Arguments:
 *  interface_id - string id of the element to build on
 *  manager - the shared GOlr manager to use
 *  golr_conf_obj - the profile of the specific 
 *  in_argument_hash - *[optional]* optional hash of optional arguments
 * 
 * Returns:
 *  this object
 */
bbop.widget.live_filters = function(interface_id, manager, golr_conf_obj,
				    in_argument_hash){
    this._is_a = 'bbop.widget.live_filters';

    var anchor = this;
    var each = bbop.core.each;
    
    // TODO/BUG: Remove the need for these.
    var ui_icon_positive_label = '&plus;';
    var ui_icon_positive_source = null;
    var ui_icon_negative_label = '&minus;';
    var ui_icon_negative_source = null;
    var ui_icon_remove_label = '&minus;';
    var ui_icon_remove_source = null;
    var ui_spinner_shield_source = null;
    var ui_spinner_shield_message = '';

    // Per-UI logger.
    var logger = new bbop.logger();
    logger.DEBUG = false;
    //logger.DEBUG = true;
    function ll(str){ logger.kvetch('LF: ' + str); }

    ///
    /// Deal with incoming arguments.
    ///

    // this._class_conf = golr_conf_obj;

    // Our argument default hash.
    var default_hash = {
	'meta_label': 'Documents:&nbsp;',
	'display_meta_p': true,
	'display_free_text_p': true,
	'free_text_placeholder': 'Free-text filter',
	'display_accordion_p': true,
	'minimum_free_text_length': 3, // wait for three characters or more
	'on_update_callback': function(){}
    };
    var folding_hash = in_argument_hash || {};
    var arg_hash = bbop.core.fold(default_hash, folding_hash);
    // 
    this._interface_id = interface_id;
    this._display_meta_p = arg_hash['display_meta_p'];
    this._meta_label = arg_hash['meta_label'];
    this._display_free_text_p = arg_hash['display_free_text_p'];
    this._free_text_placeholder = arg_hash['free_text_placeholder'];
    this._display_accordion_p = arg_hash['display_accordion_p'];
    this._minimum_free_text_length = arg_hash['minimum_free_text_length'];
    this._on_update_callback = arg_hash['on_update_callback'];

    ///
    /// Prepare the interface and setup the div hooks.
    ///

    anchor._established_p = false;

    // Mangle everything around this unique id so we don't collide
    // with other instances on the same page.
    var ui_div_id = this._interface_id;
    var mangle = ui_div_id + '_ui_element_' + bbop.core.uuid() + '_';

    // Main div id hooks to the easily changable areas of the display.
    var container_div_id = mangle + 'container-id';
    // Meta hooks.
    var meta_div_id = mangle + 'meta-id';
    var meta_count_id = mangle + 'meta-count-id';
    var meta_wait_id = mangle + 'meta-wait-id';
    // Query hooks
    var query_input_div_id = mangle + 'query-id';
    // Sticky hooks.
    var sticky_filters_div_id = mangle + 'sticky_filters-id';
    var sticky_title_id = mangle + 'sticky_filters-title-id';
    var sticky_content_id = mangle + 'sticky_filters-content-id';
    // Current hooks.
    var current_filters_div_id = mangle + 'current_filters-id';
    var current_title_id = mangle + 'current_filters-title-id';
    var current_content_id = mangle + 'current_filters-content-id';
    var clear_user_filter_span_id = mangle + 'clear-user-filter-id';
    // Accordion hooks.
    var filters_div_id = mangle + 'ui-filters-wrapper';
    var clear_query_span_id = mangle + 'clear-query-id';
    // var ui_user_button_div_id = mangle + 'user-button-id';
    // var ui_results_table_div_id = mangle + 'results-table-id';
    // var ui_count_control_div_id = mangle + 'count_control-id';

    // Blow away whatever was there completely.
    // Render a control section into HTML. This includes the accordion
    // and current filter sections.
    // Get the user interface hook and remove anything that was there.
    var container_div = new bbop.html.tag('div', {'id': container_div_id});
    jQuery('#' + ui_div_id).empty();
    jQuery('#' + ui_div_id).append(container_div.to_string());

    // // Globally declared (or not) icons.
    // var ui_spinner_search_source = '';
    // var ui_spinner_shield_source = '';
    // var ui_spinner_shield_message = null;
    // var ui_icon_positive_label = '';
    // var ui_icon_positive_source = '';
    // var ui_icon_negative_label = '';
    // var ui_icon_negative_source = '';
    // var ui_icon_remove_label = '';
    // var ui_icon_remove_source = '';

    // // The spinner, if it exists, needs to be accessible by everybody
    // // and safe to use.
    // var spinner = null;
    // function _spinner_gen(elt_id){
    // 	var spinner_args = {
    // 	    //timeout: 5,
    // 	    //timeout: 500,
    // 	    timeout: 10,
    // 	    //classes: 'bbop-widget-search_pane-spinner',
    // 	    visible_p: false
    // 	};
    // 	spinner = new bbop.widget.spinner(elt_id,
    // 					  ui_spinner_search_source,
    // 					  spinner_args);
    // }

    // // Additional id hooks for easy callbacks. While these are not as
    // // easily changable as the above, we use them often enough and
    // // across functions to have a hook.
    // var accordion_div_id = mangle + 'filter-accordion-id';
    
    // // These pointers are used in multiple functions (e.g. both
    // // *_setup and *_draw).
    var filter_accordion_widget = null;
    var spinner_div = null;
    // //var current_filters_div = null;

    function _spin_up(){
    	if( spinner_div ){
	    jQuery('#' + spinner_div.get_id()).removeClass('hidden');
	    jQuery('#' + spinner_div.get_id()).addClass('active');
    	}
    }
    function _spin_down(){
    	if( spinner_div ){
	    jQuery('#' + spinner_div.get_id()).addClass('hidden');
	    jQuery('#' + spinner_div.get_id()).removeClass('active');
    	}
    }

    /*
     * Function: spin_up
     * 
     * Turn on the spinner.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns
     *  n/a
     */
    this.spin_up = function(){
	_spin_up();
    };
	
    /*
     * Function: spin_down
     * 
     * Turn off the spinner.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns
     *  n/a
     */
    this.spin_down = function(){
	_spin_down();
    };
	
    /*
     * Function: establish_display
     * 
     * Completely redraw the display.
     * 
     * Required to display after setting up the manager.
     * 
     * Also may be useful after a major change to the manager to reset
     * it.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns
     *  n/a
     */
    this.establish_display = function(){
	
    	// Can only make a display if there is a set
    	// personality--there is no general default and it is an
    	// error.
    	var personality = manager.get_personality();
    	var cclass = golr_conf_obj.get_class(personality);
    	if( ! personality || ! cclass ){
    	    ll('ERROR: no usable personality set');
    	    throw new Error('ERROR: no useable personality set');
    	}

    	///
    	/// Setup the UI base.
    	///
	
	// Holder for things like spinner and current number of
	// results.
	this.setup_meta = function(){
	    ll('setup_meta for: ' + meta_div_id);
	    
	    // Count area.
	    var ms_attrs = {
		id: meta_count_id,
		//'class': 'label label-default pull-right'
		//'class': 'label label-default'
		'class': 'badge'
	    };
	    var ms = new bbop.html.tag('span', ms_attrs, 'n/a');

	    // Get a progress bar assembled.
	    var inspan = new bbop.html.tag('span', {'class': 'sr-only'}, '...');
	    var indiv = new bbop.html.tag('div', {'class': 'progress-bar',
						  'role': 'progressbar',
						  'aria-valuenow': '100',
						  'aria-valuemin': '0',
						  'aria-valuemax': '100',
						  'style': 'width: 100%;'},
					  inspan);
	    spinner_div =
		new bbop.html.tag('div',
				  {'generate_id': true,
				   'class':
				   'progress progress-striped active pull-right',
				   'style': 'width: 3em;'},
				  indiv);

	    // The container area; add in the label and count.
	    var mdiv_args = {
		'class': 'well well-sm',
		'id': meta_div_id
	    };
	    var mdiv = new bbop.html.tag('div', mdiv_args,
					 [this._meta_label, ms, spinner_div]);
	    
	    jQuery('#' + container_div.get_id()).append(mdiv.to_string());
	};
	if( this._display_meta_p ){
	    this.setup_meta();
	}

	// Setup the free text query display under contructed tags for
	// later population.
	// 
	// If no icon_clear_source is defined, icon_clear_label will be
	// used as the defining text.
	this.setup_query = function(){
	    ll('setup_query for: ' + query_input_div_id);
	    
	    // // Some defaults.
	    // if( ! label_str ){ label_str = ''; }
	    // // if( ! icon_clear_label ){ icon_clear_label = ''; }
	    // // if( ! icon_clear_source ){ icon_clear_source = ''; }
	    
	    // The incoming label.
	    var query_label_attrs = {
		//'class': 'bbop-js-search-pane-query-label'
	    };
	    var query_label_div = new bbop.html.tag('div', query_label_attrs);
	    
	    // The text area.
	    var ta_args = {
		//'class': 'bbop-js-search-pane-textarea',
		'placeholder': this._free_text_placeholder,
		'class': 'form-control bbop-js-live-filters-textarea',
		//'style': 'height: 1em;',
		'rows': '1',
		'id': query_input_div_id
	    };
	    var query_area = new bbop.html.tag('textarea', ta_args);
	    
	    // Figure out an icon or a label.
	    var clear_query_obj =
		//bbop.widget.display.clickable_object(icon_clear_label);
		bbop.widget.display.clickable_object(null);
	    
	    // And a div to put it in.
	    var clear_div_attrs = {
		//'class': 'bbop-js-search-pane-clear-button',
		'generate_id': true
	    };
	    var clear_div =
		new bbop.html.tag('div', clear_div_attrs, clear_query_obj);	
	    
	    // General container div.
	    // NOTE/TODO: this is just a half panel--just wanted spacing.
	    var gen_div_attrs = {
		'class': 'panel panel-default',
		'generate_id': true
	    };
	    var gen_div = new bbop.html.tag('div', gen_div_attrs);
	    
	    // Add to display.
	    query_label_div.add_to(clear_div.to_string());
	    gen_div.add_to(query_label_div.to_string());
	    gen_div.add_to(query_area.to_string());
	    
	    jQuery('#' + container_div.get_id()).append(gen_div.to_string());
	};
	if( this._display_free_text_p ){
	    this.setup_query();
	}

	// Setup sticky filters display under contructed tags for later
	// population. The seeding information is coming in through the
	// GOlr conf class.
	this.setup_sticky_filters = function(){    
    	    ll('setup_sticky_filters UI for class configuration: ' +
	       cclass.id());
	    
    	    // var stitle_attrs = {
    	    // 	'class': 'panel panel-heading',
    	    // 	'id': sticky_title_id
    	    // };
    	    // var stitle =
    	    // 	new bbop.html.tag('div', stitle_attrs,
	    // 			  'No applied sticky filters');

    	    var scont_attrs = {
    		'class': 'panel-body',
    		'id': sticky_content_id
    	    };
    	    var scont =
    		new bbop.html.tag('div', scont_attrs,
				  'No applied sticky filters');

    	    var sticky_filters_attrs = {
    		'class': 'panel panel-default',
    		'id': sticky_filters_div_id
    	    };
    	    var sticky_filters_div =
    		//new bbop.html.tag('div', sticky_filters_attrs, [stitle, scont]);
    		new bbop.html.tag('div', sticky_filters_attrs, scont);
	    
    	    // Add the output to the page.
    	    var sticky_filters_str = sticky_filters_div.to_string();
	    jQuery('#' + container_div.get_id()).append(sticky_filters_str);
	};	
	// Setup current filters display under contructed tags for later
	// population. The seeding information is coming in through the
	// GOlr conf class.
	// 
	// Add in the filter state up here.
	// 
	// If no icon_reset_source is defined, icon_reset_label will be
	// used as the defining text.
	this.setup_current_filters = function(){
    	    ll('setup_current_filters UI for class configuration: ' +
	       cclass.id());
	    
    	    var ccont_attrs = {
    		'class': 'panel-body',
    		'id': current_content_id
    	    };
    	    var ccont =
    		new bbop.html.tag('div', ccont_attrs,
				  'No applied user filters');

    	    var current_filters_attrs = {
    		'class': 'panel panel-default',
    		'id': current_filters_div_id
    	    };
    	    var current_filters_div =
    		//new bbop.html.tag('div', current_filters_attrs, [stitle, scont]);
    		new bbop.html.tag('div', current_filters_attrs, ccont);
	    
    	    // Add the output to the page.
    	    var current_filters_str = current_filters_div.to_string();
	    jQuery('#' + container_div.get_id()).append(current_filters_str);
	};
	// Setup the accordion skeleton under contructed tags for later
	// population. The seeding information is coming in through the
	// GOlr conf class.
	// Start building the accordion here. Not an updatable part.
	// 
	// If no icon_*_source is defined, icon_*_label will be
	// used as the defining text.
	this.setup_accordion = function(){
    	    ll('setup_accordion UI for class configuration: ' +
    	       cclass.id());
	    
    	    var filter_accordion_attrs = {
    		id: filters_div_id
    	    };
    	    filter_accordion_widget = // heavy lifting by special widget
    	    new bbop.html.collapsible([], filter_accordion_attrs);
	    
    	    // Add the sections with no contents as a skeleton to be
    	    // filled by draw_accordion.
    	    var field_list = cclass.field_order_by_weight('filter');
    	    each(field_list,
    		 function(in_field){
    		     ll('saw field: ' + in_field);
    		     var ifield = cclass.get_field(in_field);
    		     var in_attrs = {
    			 id: in_field,
    			 label: ifield.display_name(),
    			 description: ifield.description()
    		     };
    		     filter_accordion_widget.add_to(in_attrs, '', true);
    		 });
	
    	    // Add the output from the accordion to the page.
    	    var accordion_str = filter_accordion_widget.to_string();
    	    jQuery('#' + container_div_id).append(accordion_str);
	};
	if( this._display_accordion_p ){
	    this.setup_current_filters();
	    this.setup_sticky_filters();
	    this.setup_accordion();
	}

    	///
    	/// Define the drawing callbacks, as well as the action hooks.
    	///
	
	/*
	 * Function: draw_meta
	 *
	 * Draw meta results. Includes selector for drop down.
	 * 
	 * (Re)draw the count control with the current information in the
	 * manager. This also tries to set the selector to the response
	 * number (to keep things in sync), unbinds any current "change"
	 * event, and adds a new change event.
	 * 
	 * Parameters:
	 *  response - the <bbop.golr.response> returned from the server
	 *  manager - <bbop.golr.manager> that we initially registered with
	 *
	 * Returns:
	 *  n/a
	 */
	this.draw_meta = function(response, manager){
	    
    	    ll('draw_meta for: ' + meta_div_id);

    	    // Collect numbers for display.
    	    var total_c = response.total_documents();

    	    // Draw meta; the current numbers and page--the same for
    	    // every type of return.
	    // var ms_attrs = {
	    // 	//'class': 'label label-default pull-right'
	    // 	'class': 'label label-default'
	    // };
	    // var ms = new bbop.html.tag('div', ms_attrs, total_c);
    	    jQuery('#' + meta_count_id).empty();
    	    jQuery('#' + meta_count_id).append(total_c);
    	    // if( total_c == 0 ){
    	    // 	jQuery('#' + meta_div_id).append('No results found.');
    	    // }else{
	    // }
    	    // jQuery('#' + meta_div_id).append(ms.to_string());
	};
	if( this._display_meta_p ){
    	    manager.register('search', 'meta_first', this.draw_meta, -1);
	}

	// Detect whether or not a keyboard event is ignorable.
	function _ignorable_event(event){

    	    var retval = false;

    	    if( event ){
    		var kc = event.keyCode;
    		if( kc ){
    		    if( kc == 39 || // right
			kc == 37 || // left
			kc == 32 || // space
			kc == 20 || // ctl?
			kc == 17 || // ctl?
			kc == 16 || // shift
			//kc ==  8 || // delete
			kc ==  0 ){ // super
    			    ll('ignorable key event: ' + kc);
    			    retval = true;
    			}
		}
    	    }
    	    return retval;
	}

	/*
	 * Function: draw_query
	 *
	 * Draw the query widget. This function makes it active
	 * as well.
	 * 
	 * Clicking the reset button will reset the query to ''.
	 * 
	 * NOTE: Since this is part of the "persistant" interface (i.e. it
	 * does not get wiped after every call), we make sure to clear the
	 * event listeners when we redraw the function to prevent them from
	 * building up.
	 * 
	 * Parameters:
	 *  response - the <bbop.golr.response> returned from the server
	 *  manager - <bbop.golr.manager> that we initially registered with
	 *
	 * Returns:
	 *  n/a
	 */
	this.draw_query = function(response, manager){
    	    ll('draw_query for: ' + query_input_div_id);

    	    // Add a smartish listener.
    	    jQuery('#' + query_input_div_id).unbind('keyup');
    	    jQuery('#' + query_input_div_id).keyup(
    		function(event){

    		    // If we're left with a legitimate event, handle it.
    		    if( ! _ignorable_event(event) ){

    			// Can't ignore it anymore, so it goes into the
    			// manager for testing.
    			var tmp_q = manager.get_query();
    			var input_text = jQuery(this).val();
    			manager.set_query(input_text);

    			// If the manager feels like it's right, trigger.
    			if( manager.sensible_query_p() ){
    			    ll('keeping set query: ' + input_text);
    			    // Set the query to be more "usable" just
    			    // before triggering (so the tests can't be
    			    // confused by our switch).
    			    manager.set_comfy_query(input_text);
    			    manager.search();

    			    // We are now searching--show it.
    			    _spin_up();
    			}else{
    			    ll('rolling back query: ' + tmp_q);		    
    			    manager.set_query(tmp_q);
    			}
    		    }
    		});

    	    // Now reset the clear button and immediately set the event.
    	    jQuery('#' + clear_query_span_id).unbind('click');
    	    jQuery('#' + clear_query_span_id).click(
    		function(){
    		    manager.reset_query();
    		    //anchor.set_query_field(manager.get_query());
    		    manager.set_query_field('');
    		    manager.search();
    		    // We are now searching--show it.
    		    _spin_up();
    		});
	};
	if( this._display_free_text_p ){
    	    manager.register('search', 'query_first', this.draw_query, 0);
	}
	
	/*
	 * Function: draw_accordion
	 *
	 * (Re)draw the information in the accordion controls/filters.
	 * This function makes them active as well.
	 * 
	 * Parameters:
	 *  response - the <bbop.golr.response> returned from the server
	 *  manager - <bbop.golr.manager> that we initially registered with
	 *
	 * Returns:
	 *  n/a
	 */
	this.draw_accordion = function(response, manager){	    
    	    ll('draw_accordion for: ' + filters_div_id);

	    //
    	    // Make sure that accordion has already been inited.
    	    if( typeof(filter_accordion_widget) == 'undefined' ){
    		throw new Error('Need to init accordion widget to use it.');
    	    }

    	    // We'll need this in a little bit for calculating when to
    	    // display the "more" option for the field filters.
    	    var real_facet_limit = manager.get_facet_limit();
    	    var curr_facet_limit = real_facet_limit -1; // the facets we'll show

    	    // We want this so we can filter out any facets that have the
    	    // same count as the current response total--these facets are
    	    // pretty much information free.
    	    var total_docs = response.total_documents();

    	    // A helper function for when no filters are
    	    // displayed.
    	    function _nothing_to_see_here(in_field){
    		var section_id =
		    filter_accordion_widget.get_section_id(in_field);
    		jQuery('#' + section_id).empty();
    		jQuery('#' + section_id).append('Nothing to filter.');
    	    }

    	    // Hash where we collect our button information.
    	    // button_id -> [source, filter, count, polarity];
    	    var button_hash = {};

    	    // And a hash to store information to be able to generate the
    	    // complete filter shields.
    	    // span_id -> filter_id
    	    var overflow_hash = {};

    	    // Cycle through each facet field; all the items in each,
    	    // create the lists and buttons (while collectong data useful
    	    // in creating the callbacks) and put them into the accordion.
    	    each(response.facet_field_list(),
    		 function(in_field){

    		     var facet_bd = response.facet_field(in_field);
    		     if( bbop.core.is_empty(facet_bd) ){
			 
    			 // No filters means nothing in the box.
    			 _nothing_to_see_here(in_field);

    		     }else{
			 
    			 // Create ul lists of the facet contents.
    			 var tbl_id = mangle + 'filter-list-' + in_field;
    			 var facet_list_tbl_attrs = {
			     'class': 'table table-hover table-striped table-condensed',
    			     'id': tbl_id
    			 };

    			 var facet_list_tbl =
    			     new bbop.html.table([], [], facet_list_tbl_attrs);
			 
    			 ll("consider:" + in_field + ": " +
    			    response.facet_field(in_field).length);

    			 // BUG/TODO:
    			 // Count the number of redundant (not shown)
    			 // facets so we can at least give a face to this
    			 // bug/problem.
    			 // Also filter out "empty filters".
    			 var redundant_count = 0;
    			 // Now go through and get filters and counts.
    			 var good_count = 0; // only count when good
    			 var overflow_p = false; // true when at 24 -> 25
    			 each(response.facet_field(in_field),
    			      function(ff_field, ff_index){

    				  // Pull out info early so we can test it
    				  // for information content.
    				  var f_name = ff_field[0];
    				  var f_count = ff_field[1];
				  
    				  // ll(in_field + ": " + f_name + ": " +
    				  // 	 [f_count,
    				  // 	  total_docs,
    				  // 	  ff_index,
    				  // 	  good_count,
    				  // 	  redundant_count,
    				  // 	  real_facet_limit].join(', '));
			      	  
    				  // TODO: The field is likely redundant
    				  // (BUG: not always true in closures),
    				  // so eliminate it.
    				  if( f_count == total_docs ){
    				      //ll("\tnothing here");
    				      redundant_count++;
    				  }else if( ! f_name || f_name == "" ){
    				      // Straight out skip if it is an
    				      // "empty" facet field.
    				  }else if( ff_index < real_facet_limit -1 ){
    				      //ll("\tgood row");
    				      good_count++;

    				      // Create buttons and store them for later
    				      // activation with callbacks to
    				      // the manager.
    				      var b_plus =
    					  new bbop.html.button(
    					      ui_icon_positive_label,
					      {
						  'generate_id': true,
						  'type': 'button',
						  'class':
						  'btn btn-success btn-xs'
					      });
    				      var b_minus =
    					  new bbop.html.button(
    					      ui_icon_negative_label,
					      {
						  'generate_id': true,
						  'type': 'button',
						  'class':
						  'btn btn-danger btn-xs'
					      });
				      
    				      // Store in hash for later keying to
    				      // event.
    				      button_hash[b_plus.get_id()] =
    					  [in_field, f_name, f_count, '+'];
    				      button_hash[b_minus.get_id()] =
    					  [in_field, f_name, f_count, '-'];
				      
    				      // // Add the label and buttons to the
    				      // // appropriate ul list.
    				      //facet_list_ul.add_to(
    				      // fstr,b_plus.to_string(),
    				      //   b_minus.to_string());
    				      // Add the label and buttons to the table.
    				      facet_list_tbl.add_to([f_name,
    							     '('+ f_count+ ')',
    							     b_plus.to_string(),
    							     b_minus.to_string()
    							    ]);
    				  }
				  
    				  // This must be logically separated from
    				  // the above since we still want to show
    				  // more even if all of the top 25 are
    				  // redundant.
    				  if( ff_index == real_facet_limit -1 ){
    				      // Add the more button if we get up to
    				      // this many facet rows. This should
    				      // only happen on the last possible
    				      // iteration.
				      
    				      overflow_p = true;
    				      //ll( "\tadd [more]");
				      
    				      // Since this is the overflow item,
    				      // add a span that can be clicked on
    				      // to get the full filter list.
    				      //ll("Overflow for " + in_field);
    				      var b_over = new bbop.html.button(
    					  'more...',
					  {
					      'generate_id': true,
					      'type': 'button',
					      'title':
					      'Display the complete list',
					      'class':
					      'btn btn-primary btn-xs'
					  });
    				      facet_list_tbl.add_to([b_over.to_string(),
    				  			     '', '']);
    				      overflow_hash[b_over.get_id()] = in_field;
    				  }
    			      });

    			 // There is a case when we have filtered out all
    			 // avilable filters (think db source).
    			 if( good_count == 0 && ! overflow_p ){
    			     _nothing_to_see_here(in_field);
    			 }else{
    			     // Otherwise, now add the ul to the
    			     // appropriate section of the accordion in
    			     // the DOM.
    			     var sect_id =
    				 filter_accordion_widget.get_section_id(in_field);
    			     jQuery('#' + sect_id).empty();

    			     // TODO/BUG:
    			     // Give warning to the redundant facets.
    			     var warn_txt = null;
    			     if( redundant_count == 1 ){
    				 warn_txt = "field is";
    			     }else if( redundant_count > 1 ){
    				 warn_txt = "fields are";
    			     }
    			     if( warn_txt ){
    				 jQuery('#' + sect_id).append(
    				     "<small> The top (" + redundant_count +
    					 ") redundant " + warn_txt + " not shown" +
    					 "</small>");
				 
    			     }

    			     // Add facet table.
    			     var final_tbl_str = facet_list_tbl.to_string();
    			     jQuery('#' + sect_id).append(final_tbl_str);
    			 }
    		     }
    		 });

    	    // Okay, now introducing a function that we'll be using a
    	    // couple of times in our callbacks. Given a button id (from
    	    // a button hash) and the [field, filter, count, polarity]
    	    // values from the props, make a button-y thing an active
    	    // filter.
    	    function filter_select_live(button_id, create_time_button_props){
    		//var bid = button_id;
    		//var in_field = create_time_button_props[0];	 
    		//var in_filter = create_time_button_props[1];
    		//var in_count = create_time_button_props[2];
    		var in_polarity = create_time_button_props[3];

    		// Decide on the button graphical elements.
    		var b_ui_icon = 'ui-icon-plus';
    		if( in_polarity == '-' ){
    		    b_ui_icon = 'ui-icon-minus';
    		}
    		var b_ui_props = {
    		    icons: { primary: b_ui_icon},
    		    text: false
    		};

    		// Create the button and immediately add the event.
    		//jQuery('#' + button_id).button(b_ui_props).click(
    		jQuery('#' + button_id).click(
    		    function(){
    			var tid = jQuery(this).attr('id');
    			var call_time_button_props = button_hash[tid];
    			var call_field = call_time_button_props[0];	 
    			var call_filter = call_time_button_props[1];
    			//var in_count = button_props[2];
    			var call_polarity = call_time_button_props[3];
			
    			// Change manager and fire.
    			// var bstr =call_field+' '+call_filter+' '+call_polarity;
    			// alert(bstr);
    			manager.add_query_filter(call_field, call_filter,
    			  			 [call_polarity]);
    			manager.search();
    			// We are now searching--show it.
    			_spin_up();
    		    });
    	    }

    	    // Now let's go back and add the buttons, styles,
    	    // events, etc. in the main accordion section.
    	    each(button_hash, filter_select_live);

    	    // Next, tie the events to the "more" spans.
    	    each(overflow_hash,
    		 function(button_id, filter_name){
    		     jQuery('#' + button_id).click(

    			 // On click, set that one field to limitless in
    			 // the manager, setup a shield, and wait for the
    			 // callback.
    			 function(){

    			     // Recover the field name.
    			     var tid = jQuery(this).attr('id');
    			     var call_time_field_name = overflow_hash[tid];
    			     //alert(call_time_field_name);

    			     // Set the manager to no limit on that field and
    			     // only rturn the information that we want.
    			     manager.set_facet_limit(0);
    			     manager.set_facet_limit(call_time_field_name, -1);
    			     var curr_row = manager.get('rows');
    			     manager.set('rows', 0);

    			     // Create the shield and pop-up the
    			     // placeholder.
    			     var fs = bbop.widget.display.filter_shield;
    			     var filter_shield = new fs(ui_spinner_shield_source,
    							ui_spinner_shield_message); 
    			     filter_shield.start_wait();

    			     // Open the populated shield.
    			     function draw_shield(resp){

    				 // ll("shield what: " + bbop.core.what_is(resp));
    				 // ll("shield resp: " + bbop.core.dump(resp));

    				 // First, extract the fields from the
    				 // minimal response.
    				 var fina = call_time_field_name;
    				 var flist = resp.facet_field(call_time_field_name);

    				 // Draw the proper contents of the shield.
    				 filter_shield.draw(fina, flist, manager);
    			     }
    			     manager.fetch(draw_shield);

    			     // Reset the manager to more sane settings.
    			     manager.reset_facet_limit();
    			     manager.set('rows', curr_row);
    			 });
    		 });

    	    ll('Done current accordion for: ' + filters_div_id);
	};

	/*
	 * Function: draw_current_filters
	 *
	 * (Re)draw the information on the current filter set.
	 * This function makes them active as well.
	 * 
	 * Parameters:
	 *  response - the <bbop.golr.response> returned from the server
	 *  manager - <bbop.golr.manager> that we initially registered with
	 *
	 * Returns:
	 *  n/a
	 */
	this.draw_current_filters = function(response, manager){	
		ll('draw_current_filters for: ' + current_filters_div_id);

		///
		/// Add in the actual HTML for the filters and buttons. While
		/// doing so, tie a unique id to the filter--we'll use that
		/// later on to add buttons and events to them.
		///

		// First, we need to make the filter clear button for the top
		// of the table.
		var b_cf = new bbop.html.button('&times;',
						{
		     				    'type': 'button',
						    'id':
						    clear_user_filter_span_id,
						    'class':
						    'btn btn-danger btn-xs',
						    'title':
						    'Clear all user filters'
						});

		var in_query_filters = response.query_filters();
		//var sticky_query_filters = manager.get_sticky_query_filters();
		ll('filters: ' + bbop.core.dump(in_query_filters));
		var fq_list_tbl =
		    new bbop.html.table(['', 'User filters', b_cf.to_string()],
					[],
//				       	{'class': 'bbop-js-search-pane-filter-table'});
				       	{'class': 'table table-hover table-striped table-condensed'});
		var has_fq_p = false; // assume there are no filters to begin with
		var button_hash = {};
		each(in_query_filters,
		     function(field, field_vals){
			 each(field_vals,
			      function(field_val, polarity){

				  // Make note of stickiness, skip adding if sticky.
				  var qfp =
				      manager.get_query_filter_properties(field,
									  field_val);
				  if( ! qfp || qfp['sticky_p'] == false ){
	
				      // Note the fact that we actually have a
				      // query filter to work with and display.
				      has_fq_p = true;

				      // Boolean value to a character.
				      var polstr = '&minus;';
				      if( polarity ){ polstr = '&plus;'; }


				      // Argh! Real jQuery buttons are way too slow!
				      // var b = new bbop.html.button('remove filter',
				      // 		  {'generate_id': true});

				      // Generate a button with a unique id.
				      var b = new bbop.html.button(
					  ui_icon_remove_label,
					  {
					      'generate_id': true,
					      'type': 'button',
					      'title': 'Remove filter',
					      'class':
					      'btn btn-danger btn-xs'
					  });

				      // Tie the button it to the filter for
				      // jQuery and events attachment later on.
				      var bid = b.get_id();
				      button_hash[bid] = [polstr, field, field_val];
	
				      //ll(label_str +' '+ bid);
				      //fq_list_tbl.add_to(label_str +' '+ b.to_string());
				      fq_list_tbl.add_to(['<strong>'+ polstr +'</strong>',
							  field + ': ' + field_val,
							  b.to_string()]);
				      //label_str +' '+ b.to_string());
				  }
			      });
		     });

		// Either add to the display, or display the "empty" message.
		var cfid = '#' + current_content_id;
		jQuery(cfid).empty();
		if( ! has_fq_p ){
		    jQuery(cfid).append("No current user filters.");
		}else{

		    // With this, the buttons will be attached to the
		    // DOM...
		    jQuery(cfid).append(fq_list_tbl.to_string());
	
		    // First, lets add the reset for all of the filters.
		    jQuery('#' + b_cf.get_id()).click(
			function(){
	   		    manager.reset_query_filters();
	   		    manager.search();
			    // We are now searching--show it.
			    _spin_up();
			}		
		    );

		    // Now let's go back and add the buttons, styles,
		    // events, etc. to the filters.
		    each(button_hash,
			 function(button_id){
			     var bid = button_id;

			     // // Get the button.
			     // var bprops = {
			     // 	 icons: { primary: "ui-icon-close"},
			     // 	 text: false
			     // };
			     // Create the button and immediately add the event.
			     //jQuery('#' + bid).button(bprops).click(
			     jQuery('#' + bid).click(
				 function(){
				     var tid = jQuery(this).attr('id');
				     var button_props = button_hash[tid];
				     var polstr = button_props[0];
				     var field = button_props[1];
				     var value = button_props[2];

				     // Change manager and fire.
				     // var lstr = polstr +' '+ field +' '+ value;
				     // alert(lstr);
				     // manager.remove_query_filter(field,value,
				     // 				 [polstr, '*']);
				     manager.remove_query_filter(field, value);
				     manager.search();
				     // We are now searching--show it.
				     _spin_up();
				 });
			 });
		}
	};

	/*
	 * Function: draw_sticky_filters
	 *
	 * (Re)draw the information on the sticky filter set.
	 * 
	 * Parameters:
	 *  response - the <bbop.golr.response> returned from the server
	 *  manager - <bbop.golr.manager> that we initially registered with
	 *
	 * Returns:
	 *  n/a
	 */
	this.draw_sticky_filters = function(response, manager){	    
    	    ll('draw_sticky_filters for: ' + sticky_filters_div_id);

    	    // Add in the actual HTML for the pinned filters and buttons.
    	    var sticky_query_filters = manager.get_sticky_query_filters();
    	    ll('sticky filters: ' + bbop.core.dump(sticky_query_filters));
    	    var fq_list_tbl =
    		new bbop.html.table(['', 'Your search is pinned to these filters'],
    				    [],
    			       	    {'class': 'table table-hover table-striped table-condensed'});
    	    // [{'filter': A, 'value': B, 'negative_p': C, 'sticky_p': D}, ...]
    	    each(sticky_query_filters,
    		 function(fset){

    		     //
    		     var sfield = fset['filter'];
    		     var sfield_val = fset['value'];

    		     // Boolean value to a character.
    		     var polarity = fset['negative_p'];
    		     var polstr = '&minus;';
    		     if( polarity ){ polstr = '&plus;'; }

    		     // Generate a button with a unique id.
    		     var label_str = polstr + ' ' + sfield + ':' + sfield_val;
    		     fq_list_tbl.add_to(['<b>'+ polstr +'</b>',
    					 sfield + ': ' + sfield_val]);
    		 });
	    
    	    // Either add to the display, or display the "empty" message.
    	    //var sfid = '#' + sticky_filters_div_id;
    	    var sfid = '#' + sticky_content_id;
    	    jQuery(sfid).empty();
    	    if( sticky_query_filters.length == 0 ){
    		jQuery(sfid).append("No sticky filters.");
    	    }else{
    		// Attach to the DOM...
    		jQuery(sfid).append(fq_list_tbl.to_string());
    	    }
	};

	if( this._display_accordion_p ){
    	    manager.register('search', 'accrdn_first', this.draw_accordion, 1);
    	    manager.register('search', 'current_first',
			     this.draw_current_filters, 2);
    	    manager.register('search', 'sticky_first',
			     this.draw_sticky_filters, 3);
	}

	/*
	 * Function: draw_error
	 *
	 * Somehow report an error to the user.
	 * 
	 * Parameters:
	 *  error_message - a string(?) describing the error
	 *  manager - <bbop.golr.manager> that we initially registered with
	 *
	 * Returns:
	 *  n/a
	 */
	this.draw_error = function(error_message, manager){
    	    ll("draw_error: " + error_message);
    	    alert("Runtime error: " + error_message);
    	    _spin_down();
	};
    	manager.register('error', 'error_first', this.draw_error, 0);

	// 
	function spin_down_wait(){
	    _spin_down();
	}
    	manager.register('search', 'donedonedone', spin_down_wait, -100);

    	// Start the ball with a reset event.
    	//manager.search();

	// The display has been established.
	anchor._established_p = true;
    };
};
/*
 * Package: live_pager.js
 * 
 * Namespace: bbop.widget.live_pager
 * 
 * BBOP JS object to allow the the paging/downloading etc. of a GOlr
 * manager.
 * 
 * Very much like a separated pager from the search pane.
 * 
 * This is a Bootstrap 3 widget.
 * 
 * See Also:
 *  <search_pane.js>
 *  <live_search.js>
 *  <live_filters.js>
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.widget == "undefined" ){ bbop.widget = {}; }

/*
 * Constructor: live_pager
 * 
 * Contructor for the bbop.widget.live_pager object.
 * 
 * Display a manager response. Not a manager itself, but can use the
 * argument manager to page, download, etc.
 *
 * Arguments:
 *  interface_id - string id of the element to build on
 *  manager - a manager object to probe for display and use for remoting
 *  in_argument_hash - *[optional]* optional hash of optional arguments
 * 
 * Returns:
 *  this object
 */
bbop.widget.live_pager = function(interface_id, manager, in_argument_hash){
    this._is_a = 'bbop.widget.live_pager';

    var anchor = this;
    var each = bbop.core.each;
    function ll(str){ console.log(str); };

    // Some top-level variable defined.
    var ui_count_control_div_id =
	    interface_id + '_countctl_div_' + bbop.core.uuid();
    var external_button_location_id = 'pager_button_holder_' + bbop.core.uuid();

    // Handle incoming arguements.
    var default_hash = {
	'callback_priority': 0
    };
    var folding_hash = in_argument_hash || {};
    var arg_hash = bbop.core.fold(default_hash, folding_hash);
    //
    var callback_priority = arg_hash['callback_priority'];

    // Last things last, bind to the manager.
    // TODO/BUG: Should this actually happen outside the widget? How
    // complicated is this really?
    var fun_id = bbop.core.uuid();
    manager.register('search', fun_id, _repaint_on_callback, callback_priority);

    // Add the "disabled" property to a button if the boolean
    // value says so.
    function _disable_if(bttn, disbool){
	if( disbool ){
	    jQuery('#' + bttn.get_id()).attr('disabled','disabled');
	}
    }

    // (Re)draw the count control with the current information in the
    // manager. This also tries to set the selector to the response
    // number (to keep things in sync), unbinds any current "change"
    // event, and adds a new change event.
    function _repaint_on_callback(response, manager){
	
	//ll('draw live_pager at: ' + interface_id);

	///
	/// Section 1: the numbers display.
	///

	// Collect numbers for display.
	var total_c = response.total_documents();
	var first_d = response.start_document();
	var last_d = response.end_document();

	// Draw meta; the current numbers and page--the same for
	// every type of return.
	jQuery('#' + interface_id).empty();
	if( total_c == 0 ){
	    jQuery('#' + interface_id).append('No results found.');
	}else{

	    // A top-level div to contain the literal meta results, and the count
	    // selector next to them.
	    var mdiv_attrs = {
		'class': 'row',
		'generate_id': true
	    };
	    var mdiv = new bbop.html.tag('div', mdiv_attrs);

	    // The literal return metadata.
	    var dmeta_attrs = {
		//'class': 'bbop-js-search-pane-meta'
		'generate_id': true,
		'class': 'col-xs-6 col-sm-6 col-md-4 col-lg-4'
	    };
	    var dmeta = new bbop.html.tag('div', dmeta_attrs);
	    dmeta.add_to('<div>Total: ' + total_c +
			 '; showing: ' + first_d +
			 '-' + last_d + '</div>');
	    mdiv.add_to(dmeta);

	    ///
	    /// Section 2: results count control.
	    ///

	    // Create a text label.
	    var sel_label_attrs = {
		//'for': ui_count_control_div_id,
		// 'generate_id': true,
		//'class': 'control-label'
	    };
	    var sel_label = new bbop.html.tag('span', sel_label_attrs,
					      'Results&nbsp;count&nbsp;&nbsp;');
	    
	    // Create inputs (the current order is important for proper
	    // for/id creation).
	    var cinputs = [];
	    each([10, 25, 50, 100],
		 function(num, cindex){
		     // Create and store the option.
		     var sel_input_attrs = {
			 'generate_id': true,
			 'value': num
		     };
		     var sel_input =
			     new bbop.html.tag('option', sel_input_attrs, num);
		     var sel_input_id = sel_input.get_id();
		     cinputs.push(sel_input);
		 });
	    // Option container div.
	    var sel_attrs = {
		'id': ui_count_control_div_id,
		//'class': 'form-control',
		'style': 'width: 5em;'
	    };
	    var sel = new bbop.html.tag('select', sel_attrs, cinputs);
	    
	    // Container div.
	    var sel_div_attrs = {
	    	'generate_id': true
		//'class': 'col-xs-6 col-sm-6 col-md-3 col-lg-3'
	    	//'class': 'form-group'
	    	//'style': 'width: 7em;'
	    };
	    var sel_div = new bbop.html.tag('div', sel_div_attrs);
	    
	    // Assemble these elements into the UI.
	    sel_div.add_to(sel_label);
	    sel_div.add_to(sel);
	    //mdiv.add_to(sel_div);
	    dmeta.add_to(sel_div);

	    // Render out the last two sections.
	    jQuery('#' + interface_id).append(mdiv.to_string());
	    
	    ///
	    /// Section 3: results count activity, setting.
	    ///

	    // First, unbind so we don't accidentally trigger with any
	    // changes and don't pile up event handlers.
	    jQuery('#' + ui_count_control_div_id).unbind('change');

	    // Next, pull out the number of rows requested.
	    var step = response.row_step();
	    
	    // Set the value to the number.
	    jQuery('#' + ui_count_control_div_id).val(step);
	    
	    // Finally, reactivate the event handler on the select.
	    jQuery('#' + ui_count_control_div_id).change(
		function(event, ui){
		    var sv = jQuery('#' + ui_count_control_div_id).val();
		    if( bbop.core.is_defined(sv) ){
			// Convert to a number.
			var si = parseInt(sv);
			
			// Set manager and to the search.
			manager.set_results_count(si);
			manager.search();
			// We are now searching--show it.
			//_spin_up();
		    }
		});

	    ///
	    /// Section 4: the paging buttons.
	    ///
	    
	    var bdiv_attrs = {
 		'class': 'col-xs-12 col-sm-12 col-md-8 col-lg-8',
	    	'generate_id': true
	    };
	    var bdiv = new bbop.html.tag('div', bdiv_attrs);
	    //jQuery('#' + interface_id).append(bdiv.to_string());
	    jQuery('#' + mdiv.get_id()).append(bdiv.to_string());
	    var bdiv_id = bdiv.get_id();

	    // Now add the raw buttons to the interface, and after this,
	    // activation and adding events.
	    var bopts = {
		'generate_id': true,
		'class': 'btn btn-primary'
	    };
	    var b_first = new bbop.html.button('&laquo;First', bopts);
	    //jQuery('#' + interface_id).append(b_first.to_string());
	    jQuery('#' + bdiv_id).append(b_first.to_string());
	    var b_back = new bbop.html.button('&lt;Prev', bopts);
	    //jQuery('#' + interface_id).append(b_back.to_string());
	    jQuery('#' + bdiv_id).append(b_back.to_string());
	    var b_forward = new bbop.html.button('Next&gt;', bopts);
	    //jQuery('#' + interface_id).append(b_forward.to_string());
	    jQuery('#' + bdiv_id).append(b_forward.to_string());
	    var b_last = new bbop.html.button('Last&raquo;', bopts);
	    //jQuery('#' + interface_id).append(b_last.to_string());
	    jQuery('#' + bdiv_id).append(b_last.to_string());

	    // Do the math about what buttons to activate.
	    var b_first_disabled_p = false;
	    var b_back_disabled_p = false;
	    var b_forward_disabled_p = false;
	    var b_last_disabled_p = false;
	    
	    // Only activate paging if it is necessary to the returns.
	    if( ! response.paging_p() ){
		b_first_disabled_p = true;
		b_back_disabled_p = true;
		b_forward_disabled_p = true;
		b_last_disabled_p = true;
	    }
	    
	    // Don't activate back on the first page.
	    if( ! response.paging_previous_p() ){
		b_first_disabled_p = true;
		b_back_disabled_p = true;
	    }
	    
	    // Don't activate next on the last page.
	    if( ! response.paging_next_p() ){
		b_forward_disabled_p = true;
		b_last_disabled_p = true;
	    }

	    // First page button.
	    _disable_if(b_first, b_first_disabled_p);
	    jQuery('#' + b_first.get_id()).click(function(){
		// Cheat and trust reset by proxy to work.
		manager.page_first(); 
		// We are now searching--show it.
		//_spin_up();
	    });
	    
	    // Previous page button.
	    _disable_if(b_back, b_back_disabled_p);
	    jQuery('#' + b_back.get_id()).click(function(){
		manager.page_previous();
		// We are now searching--show it.
		//_spin_up();
	    });
	    
	    // Next page button.
	    _disable_if(b_forward, b_forward_disabled_p);
	    jQuery('#' + b_forward.get_id()).click(function(){
		manager.page_next();
		// We are now searching--show it.
		//_spin_up();
	    });
	    
	    // Last page button.
	    _disable_if(b_last, b_last_disabled_p);
	    jQuery('#' + b_last.get_id()).click(function(){
		// A little trickier.
		manager.page_last(total_c);
		// We are now searching--show it.
		//_spin_up();
	    });

	    ///
	    /// Section 5: make a place for external buttons.
	    ///

	    var holder_attrs = {
		'id': external_button_location_id
	    };
	    var holder = new bbop.html.tag('span', holder_attrs);
	    jQuery('#' + bdiv_id).append('&nbsp;' + holder.to_string());
	}
    }

	
    /*
     * Function: button_span_id
     * 
     * Returns the location of a place to add external buttons if you
     * want.
     * 
     * Parameters:
     *  n/a
     * 
     * Returns
     *  string rep of place to put external buttons (span tag)
     */
    anchor.button_span_id = function(){
	return external_button_location_id;
    };
};
/*
 * Package: live_results.js
 * 
 * Namespace: bbop.widget.live_results
 * 
 * BBOP JS widget to display the results of a search on callback.
 * 
 * TODO: Button insertion in other non-internal places.
 * 
 * This is a Bootstrap 3 widget.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.widget == "undefined" ){ bbop.widget = {}; }

/*
 * Constructor: live_results
 * 
 * Contructor for the bbop.widget.live_results object.
 * 
 * Results table and optional buttons.
 *
 * Optional options looks like:
 *  callback_priority - default 0
 *  user_buttons - default [], should be any passable renderable button
 *  user_buttons_div_id - default null
 *  selectable_p - have selectable side buttons (default true)
 *
 * Arguments:
 *  interface_id - string id of the element to build on
 *  manager - the shared GOlr manager to use
 *  conf_class - the profile of the specific conf to use
 *  handler - handler to use in rendering
 *  linker - linker to use in rendering
 *  in_argument_hash - *[optional]* optional hash of optional arguments, described above
 * 
 * Returns:
 *  this object
 */
bbop.widget.live_results = function(interface_id, manager, conf_class,
				    handler, linker, in_argument_hash){
    this._is_a = 'bbop.widget.live_results';

    var anchor = this;
    var each = bbop.core.each;
    
    // Per-UI logger.
    var logger = new bbop.logger();
    logger.DEBUG = false;
    //logger.DEBUG = true;
    function ll(str){ logger.kvetch('LR: ' + str); }

    var results_table = null;

    // Some top-level variable defined.
    // Special id and names for optional select column.
    var local_mangle = bbop.core.uuid();
    var select_column_id = 'rtbcc_select_' + local_mangle;
    var select_item_name = 'rtbcc_select_name_' + local_mangle;

    ///
    /// Deal with incoming arguments.
    ///

    // Our argument default hash.
    var default_hash = {
	'callback_priority': 0,
	'user_buttons': [],
	'user_buttons_div_id': null,
	'selectable_p': true
    };
    var folding_hash = in_argument_hash || {};
    var arg_hash = bbop.core.fold(default_hash, folding_hash);
    // 
    var callback_priority = arg_hash['callback_priority'];
    var user_buttons = arg_hash['user_buttons'];
    var user_buttons_div_id = arg_hash['user_buttons_div_id'];
    var selectable_p = arg_hash['selectable_p'];

    //
    var fun_id = bbop.core.uuid();

    ///
    /// Set the callbacks.
    ///

    // Add the "disabled" property to a button if the boolean
    // value says so.
    function _disable_if(bttn, disbool){
	if( disbool ){
	    jQuery('#' + bttn.get_id()).attr('disabled','disabled');
	}
    }
    
    // (Re)draw the user-defined buttons in the meta
    // information area.  Will naturally fail if there is no
    // meta div that has been nested with the user button
    // element.
    function _draw_user_buttons(button_definitions, loc_id){
	function _button_rollout(button_def_hash){
	    var default_hash = {
		label : '?',
		disabled_p : false,
		click_function_generator :
		function(anchor, manager){
		    return function(anchor, manager){
			alert('No callback defined for this button--' +
			      'the generator may have been empty!');
		    };
		}
    	    };
	    var folding_hash = button_def_hash || {};
	    var arg_hash = bbop.core.fold(default_hash, folding_hash);
	    
	    var label = arg_hash['label'];
	    var disabled_p = arg_hash['disabled_p'];
	    var click_function_generator = arg_hash['click_function_generator'];
	    
	    /// Add button to DOM.
	    var b_props = {
		'generate_id': true,
		'class': 'btn btn-primary'
	    };
	    var b = new bbop.html.button(label, b_props);
	    jQuery('#' + loc_id).append(b.to_string());
	    _disable_if(b, disabled_p);
	    
	    // Bind function to action.
	    var click_fun = click_function_generator(anchor, manager);
	    jQuery('#' + b.get_id()).click(click_fun);
	}
	
	// Check that we're not about to do the impossible.
	if( ! jQuery('#' + loc_id) ){
	    alert('cannot refresh buttons without a place to draw them');
	}else{
	    jQuery('#' + loc_id).empty();
	    bbop.core.each(button_definitions, _button_rollout);
	}
    }

    // Draw a table at the right place or an error message.
    function _draw_table_or_something(resp, manager){

	// Wipe interface.
	jQuery('#' + interface_id).empty();

	// Vary by what we got.
	if( ! resp.success() || resp.total_documents() == 0 ){
	    jQuery('#' + interface_id).append('<em>No results given your input and search fields. Please refine and try again.</em>');
	}else{

	    // Render the buttons.
	    //console.log('user_buttons: ', user_buttons);
	    if( user_buttons && user_buttons.length && user_buttons.length > 0 ){

		// Ensure we have somewhere to put our buttons. If not
		// supplied with an injection id, make our own and use
		// it.
		var insert_div_id = user_buttons_div_id;
		if( ! user_buttons_div_id ){

		    // Generate new dic and add it to the display.
		    var ubt_attrs = {
			'generate_id': true
		    };
		    var ubt = new bbop.html.tag('div', ubt_attrs);
		    jQuery('#' + interface_id).append(ubt.to_string());
		    
		    // Ensure the id.
		    insert_div_id = ubt.get_id();
		}

		// Add all of the defined buttons after the spacing.
		_draw_user_buttons(user_buttons, insert_div_id);
	    }

	    // Display results.
	    var bwd = bbop.widget.display;
	    results_table =
		bwd.results_table_by_class_conf_b3(conf_class, resp, linker,
						   handler, interface_id,
						   selectable_p,
						   select_column_id,
						   select_item_name);
	}
    }
    manager.register('search', fun_id, _draw_table_or_something,
		     callback_priority);
    
    // Somehow report an error to the user.
    //  error_message - a string(?) describing the error
    //  manager - <bbop.golr.manager> that we initially registered with
    function _draw_error(error_message, manager){
    	ll("draw_error: " + error_message);
    	alert("Runtime error: " + error_message);
    	//_spin_down();
    };
    manager.register('error', fun_id, _draw_error, callback_priority);

    ///
    /// External API.
    ///

    /*
     * Function: item_name
     *
     * Return a string of the name attribute used by the checkboxes if
     * we selected for checkboxes to be displayed.
     * 
     * Parameters:
     *  n/a
     *
     * Returns:
     *  string or null if displaying checkboxes was false
     */
    this.item_name = function(){	
	return select_item_name;
    };

    /*
     * Function: toggle_id
     *
     * Return a string of the id of the checkbox in the header if we
     * selected for checkboxes to be displayed.
     * 
     * Parameters:
     *  n/a
     *
     * Returns:
     *  string or null if displaying checkboxes was false
     */
    this.toggle_id = function(){	
	return select_column_id;
    };
    
    /*
     * Function: get_selected_items
     * 
     * The idea is to return a list of the items selected (with
     * checkboxes) in the display. This means that there are three
     * possibilities. 1) We are not using checkboxes or the display
     * has not been established, so we return null; 2) no or all items
     * have been selected, so we get back an empty list (all == none
     * in our view); 3) a subset list of strings (ids).
     * 
     * NOTE: Naturally, does not function until the display is established.
     * 
     * Parameters:
     *  n/a
     *
     * Returns
     *  string list or null
     */
    this.get_selected_items = function(){
	var retval = null;

	// 
	if( selectable_p ){
	    retval = [];

	    // Cycle through and pull out the values of the checked
	    // ones.
	    var total_count = 0;
	    var nstr = 'input[name=' + select_item_name + ']';
	    jQuery(nstr).each(
		function(){
		    if( this.checked ){
			var val = jQuery(this).val();
			retval.push(val);
		    }
		    total_count++;
		});

	    // If we are selecting all of the items on this page, that
	    // is the same as not selecting any in our world, so reset
	    // and warn.
	    if( total_count > 0 && total_count == retval.length ){
		alert('You can "select" all of the items on a results page by not selecting any (all being the default). This will also get your results processed faster and cause significantly less overhead on the servers.');
		retval = [];
	    }	    
	}

	return retval;
    };

};
/*
 * Package: repl.js
 * 
 * Namespace: bbop.widget.repl
 * 
 * A self-contained flexible REPL to use as a base to explore the BBOP
 * environment that you setup.
 * 
 * This is a completely self-contained UI and manager.
 * 
 * WARNING: This widget cannot display any kind of HTML tags in the
 * log.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.widget == "undefined" ){ bbop.widget = {}; }

/*
 * Constructor: repl
 * 
 * Contructor for the bbop.widget.repl object.
 * 
 * The in_argument_hash has the following options.
 * 
 *  buffer_id - the id of the evaluation buffer textarea (default: null/random)
 *  cli_id - the id of the CLI textarea (default: null/random)
 *  display_initial_commands_p - (default true)
 * 
 * If you do not specify ids for the inputs, random ones will be
 * generated.
 * 
 * Arguments:
 *  interface_id - string id of the element to build on
 *  initial_commands - a list of initial commands to feed the interpreter
 *  in_argument_hash - *[optional]* optional hash of optional arguments
 * 
 * Returns:
 *  this object
 */
bbop.widget.repl = function(interface_id, initial_commands, in_argument_hash){
    this._is_a = 'bbop.widget.repl';

    // Aliases.
    var anchor = this;
    var loop = bbop.core.each;
    
    // Our argument default hash.
    var default_hash =
	{
	    'buffer_id': null,
	    'cli_id': null,
	    'display_initial_commands_p': true
	};
    var folding_hash = in_argument_hash || {};
    var arg_hash = bbop.core.fold(default_hash, folding_hash);
    var in_buffer_id = arg_hash['buffer_id'];
    var in_cli_id = arg_hash['cli_id'];
    var display_initial_commands_p = arg_hash['display_initial_commands_p'];

    // Get no commands if nothing else.
    var init_buffer = initial_commands || [];
    
    // The main div we'll work with.
    var repl_id = interface_id;
    jQuery('#' + repl_id).empty();

    // Save our CLI history as we go.
    var history_pointer = 0;
    var history_list = [''];

    ///
    /// Setup the HTML and layout on the page.
    ///

    // Env into work buffer.
    var command_buffer_args = {'rows': '12', cols:'80'};
    if( in_buffer_id ){
	command_buffer_args['id'] = in_buffer_id;
    }else{
	command_buffer_args['generate_id'] = true;
    }
    var command_buffer = new bbop.html.tag('textarea', command_buffer_args,
					   init_buffer.join("\n"));	
    jQuery('#' + repl_id).append(command_buffer.to_string());
    
    jQuery('#' + repl_id).append('<br />');

    // Command buffer eval button.
    var command_buffer_button = new bbop.html.button('Evaluate buffer',
	    				   {'generate_id': true});
    jQuery('#' + repl_id).append(command_buffer_button.to_string());

    // Clear buffer button.
    var clear_buffer_button = new bbop.html.button('Clear buffer',
	    					   {'generate_id': true});
    jQuery('#' + repl_id).append(clear_buffer_button.to_string());

    // Clear log button.
    var clear_log_button = new bbop.html.button('Clear log',
	    					{'generate_id': true});
    jQuery('#' + repl_id).append(clear_log_button.to_string());

    jQuery('#' + repl_id).append('<br />');

    // Log (+ clear botton).
    // //var logging_console_id = 'bbop-logger-console-text';
    // var logging_console_id = 'bbop-logger-console-textarea';
    // var logging_console = new bbop.html.tag('textarea',
    // 					    {'rows': '7', cols:'80',
    // 					     'readonly': 'readonly',
    // 					     'id': logging_console_id});
    var logging_console_id = 'bbop-logger-console-html';
    var logging_console = new bbop.html.tag('div',
    					    {'id': logging_console_id,
					     'class': 'nowrap',
    					     'style': 'height: 7em; width: 40em; border: 1px solid #888888; overflow: auto;'});
    jQuery('#' + repl_id).append(logging_console.to_string());

    //jQuery('#' + repl_id).append('<br />');

    // A usage message.
    var cli_msg = new bbop.html.tag('span', {},
				    "[eval: return; ctrl+up/down: history]:");
    jQuery('#' + repl_id).append(cli_msg.to_string());
    jQuery('#' + repl_id).append('<br />');

    // Command line.
    var command_line_args = {'rows': '1', cols:'80'};
    if( in_cli_id ){
	command_line_args['id'] = in_cli_id;
    }else{
	command_line_args['generate_id'] = true;
    }
    var command_line = new bbop.html.tag('textarea', command_line_args);
    jQuery('#' + repl_id).append(command_line.to_string());

    ///
    /// Core helper functions.
    ///

    // Per-UI logger. Notice that we waited until after the log div
    // was added to run this to make sure we bind to the right spot.
    var rlogger = new bbop.logger();
    rlogger.DEBUG = true;
    //function log(str){ rlogger.kvetch('repl (pre): ' + str); }
    function log(str){ rlogger.kvetch(str); }

    // Advance the log to the bottom.
    function _advance_log_to_bottom(){
    	// var cons = jQuery('#' + logging_console_id);
    	// var foo = cons.scrollTop(cons[0].scrollHeight);	
    };

    // Eval!
    function _evaluate(to_eval){

	var retval = null;
	var retval_str = '';
	var okay_p = true;

	try{
	    // If we get through this, things have gone well.
	    // Global eval actually kind of tricky:
	    //  http://perfectionkills.com/global-eval-what-are-the-options/
	    //var ret = eval(to_eval);
	    //var ret = jQuery.globalEval(to_eval);
	    retval = window.eval(to_eval);
	    if( bbop.core.is_defined(retval) ){
		//log('// in def if');
		if( bbop.core.what_is(retval) == 'string' ){
		    // // log('// in str if');
		    // retval_str = retval;
		    // // var gt_re = new RegExp("/\>/", "gi");
		    // // var lt_re = new RegExp("/\</", "gi");
		    // retval_str.replace(">", "&gt;");
		    // retval_str.replace("<", "&lt;");
		    // //retval_str = '<pre>' + retval_str + '</pre>';
		    // // log('// end: (' + retval_str + ')');
		    // retval_str = '<code>' + retval_str + '</code>';
		    // retval_str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
		    retval_str = '"' + retval + '"';
		}else{
		    retval_str = retval; // worth a try at least
		}
	    }else{
		// Maybe undefined, but probably just no return value.
		//retval_str = '[undefined]';
		retval_str = '';
	    }
	}catch (x){
	    // Bad things happened.
	    retval = null;
	    retval_str = '[n/a]';
	    okay_p = false;
	}

	return [retval, retval_str, okay_p];
    }

    // Update the CLI to the current point in the history.
    function _update_cli(){

	var item = history_list[history_pointer];
	jQuery('#' + command_line.get_id()).val(item);
	//log('// [history]: ' + item);
	//log('// history: '+history_pointer+', '+history_list.length);
	//_advance_log_to_bottom();
    }

    ///
    /// Build callbacks.
    ///
    
    // A lot of cases for button presses when reading from the command
    // line.
    function read_cli(event){

	var which = event.which;
	var ctrl_p = event.ctrlKey;
	//log('cli: ' + which + ', ' + ctrl_p);

	if ( which == 13 ) { // return
	    
	    // Stop events.
	    event.preventDefault();
	    
	    // Get and ensure nice JS, wipe CLI clean.
	    var to_eval = jQuery('#' + command_line.get_id()).val();
	    if( to_eval != '' ){
		jQuery('#' + command_line.get_id()).val('');
		
		// Enter the new command into our history and bump the
		// index to the last thing pushed on.
		history_list.pop(); // pop the empty ''
		history_list.push(to_eval);
		history_list.push(''); // push new empty ''
		history_pointer = history_list.length -1;
		//log('// history: '+history_pointer+', '+history_list.length);
		
		// Log, eval, log.
		to_eval = bbop.core.ensure(to_eval, ';', 'back');
		log(to_eval);
		var evals = _evaluate(to_eval);
		log('// ' + evals[1]);
		_advance_log_to_bottom();

		return false;
	    }
	}else if( ctrl_p && which == 38 ){ // ctrl + up

	    // Stop stuff?
	    event.preventDefault();

	    if( history_pointer == 0 ){
		_update_cli();
	    }else if( history_pointer > 0 ){
		history_pointer--;
		_update_cli();
	    }

	    return false;

	}else if( ctrl_p && which == 40 ){ // ctrl + down

	    // Stop stuff?
	    event.preventDefault();

	    if( history_pointer < history_list.length -1 ){
		history_pointer++;
		_update_cli();
	    }

	    return false;
	}

	return true;
    }
    jQuery('#' + command_line.get_id()).keydown(read_cli);

    // Bind buffer eval.
    function read_buffer(){
	var to_eval = jQuery('#' + command_buffer.get_id()).val();
	if( to_eval != '' ){
	    log('// Evaluating buffer...');
	    var evals = _evaluate(to_eval);
	    log('// ' + evals[1]);
	    _advance_log_to_bottom();
	}
    }
    var cbbid = '#' + command_buffer_button.get_id();
    var command_buffer_button_props = {
	icons: { primary: "ui-icon-play"},
	disabled: false,
	text: true
    };    
    jQuery(cbbid).button(command_buffer_button_props).click(read_buffer);

    // Bind buffer clear.
    function clear_buffer(){
	//jQuery('#' + logging_console_id).val('');
	//alert('to clear: ' + command_buffer.get_id());
	// FF, at least, does something weird here and empty() does
	// not always work--doubling seems to be file.
	jQuery('#' + command_buffer.get_id()).val('');
	//jQuery('#' + command_buffer.get_id()).empty();
    }
    var cbuid = '#' + clear_buffer_button.get_id();
    var clear_buffer_button_props = {
	icons: { primary: "ui-icon-trash"},
	disabled: false,
	text: true
    };
    jQuery(cbuid).button(clear_buffer_button_props).click(clear_buffer);

    // Bind log clear.
    function clear_log(){
	//jQuery('#' + logging_console_id).val('');
	jQuery('#' + logging_console_id).empty();
    }
    var clbid = '#' + clear_log_button.get_id();
    var clear_log_button_props = {
	icons: { primary: "ui-icon-trash"},
	disabled: false,
	text: true
    };
    jQuery(clbid).button(clear_log_button_props).click(clear_log);

    ///
    /// Bootstrap session.
    ///

    // Evaluate what we initially put in the command buffer.
    jQuery(cbbid).click(); // run the stuff in the buffer
    if( display_initial_commands_p == false ){ // maybe make it disappear
	clear_buffer();
	clear_log();
    }
    log('// [Session start.]');

    ///
    /// External use methods.
    ///

    /*
     * Function: get_id
     * 
     * Get the id of different components in the REPL.
     * 
     * Currently supported arguments are:
     *  - 'buffer'
     * 
     * Arguments:
     *  str - the item you want to check
     * 
     * Returns:
     *  string or null
     */
    this.get_id = function(str){

	var retval = null;

	if( str ){
	    if( str == 'buffer' ){
		retval = command_buffer.get_id();
	    }
	}

	return retval;
    };

    /*
     * Function: replace_buffer_text
     * 
     * Replace the buffer text with new text.
     * 
     * Arguments:
     *  str - the new text for the command buffer
     * 
     * Returns:
     *  n/a
     */
    this.replace_buffer_text = function(str){
	clear_buffer();
	//jQuery('#' + command_buffer.get_id()).append(str);
	jQuery('#' + command_buffer.get_id()).val(str);
    };

    /*
     * Function: advance_log_to_bottom
     * 
     * Can't be bothered to check now, but this needs to be done
     * separately from the log because of an initial race condition.
     * 
     * Arguments:
     *  n/a
     * 
     * Returns:
     *  n/a
     */
    this.advance_log_to_bottom = function(){
	_advance_log_to_bottom();
    };

    /*
     * Function: destroy
     * 
     * Remove the autocomplete and functionality from the DOM.
     * 
     * Arguments:
     *  n/a
     * 
     * Returns:
     *  n/a
     */
    this.destroy = function(){
	jQuery('#' + anchor._interface_id).val('');
    };

};
////////////
////
//// bbop.widget.phylo_old
////
//// Purpose: Extend the model to be handy for a (phylo)tree.
//// 
//// WARNING: This functionality is deprecated.
////
//// Width is determined by used div width (style).
//// 
//// Taken name spaces:
////    bbop.widget.phylo_old.*
////
//// TODO: better selection of displayable text
//// TODO: get parser so we can start really checking/use.
//// TODO: make things non-interactive during visible == false?
//// TODO: font and text placement
//// TODO: better text alignment
//// TODO: floating right-hand text (see PAINT)
//// TODO: some "speed-up" refactoring?
////
//// OKAY: FF, Safari, Chrome, Opera
//// TODO: IE a little wonky, but not too bad--easy fix?
////
//// Required:
////    Rafael
////    bbop.core
////    bbop.model
////    bbop.model.tree
////
//////////


// Module and namespace checking.
if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.widget == "undefined" ){ bbop.widget = {}; }
if ( typeof bbop.widget.phylo_old == "undefined" ){ bbop.widget.phylo_old = {}; }

///
/// PNodes (phylonode) object.
///

// Render out.
// Actually, use this to wrap graph abstraction.
bbop.widget.phylo_old.renderer = function (element_id, info_box_p){

    // Logger.
    var logger = new bbop.logger();
    logger.DEBUG = true;
    function ll(str){ logger.kvetch(str); }

    var elt_id = element_id;

    var renderer_context = this;

    // Properties that can be manipulated externally.
    //this.animation_time = 100;
    this.animation_time = 200;
    //this.animation_time = 1000; // for debug
    //this.use_animation = true;
    this.use_animation = false;

    // These first two defaults will be overwritten on display.
    this.box_width = 60;
    this.box_height = 30;

    // Internal-only variables.
    this._render_frame_width = 800;
    this._render_interal_width = this._render_frame_width;
    this._render_frame_height = 600;
    this._render_internal_height = this._render_height;
    //this._node_labels = {};
    //this._node_hover_labels = {};
    //this._edge_labels = {};
    //this._floating_labels = {};

    ///
    /// Functions to handle internal graph management.
    ///
    
    var node_cache_hash = {};
    this._graph = new bbop.model.tree.graph();

    //
    this.add_node = function(node){
	var nid = node.id();
	node_cache_hash[nid] = node;
	this._graph.add_node(node);
    };	

    //
    //this.add_edge = function(nid1, nid2, dist){
    this.add_edge = function(edge){

	var retval = false;

	var n1 = node_cache_hash[edge.subject_id()];
	var n2 = node_cache_hash[edge.object_id()];
	if( n1 && n2 ){
	    this._graph.add_edge(edge);
	    retval = true;	    
	}

	return retval;
    };

    ///
    /// ...
    ///

    // Init: context, label, x-coord, y-coord.
    graph_pnode = function(context, label, px, py, internal_p){

	var pnode_box_width = renderer_context.box_width;
	var pnode_box_height = renderer_context.box_height;

	// Color and size definitions.
	var text_offset_x = pnode_box_width / 2.0;
	var text_offset_y = pnode_box_height / 2.0;
	this.base_node_color = "#00f";

	// Variations if an internal node.
	if( internal_p ){
	    pnode_box_width = pnode_box_width / 2.0;
	    pnode_box_width = 2.0;
	    //pnode_box_height = 2.0;
	    text_offset_x = (pnode_box_width / 2.0);
	}

	// Future visibility.    
	this.visible = true;
	
	// For advanced tree use.
	this.open = true;
	
	// Coloration and style attributes.
	this.shape_base_attr = {
	    "fill": this.base_node_color,
	    "fill-opacity": 0.05,
	    "opacity": 1.0,
	    "stroke": this.base_node_color,
	    "stroke-width": 2,
	    "title": "This is " + label,
	    "cursor": "move"
	};
	this.shape_highlight_attr = {
	    "fill": this.base_node_color,
	    "fill-opacity": 0.5,
	    "opacity": 1.0,
	    "stroke": this.base_node_color,
	    "stroke-width": 3
	};
	this.shape_dim_attr = {
	    "fill": this.base_node_color,
	    "fill-opacity": 0.0,
	    "opacity": 0.5,
	    "stroke": this.base_node_color,
	    "stroke-width": 1
	};
	this.shape_invisible_attr = {
	    "fill": "#000",
	    "fill-opacity": 0.0,
	    "opacity": 0.0,
	    "stroke": "#000",
	    "stroke-width": 0
	};
	// Text in node.
	this.text_base_attr = {
	    //"fill-opacity": 1.0,
	    "opacity" : 1.0,
	    "font-size" : 10
	};
	//this.text_highlight_attr = {"fill-opacity": 1.0, "font-size" : 12};
	this.text_highlight_attr = {
	    //"fill-opacity": 1.0,
	    "opacity" : 1.0,
	    "font-size" : 10
	};
	this.text_dim_attr = {
	    //"fill-opacity": 0.2,
	    "opacity" : 0.2,
	    "font-size" : 10
	};
	this.text_invisible_attr = {
	    //"fill-opacity": 0.0,
	    "opacity" : 0.0,
	    "font-size" : 10
	};

	// Draw out initial node.
	this._context = context;

	this._text = // NOTE: text is *centered* at this point.
	this._context.text(px + text_offset_x, py + text_offset_y, label);
	this._text.toBack(); // make sure it's behind the boxes
	this._shape = this._context.rect(px, py,
					 pnode_box_width, pnode_box_height,
					 2);

	// Proxy properties and functions.
	// This is so wrong, but feels so good...proxy most things through
	// shape.
	this.id = this._shape.id; // Use the shape's UID as our UID.
	this.getBBox = function(){
	    return this._shape.getBBox.call(this._shape);
	};
	// Semi-proxy.
	this.shape_attr = function(arg){
	    return this._shape.attr.call(this._shape, arg);
	};

	// Add to the object the initial position.
	this._start_shape_y = this._shape.attr("y");
	this._start_text_y = this._text.attr("y");

	// Setup shape attributes.
	this._shape.attr(this.shape_base_attr);
    };
    // Call first when you want to move.
    graph_pnode.prototype.update_position = function(){
	this._start_shape_y = this._shape.attr("y");
	this._start_text_y = this._text.attr("y");
    };
    // Move.
    graph_pnode.prototype.move_y = function(arg){
	var d_shape = this._start_shape_y + arg;
	var d_text = this._start_text_y + arg;
	this._shape.attr.call(this._shape, {"y": d_shape});
	this._text.attr.call(this._text, {"y": d_text});
    };
    // Event handler proxies for underlying shapes (text ignored).
    graph_pnode.prototype.drag = function(mv_func,start_func,end_func){
	this._shape.drag(mv_func, start_func, end_func);
    };
    graph_pnode.prototype.dblclick = function(handler){
	this._shape.dblclick.call(this._shape, handler);
    };
    graph_pnode.prototype.mouseover = function(handler){
	this._shape.mouseover.call(this._shape, handler);
    };
    graph_pnode.prototype.mouseout = function(handler){
	this._shape.mouseout.call(this._shape, handler);
    };

    graph_pnode.prototype.update = function(message){

	//
	var shape_attr_to_apply = this.shape_base_attr;
	var text_attr_to_apply = this.text_base_attr;

	// 
	if( this.visible == false ){
	    shape_attr_to_apply = this.shape_invisible_attr;
	    text_attr_to_apply = this.text_invisible_attr;
	}else if( message == 'highlight' ){
	    shape_attr_to_apply = this.shape_highlight_attr;
	    text_attr_to_apply = this.text_highlight_attr;
	}else if( message == 'dim' ){
	    shape_attr_to_apply = this.shape_dim_attr;
	    text_attr_to_apply = this.text_dim_attr;
	}

	// Change border on whether or not it's "opened".
	if( this.open == false ){
	    shape_attr_to_apply['stroke'] = "#070";
	}else{
    	    shape_attr_to_apply['stroke'] = this.base_node_color;	
	}

	// Render with whatever filtered through.
	if( renderer_context.use_animation ){
	    this._shape.animate.call(this._shape,
				     shape_attr_to_apply,
				     renderer_context.animation_time);
	    this._shape.animate.call(this._text,
				     text_attr_to_apply,
				     renderer_context.animation_time);	
	}else{
	    this._shape.attr(shape_attr_to_apply);
	    this._text.attr(text_attr_to_apply);
	}
    };


    ///
    /// Define the edges (connections) to be used for drawing.
    /// Connection (between two pnodes) object.
    ///

    // Init: context, shape, shape, and "distance" representation
    // (optional).
    graph_connection = function(context, obj1, obj2, dist_rep){

	//this.context = context;

	// These need to be set right away for path calculation.    
	this.from = obj1;
	this.to = obj2;

	this.id = this.from.id + '_id_invariant_' + this.to.id;

	// Get path.
	var path_info = this.get_path_between_info();
	var path = path_info['path'];
	var cp = path_info['center_point'];

	// ll("conn: cp: (" + cp[0] + ", " + cp[1] + ")");

	// Future visibility.
	this.visible = true;

	var base_edge_color = "#030";
	var base_edge_width = "3";
	var highlight_edge_color = "#00f";
	var highlight_edge_width = "5";
	var invisible_edge_color = "#000";
	var invisible_edge_width = "0";

	this.edge_base_attr = {
	    "stroke": base_edge_color,
     	    "stroke-width": base_edge_width,
	    "fill": "none",
	    "opacity": 1.0,
	    "fill-opacity": 0.0
	};
	this.edge_highlight_attr = {
	    "stroke": highlight_edge_color,
     	    "stroke-width": highlight_edge_width,
	    "fill": "none",
	    "opacity": 1.0,
	    "fill-opacity": 0.0
	};
	this.edge_dim_attr = {
	    "stroke": base_edge_color,
     	    "stroke-width": 1,
	    "fill": "none",
	    "opacity": 0.5,
	    "fill-opacity": 0.0
	};
	this.edge_invisible_attr = {
	    "stroke": invisible_edge_color,
     	    "stroke-width": invisible_edge_width,
	    "fill": "none",
	    "opacity": 0.0,
	    "fill-opacity": 0.0
	};
	// // As connections.
	// this.text_base_attr = {"fill-opacity": 1.0, "font-size" : 10};
	// this.text_highlight_attr = {"fill-opacity": 1.0, "font-size" : 10};
	// this.text_dim_attr = {"fill-opacity": 0.2, "font-size" : 10};
	// this.text_invisible_attr = {"fill-opacity": 0.0, "font-size" : 10};
	// Highlight-only.
	this.text_base_attr = {
	    "opacity": 0.0,
	    "font-size" : 10
	};
	//this.text_highlight_attr = {"fill-opacity": 1.0, "font-size" : 12};
	this.text_highlight_attr = {
	    "opacity": 1.0,
	    "font-size" : 10
	};
	this.text_dim_attr = {
	    "opacity": 0.0,
	    "font-size" : 10
	};
	this.text_invisible_attr = {
	    "opacity": 0.0,
	    "font-size" : 10
	};

	// Build up text at path centerpoint.
	this.text = null;
	if( dist_rep ){
	    this.text = context.text(cp[0], (cp[1] + 10), dist_rep);
	    this.text.toBack(); // make sure it's behind the boxes
	    this.text.attr(this.text_base_attr);	
	}

	// Colors and lines.
	this.line = context.path(path);
	this.line.attr(this.edge_base_attr);
    };
    // Update line graphic.
    graph_connection.prototype.update = function(message){

	// Get path.
	var path_info = this.get_path_between_info();
	var path = path_info['path'];

	// Update line position.
	this.line.attr({path: path});

	// Update line graphics on message.
	var line_attr_to_apply = null;
	if( this.visible == false ){
	    line_attr_to_apply = this.edge_invisible_attr;
	}else if( message == 'highlight' ){
	    line_attr_to_apply = this.edge_highlight_attr;
	}else if( message == 'dim' ){
	    line_attr_to_apply = this.edge_dim_attr;
	}else{
	    line_attr_to_apply = this.edge_base_attr;
	}

	// Render with whatever filtered through.
	if( renderer_context.use_animation ){	
	    this.line.animate.call(this.line,
				   line_attr_to_apply,
				   renderer_context.animation_time);
	}else{
	    this.line.attr(line_attr_to_apply);
	}

	// Update text position.
	var text_attr_to_apply = null;
	if( this.text ){
	    var cp = path_info['center_point'];
	    this.text.attr({"x": cp[0], "y": (cp[1] + 10)});

	    // Update graphics graphics on message.
	    if( this.visible == false ){
		text_attr_to_apply = this.text_invisible_attr;
	    }else if( message == 'highlight' ){
		text_attr_to_apply = this.text_highlight_attr;
	    }else if( message == 'dim' ){
		text_attr_to_apply = this.text_dim_attr;
	    }else{
		text_attr_to_apply = this.text_base_attr;
	    }

	    // Render with whatever filtered through.
	    if( renderer_context.use_animation ){	
		this.text.animate.call(this.text,
				       text_attr_to_apply,
				       renderer_context.animation_time);
	    }else{
		this.text.attr(text_attr_to_apply);
	    }
	}
    };
    // // Generate path from between the two internally stored objects.
    // graph_connection.prototype.get_path_between_info = function(){

    // 	var bb1 = this.from.getBBox();
    // 	var bb2 = this.to.getBBox();

    // 	//ll("bb1.width: " + bb1.width);
    // 	//ll("bb1.x: " + bb1.x + ", bb1.y: " + bb1.y);
    // 	//ll("bb1.width: "+ bb1.width +", bb1.height: "+ bb1.height);

    // 	var p = [{x: bb1.x + bb1.width / 2, y: bb1.y - 1},
    // 		 {x: bb1.x + bb1.width / 2, y: bb1.y + bb1.height + 1},
    // 		 {x: bb1.x - 1, y: bb1.y + bb1.height / 2},
    // 		 {x: bb1.x + bb1.width + 1, y: bb1.y + bb1.height / 2},
    // 		 {x: bb2.x + bb2.width / 2, y: bb2.y - 1},
    // 		 {x: bb2.x + bb2.width / 2, y: bb2.y + bb2.height + 1},
    // 		 {x: bb2.x - 1, y: bb2.y + bb2.height / 2},
    // 		 {x: bb2.x + bb2.width + 1, y: bb2.y + bb2.height / 2}];
    // 	var d = {};
    // 	var dis = [];
    // 	for (var i = 0; i < 4; i++) {
    //         for (var j = 4; j < 8; j++) {
    // 		var dx = Math.abs(p[i].x - p[j].x);
    // 		var dy = Math.abs(p[i].y - p[j].y);
    // 		if ((i == j - 4) ||
    // 		    (((i != 3 && j != 6) || p[i].x < p[j].x) &&
    // 		     ((i != 2 && j != 7) || p[i].x > p[j].x) &&
    // 		     ((i != 0 && j != 5) || p[i].y > p[j].y) &&
    // 		     ((i != 1 && j != 4) || p[i].y < p[j].y))) {
    //                 dis.push(dx + dy);
    //                 d[dis[dis.length - 1]] = [i, j];
    // 		}
    //         }
    // 	}
    // 	var res = null;
    // 	if (dis.length == 0) {
    //         res = [0, 4];
    // 	}else{
    //         res = d[Math.min.apply(Math, dis)];
    // 	}
    // 	var x1 = p[res[0]].x;
    // 	var y1 = p[res[0]].y;
    // 	var x2 = p[res[1]].x;
    // 	var y2 = p[res[1]].y;
    // 	var dx = Math.max(Math.abs(x1 - x2) / 2, 10);
    // 	var dy = Math.max(Math.abs(y1 - y2) / 2, 10);
    // 	return {"path": [
    // 		    "M", x1.toFixed(3), y1.toFixed(3),
    // 		    "L", x1.toFixed(3), y2.toFixed(3),
    // 		    "L", x2.toFixed(3), y2.toFixed(3)
    // 		].join(","),
    // 		// "center_point": [(x1.toFixed(3) + x1.toFixed(3)),
    // 		// 		     (y1.toFixed(3) + y2.toFixed(3))]
    // 		"center_point": [(x1 + x2) / 2.0, (y2)]
    // 	       };
    // };

    // Generate path from between the two internally stored objects.
    graph_connection.prototype.get_path_between_info = function(){

	var bb1 = this.from.getBBox();
	var bb2 = this.to.getBBox();

	//ll("bb1.width: " + bb1.width);
	//ll("bb1.x: " + bb1.x + ", bb1.y: " + bb1.y);
	//ll("bb1.width: "+ bb1.width +", bb1.height: "+ bb1.height);

	var p =
	    [
		// bb1: middle-top
		{x: bb1.x + bb1.width / 2, y: bb1.y - 1},
		// bb1: middle-bottom
		{x: bb1.x + bb1.width / 2, y: bb1.y + bb1.height + 1},
		// bb1: left-middle
		{x: bb1.x - 1, y: bb1.y + bb1.height / 2},
		// bb1: right-middle
		{x: bb1.x + bb1.width + 1, y: bb1.y + bb1.height / 2},
		// bb2: middle-top
		//{x: bb2.x + bb2.width / 2, y: bb2.y - 1},
		{x: bb2.x - 1, y: bb2.y + bb2.height / 2},
		// bb2: middle-bottom
		//{x: bb2.x + bb2.width / 2, y: bb2.y + bb2.height + 1},
		{x: bb2.x - 1, y: bb2.y + bb2.height / 2},
		// bb2: left-middle
		{x: bb2.x - 1, y: bb2.y + bb2.height / 2},
		// bb2: right-middle
		//{x: bb2.x + bb2.width + 1, y: bb2.y + bb2.height / 2}
		{x: bb2.x - 1, y: bb2.y + bb2.height / 2}
	    ];
	var d = {};
	var dis = [];
	for (var i = 0; i < 4; i++) { // for bb1
            for (var j = 4; j < 8; j++) { // for bb2
		var dx = Math.abs(p[i].x - p[j].x);
		var dy = Math.abs(p[i].y - p[j].y);
		if ((i == j - 4) ||
    		    (((i != 3 && j != 6) || p[i].x < p[j].x) &&
    		     ((i != 2 && j != 7) || p[i].x > p[j].x) &&
    		     ((i != 0 && j != 5) || p[i].y > p[j].y) &&
    		     ((i != 1 && j != 4) || p[i].y < p[j].y))) {
                    dis.push(dx + dy);
                    d[dis[dis.length - 1]] = [i, j];
		}
            }
	}
	var res = null;
	if (dis.length == 0) {
            res = [0, 4];
	}else{
            res = d[Math.min.apply(Math, dis)];
	}
	var x1 = p[res[0]].x;
	var y1 = p[res[0]].y;
	var x2 = p[res[1]].x;
	var y2 = p[res[1]].y;
	//var dx = Math.max(Math.abs(x1 - x2) / 2, 10);
	//var dy = Math.max(Math.abs(y1 - y2) / 2, 10);
	return {"path": [
    		    "M", x1.toFixed(3), y1.toFixed(3),
    		    "L", x1.toFixed(3), y2.toFixed(3),
    		    "L", x2.toFixed(3), y2.toFixed(3)
		].join(","),
		// "center_point": [(x1.toFixed(3) + x1.toFixed(3)),
		// 		     (y1.toFixed(3) + y2.toFixed(3))]
		"center_point": [(x1 + x2) / 2.0, (y2)]
	       };
    };

    ///
    /// Functions and sub-functions for display.
    ///

    // TODO: later, allow display to take args to force size.
    this.display = function () {

	var layout = this._graph.layout();
	var elt = document.getElementById(elt_id);

	// Fudge variables.
	var edge_shift = 1.0; // fudge to allow the last little bit on screen
	var absolute_pull = 15.0; // there seems to be a misjudgement
				  // in width by about this much

	// Adjust vertical scales and display.
	var y_scale = renderer_context.box_height * 2.0; // fixed y-scale
	this._render_frame_height = (layout.max_width * y_scale);
	this._render_internal_height = this._render_frame_height - edge_shift;

	// Adjust for render width based on platform.
	// TODO: later, allow display to take args to force size.
	var x_scale = 1.0;
	//if( window && window.innerWidth && 1 == 2){
	    //this._render_frame_width = window.innerWidth;
	//}else 
	if( elt.clientWidth ){
	    this._render_frame_width = elt.clientWidth;
	}else{
	    ll("UFP: Unidentified Failing Platform.");
	}
	// Now adjust the drawing width to make sure that the boxes
	// fit.
	//this._render_internal_width = this._render_frame_width;
	this._render_internal_width =
	    this._render_frame_width
	    - (1.0 * renderer_context.box_width)
	    - absolute_pull;
	// If we're using the info box, adjust inwards by some amount.
	if( info_box_p ){
	    this._render_internal_width = this._render_internal_width * 0.8;
	}
	// Recalculate x-scale.
	x_scale = this._render_internal_width / layout.max_distance;
	// Get that last pixel column on board.
	ll('internal width: ' + this._render_internal_width);
	ll('frame width: ' + this._render_frame_width);

	// Create context.
	var paper = Raphael(elt_id,
			    this._render_frame_width,
			    this._render_frame_height);
	ll('display: made paper');

	///
	/// Graph helper function definitions.
	/// 

	function get_pnode_from_phynode_id(phynode_id){
	    var ret = null;
	    if( phynode_id_to_index[phynode_id] ){
		ret = phynodes[phynode_id_to_index[phynode_id]];
	    }
	    return ret;
	}

	// Subtree list, including self.
	function gather_list_from_hash(nid, hash){
    	    var retlist = new Array();
    	    retlist.push(nid);
    	    // Get all nodes cribbing from distances.
    	    for( vt in hash[nid] ){
    		//ll("id: " + id + ", v: " + ct);
    		retlist.push(vt);
    	    }
    	    return retlist;	
	}

	// Subtree list, including self.
	function get_descendant_node_list(nid){
	    return gather_list_from_hash(nid, layout.parent_distances);
	}

	// Ancestor list, including self.
	function get_ancestor_node_list(nid){
	    return gather_list_from_hash(nid, layout.child_distances);
	}

	//
	function get_associated(phynode_id, index_kept, getter){

    	    var retlist = new Array();
	    
    	    var node_id = phynode_id_to_node_id[phynode_id];
    	    var subtree_node_list = getter(node_id);
    	    for( var si = 0; si < subtree_node_list.length; si++ ){

    		var subnode_id = subtree_node_list[si];
    		var sindex = node_id_to_index[subnode_id];

    		var thing = index_kept[sindex];
    		retlist.push(thing);
    	    }

    	    return retlist;
	}

	function get_descendant_phynodes(phynode_id){
    	    return get_associated(phynode_id, phynodes, get_descendant_node_list);
	}

	function get_descendant_texts(phynode_id){
    	    return get_associated(phynode_id, texts, get_descendant_node_list);
	}

	function get_ancestor_phynodes(phynode_id){
    	    return get_associated(phynode_id, phynodes, get_ancestor_node_list);
	}

	// General func.
	function get_connections(phynode_id, phynode_getter, conn_hash){

	    var retlist = new Array();

	    // Fish in the connection ancestor hash for edges.
	    var tmp_phynodes = phynode_getter(phynode_id);
	    for( var si = 0; si < tmp_phynodes.length; si++ ){
		var tshp = tmp_phynodes[si];
		var tnid = phynode_id_to_node_id[tshp.id];
		if( tnid && conn_hash[tnid] ){
		    for( var anid in conn_hash[tnid] ){
			var conn_index = conn_hash[tnid][anid];
			var conn = connections[conn_index];
			ll('get_conn: found: [' + conn_index +
					 '] ' + anid + ' <=> ' + tnid +
					 ' ... ' + conn);
			retlist.push(conn);
		    }
		}
	    }
	    return retlist;
	};

	//
	function get_ancestor_connections(phynode_id){
	    return get_connections(phynode_id,
				   get_ancestor_phynodes,
				   conn_hash_ancestor);
	}

	//
	function get_descendant_connections(phynode_id){
	    return get_connections(phynode_id,
				   get_descendant_phynodes,
				   conn_hash_descendant);
	}

	///
	/// Phynode manipulation function definitions.
	/// 

	// Dragging animation (color dimming).
	var start = function () {

    	    var phynode_id = this.id;

	    // Darken boxes and update current position before dragging.
    	    var assoc_phynodes = get_descendant_phynodes(phynode_id);
    	    for( var si = 0; si < assoc_phynodes.length; si++ ){
		var phynode = assoc_phynodes[si];
		phynode.update_position();
		phynode.update("dim");
    	    }

	    // "Dim" edges.
	    var subtree_edges = get_descendant_connections(phynode_id);
	    for( var se = 0; se < subtree_edges.length; se++ ){
		var ste = subtree_edges[se];
		ste.update("dim");
	    }
	};

	// Movement animation (don't allow movement on the x-axis) and
	// redo lines.
	var move = function (dx, dy) {

    	    var phynode_id = this.id;

	    // Move box positions.
    	    var assoc_phynodes = get_descendant_phynodes(phynode_id);
    	    for( var si = 0; si < assoc_phynodes.length; si++ ){
		var mshp = assoc_phynodes[si];
		mshp.move_y(dy);
		//ll('mshp['+si+']:'+' oy: '+mshp.start_y+', dy:'+dy);
    	    }

	    // Collect subtree edges for next bit.
	    var dimmable_subtree = {};
	    var subtree_edges = get_descendant_connections(phynode_id);
	    for( var se = 0; se < subtree_edges.length; se++ ){
		var ste = subtree_edges[se];
		dimmable_subtree[ste.id] = true;
	    }

	    // Update connections; keep subtree dimmed while in transit.
            for (var i = connections.length; i--;) {
		var conn = connections[i];
		if( dimmable_subtree[conn.id] ){
		    conn.update('dim');		
		}else{
		    conn.update();		
		}
            }
            paper.safari();
	};

	// Undrag animation.
	var stop = function () {

    	    var phynode_id = this.id;

	    // Fade boxes.
    	    var assoc_phynodes = get_descendant_phynodes(phynode_id);
    	    for( var si = 0; si < assoc_phynodes.length; si++ ){
		var mshp = assoc_phynodes[si];
		mshp.update();
    	    }

	    // Update connections; bring them all back to normal.
            for (var i = connections.length; i--;) {
		connections[i].update();		
            }
            paper.safari();
	};

	// Experiment with double click.
	function dblclick_event_handler(event){

	    var phynode_id = this.id;

	    // If this is the first double click here...
	    var pn = get_pnode_from_phynode_id(phynode_id);
	    if( pn.open == true ){
		
		// "Vanish" edges.
		var subtree_edges = get_descendant_connections(phynode_id);
		for( var se = 0; se < subtree_edges.length; se++ ){
		    var ste = subtree_edges[se];
		    ste.visible = false;
		    ste.update();
		}

		// "Vanish" nodes and text; not this node though...
		var subtree_nodes = get_descendant_phynodes(phynode_id);
		for( var sn = 0; sn < subtree_nodes.length; sn++ ){
		    var stn = subtree_nodes[sn];
		    if( stn.id != phynode_id ){
			// Turn of visibilty for children.
			stn.visible = false;
		    }else{
			// Mark self as closed.
			stn.open = false;
		    }
		    stn.update();
		}
	    }else{ //Otherwise...
		
		// Reestablish edges.
		var subtree_edges = get_descendant_connections(phynode_id);
		for( var se = 0; se < subtree_edges.length; se++ ){
		    var ste = subtree_edges[se];
		    ste.visible = true;
		    ste.update();
		}

		// Restablish pnodes; clear all history.
		var subtree_nodes = get_descendant_phynodes(phynode_id);
		for( var sn = 0; sn < subtree_nodes.length; sn++ ){
		    var stn = subtree_nodes[sn];
		    stn.open = true;
		    stn.visible = true;
		    stn.update();
		}
	    }
	}

	// Experiment with hover.
	function mouseover_event_handler(event){

    	    var phynode_id = this.id;

	    // Cycle through ancestor phynodes.
    	    var anc_phynodes = get_ancestor_phynodes(phynode_id);
    	    for( var ai = 0; ai < anc_phynodes.length; ai++ ){
		// Change boxes opacity (darken).
		var ashp = anc_phynodes[ai];
		ashp.update("highlight");
	    }
	    // Cycle through descendant phynodes.
    	    var desc_phynodes = get_descendant_phynodes(phynode_id);
    	    for( var di = 0; di < desc_phynodes.length; di++ ){
		// Change boxes opacity (darken).
		var dshp = desc_phynodes[di];
		dshp.update("highlight");
	    }

	    // See if we can fish any edges out and highlight them.
    	    var anc_edges = get_ancestor_connections(phynode_id);
    	    for( var ac = 0; ac < anc_edges.length; ac++ ){
		var aconn = anc_edges[ac];
		aconn.update("highlight");
	    }
    	    var desc_edges = get_descendant_connections(phynode_id);
    	    for( var dc = 0; dc < desc_edges.length; dc++ ){
		var dconn = desc_edges[dc];
		dconn.update("highlight");
	    }
	    paper.safari();
	}
	function mouseout_event_handler(event){

    	    var phynode_id = this.id;

	    // Cycle through ancestor phynodes.
    	    var anc_phynodes = get_ancestor_phynodes(phynode_id);
    	    for( var ai = 0; ai < anc_phynodes.length; ai++ ){
		// Change boxes opacity (lighten).
		var ashp = anc_phynodes[ai];
		ashp.update();
    	    }
	    // Cycle through descendant phynodes.
    	    var desc_phynodes = get_descendant_phynodes(phynode_id);
    	    for( var di = 0; di < desc_phynodes.length; di++ ){
		// Change boxes opacity (lighten).
		var dshp = desc_phynodes[di];
		dshp.update();
    	    }

	    // See if we can fish any edges out and unhighlight them.
    	    var anc_edges = get_ancestor_connections(phynode_id);
    	    for( var ac = 0; ac < anc_edges.length; ac++ ){
		var aconn = anc_edges[ac];
		aconn.update();
	    }
    	    var desc_edges = get_descendant_connections(phynode_id);
    	    for( var dc = 0; dc < desc_edges.length; dc++ ){
		var dconn = desc_edges[dc];
		dconn.update();
	    }
	    paper.safari();
	}

	///
	///  Render info box if wanted.
	///

	if( info_box_p ){
	    
	    //var lnodes = this._graph.get_leaf_nodes();
	    // Get the last ordered cohort and build table from that.
	    var lnodes = layout.cohorts[layout.cohorts.length - 1];
	    for( var ln = 0; ln < lnodes.length; ln++ ){	    
		var lnode = lnodes[ln];

		var pr_xa = paper.width - (paper.width * 0.2) + 20; // x-axis
		var pr_ya = 1.0 + (y_scale * ln); // y-axis
		var bw = (paper.width * 0.2) - 30.0; // width
		var bh = y_scale - 1.0; // height
		var pr = paper.rect(pr_xa, pr_ya,
				    bw, bh,
				    1); // roundness
		pr.attr({
			    "fill": "#eeee99",
			    "fill-opacity": 0.5,
			    "opacity": 1.0,
			    "stroke": "#333388",
			    "stroke-width": 1,
			    "title": "This is " + lnode.id
			    //"cursor": "move"
			});

		var pt = paper.text(pr_xa + (bw / 2.0), pr_ya + (bh / 2.0),
				    "Data for " + lnode.id);
	    }
	}

	///
	/// Phynode creation and placement.
	/// 

	// Add phynodes and create lookup (hash) for use with connections.
	var phynodes = new Array();
	var phynode_hash = {};
	var texts = new Array();
	var phynode_id_to_index = {};
	var phynode_id_to_node_id = {};
	var node_id_to_index = {};
	for( var nidi = 0; nidi < layout.node_list.length; nidi++ ){

	    // Calculate position.
	    var node_id = layout.node_list[nidi];
	    var lpx = (layout.position_x[node_id] * x_scale) + edge_shift;
	    var lpy = (layout.position_y[node_id] * y_scale) + edge_shift;

	    // Create node at place. 
	    var phynode = null;
	    if( ! this._graph.is_leaf_node(node_id) && info_box_p ){
		ll('display: internal node: ' + node_id);
		phynode = new graph_pnode(paper, node_id, lpx, lpy, true);
		//phynode.attr("width") = 10;
		//phynode.attr("height") = 10;
	    }else{
		phynode = new graph_pnode(paper, node_id, lpx, lpy);
	    }

            phynodes.push(phynode);

	    // Indexing for later (edge) use.
	    phynode_hash[node_id] = nidi;

	    // More indexing.
	    var ref_index = phynodes.length -1;
	    var phynode_id = phynode.id;
	    phynode_id_to_index[phynode_id] = ref_index;
	    phynode_id_to_node_id[phynode_id] = node_id;
	    node_id_to_index[node_id] = ref_index;

	    ll('display: indexed (node): node_id: ' + node_id +
			     ', phynode_id: ' + phynode_id +
			     ', ref_index: ' + ref_index);
	}

	// Add listeners.
	for (var i = 0, ii = phynodes.length; i < ii; i++) {
	    phynodes[i].dblclick(dblclick_event_handler);
            phynodes[i].drag(move, start, stop);
	    phynodes[i].mouseover(mouseover_event_handler);
	    phynodes[i].mouseout(mouseout_event_handler);
	}

	// Add stored connections.
	var connections = new Array();
	var conn_hash_ancestor = {};
	var conn_hash_descendant = {};
	for( var ei = 0; ei < layout.edge_list.length; ei++ ){

	    //
	    var edge = layout.edge_list[ei];
	    var e0 = edge[0];
	    var e1 = edge[1];

	    // Push edge onto array.
	    var n0_pnode = phynodes[phynode_hash[e0]];
	    var n1_pnode = phynodes[phynode_hash[e1]];
	    var d_label = layout.parent_distances[e0][e1] + '';
	    var nconn = new graph_connection(paper, n0_pnode, n1_pnode,
					     d_label);
	    connections.push(nconn);

	    // Index edge index for later recall.
	    if( ! conn_hash_descendant[e0] ){ conn_hash_descendant[e0] = {}; }
	    conn_hash_descendant[e0][e1] = ei;
	    if( ! conn_hash_ancestor[e1] ){ conn_hash_ancestor[e1] = {}; }
	    conn_hash_ancestor[e1][e0] = ei;

	    ll('display: indexed (edge): e0: ' + e0 +
	       ', e1: ' + e1 +
	       ', ei: ' + ei);
	}
	
	// See: https://github.com/sorccu/cufon/wiki/about
	// See: http://raphaeljs.com/reference.html#getFont
	// var txt = paper.print(100, 100, "print",
	//  paper.getFont("Museo"), 30).attr({fill: "#00f"});
	//paper.print(100, 100, "Test string", paper.getFont("Times", 800), 30);
	//txt[0].attr({fill: "#f00"});
    };

};
if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.widget == "undefined" ){ bbop.widget = {}; }
if ( typeof bbop.widget.phylo_tree == "undefined" ){ bbop.widget.phylo_tree = {}; }

(function() {

bbop.widget.phylo_tree.renderer = renderer;

// if there is more than one phylo tree on the page, this counter
// makes the CSS prefixes unique
var id_counter = 0;

// see default_config for a description of possible config settings
function renderer(parent, config){
    this.parent = ( ( "string" == typeof parent )
		    ? document.getElementById(parent)
		    : parent );
    if (this.parent === undefined) {
        throw "can't find parent element " + parent;
    }
    this.tree = new tree();
    this.node_hidden = {};
    this.children_hidden = {};
    this._sort = "ladderize_up";
    this._layout_dirty = true;
    this._css_prefix = "phylo_tree_" + (id_counter++) + "_";

    var self = this;
    this.node_elem_click_handler = function(event) {
        var node_elem =
            (event.currentTarget) ? event.currentTarget : event.srcElement;
        var node = self.tree.nodes[node_elem.node_id];
        if (node) return self.node_clicked(node, node_elem, event);
    };

    var default_config = {
        // these are in pixels
        // leaf box vertical height, including padding and borders
        box_height: 24,
        // vertical space between leaf boxes
        box_spacing: 10,
        // space between leaf box edge and leaf label
        leaf_padding: 4,
        // leaf border thickness
        leaf_border: 2,
        // leaf left offset
        leaf_margin: 1,
        // width/height of internal nodes
        node_size: 8,

        // leaf border color
        leaf_border_color: "blue",
        // font for leaf labels
        leaf_font: "Helvetica, Arial, sans-serif",
        transition_time: "0.8s"
    };

    this.config = ("object" == typeof config
                   ? bbop.core.merge(default_config, config)
                   : default_config);

    //config settings with default values dependent on other config values
    this.config.parent_padding = ( (this.config.parent_padding === undefined)
                                   ? ((this.config.box_spacing / 2) | 0)
                                   : this.config.parent_padding );

    this.node_style = {
        position: "absolute",
        background: "white",
        "z-index": 2,
        width: this.config.node_size + "px",
        height: this.config.node_size + "px",
        "margin-top": (-this.config.node_size / 2) + "px",
        "margin-left": (-this.config.node_size / 2) + "px",
        border: "1px solid black",
        "transition-property": "top, left",
        "transition-duration": this.config.transition_time,
        "transition-timing-function": "ease-in-out, ease-in-out",
        "box-sizing": "content-box",
        "-moz-box-sizing": "content-box"
    };

    this.leaf_style = {
        position: "absolute",
        background: "#f1f1ff",
        "z-index": 1,
        padding: this.config.leaf_padding + "px",
        // if leaf_padding is too low, the branch line will touch the text
        "padding-left": Math.max(this.config.leaf_padding, 3) + "px",

        // so that the leaves don't cover up the connection lines
        "margin-left": this.config.leaf_margin + "px",

        "margin-top": (-this.config.box_height / 2) + "px",

        // setting font size from box height.  We'd like to set font cap height
        // directly, but we can only set em box size.  Cap height on average is
        // 70% of em box size, so we'll set the font size to the intended
	// height divided by 0.7
        font: ( ( this.config.box_height
                  - ( this.config.leaf_padding * 2 )
                  - ( this.config.leaf_border * 2 ) )
                / 0.7 ) + "px " + this.config.leaf_font,

        // this.config.box_height includes padding and borders, so we
        // subtract those out to set the CSS height, which doesn't include
        // padding or borders
        height: ( this.config.box_height
                  - ( this.config.leaf_padding * 2 )
                  - ( this.config.leaf_border * 2 ) ) + "px",

        // center vertically by setting the line height to 0.7em
        // (corresponding to the way we set font size above)
        "line-height": "0.7em",
        "border-radius": (this.config.leaf_padding + 1) + "px",
        "white-space": "nowrap",
        "transition-property": "top, left",
        "transition-duration": this.config.transition_time,
        "transition-timing-function": "ease-in-out, ease-in-out",
        "box-sizing": "content-box",
        "-moz-box-sizing": "content-box"
    };

    if (this.config.leaf_border > 0) {
        this.leaf_style.border =
            this.config.leaf_border + "px solid "
            + this.config.leaf_border_color;
    }

    this.connection_style = {
        position: "absolute",
        "border-left": "2px solid black",
        "border-top": "2px solid black",
        "border-bottom": "2px solid black",
        "border-right": "none",
        "transition-property": "top, height, left, width, border",
        "transition-duration": this.config.transition_time,
        "transition-timing-function": 
            "ease-in-out, ease-in-out, ease-in-out, ease-in-out, step-start"
    };
};

renderer.prototype.subtree_hidden = function(node_id) {
    return this.children_hidden[node_id];
};

// sets the given css_string as a new stylesheet, or replaces this object's
// stylesheet with css_string if one has already been set
renderer.prototype.set_styles = function(css_string) {
    if (! this._style_node) {
        head = document.getElementsByTagName('head')[0],
        this._style_node = document.createElement('style');
        this._style_node.type = 'text/css';
        head.appendChild(this._style_node);
    }

    if (this._style_node.styleSheet) {
        // IE
        this._style_node.styleSheet.cssText = css_string;
    } else {
        while (this._style_node.firstChild) {
            this._style_node.removeChild(this._style_node.firstChild);
        }
        this._style_node.appendChild(document.createTextNode(css_string));
    }
};

renderer.prototype.add_node = function(unique_id, label, meta){
    this.tree.add_node(unique_id, label, meta);
    this._layout_dirty = true;
};

renderer.prototype.add_edge = function(nid1, nid2, dist){
    this.tree.add_edge(nid1, nid2, dist);
    this._layout_dirty = true;
};

renderer.prototype.display = function () {
    if (this.container) this.parent.removeChild(this.container);

    this.container = document.createElement("div");
    this.container.style.cssText = [
        "position: absolute",
        "top: 0px",
        "left: " + ( (this.config.node_size / 2)
                     + this.config.parent_padding ) + "px",
        "margin: 0px",
        "padding: 0px",
        "transition-property: width, height",
        "transition-duration: " + this.config.transition_time,
        "transition-timing-function: ease-in-out"
    ].join(";") + ";";

    var node_class = this._css_prefix + "node";
    var leaf_class = this._css_prefix + "leaf";
    var conn_class = this._css_prefix + "conn";
        
    this.set_styles([
        "div." + node_class + " {" + css_string(this.node_style) + "}",
        "div." + leaf_class + " {" + css_string(this.leaf_style) + "}",
        "div." + conn_class + " {" + css_string(this.connection_style) + "}"
    ].join("\n"));

    var phynodes = {};
    for (var node_id in this.tree.nodes) {
        var node = this.tree.nodes[node_id];
        var phynode = new graph_pnode(node,
                                      node_class, leaf_class,
                                      this.config.box_height);
        this.container.appendChild(phynode.node_elem);
        phynode.node_elem.onclick = this.node_elem_click_handler;
        phynodes[node.id] = phynode;
    }
    this._phynodes = phynodes;

    var container = this.container;
    var self = this;
    this.tree.iterate_edges(function(parent, child) {
        if (self.node_hidden[child.id]) return;
        var child_phynode = phynodes[child.id];
        child_phynode.set_parent(
            phynodes[parent.id],
            conn_class
        );
        container.appendChild(child_phynode.conn_elem);
    });

    this.position_nodes();
    this.parent.appendChild(this.container);

    this.width_changed(this.parent.clientWidth);
};

renderer.prototype.position_nodes = function() {
    // x_scale will be percentage units
    var x_scale = 100 / this.max_distance();

    // row_height is in pixel units
    var row_height = this.config.box_height + this.config.box_spacing;

    // the position values from the tree layout are center
    // positions, and the very top one has a y-position of 0.
    // if a leaf node box is centered at that point, then the
    // top half of the top box would get cut off.  So we move
    // all of the positions down by top_margin pixels.
    var top_margin = ( (this.config.box_height / 2)
                       + this.config.parent_padding );

    var layout = this.layout();
    var self = this;
    this.tree.iterate_preorder(function(node) {
	var node_pos = layout[node.id];

	var x = (node_pos.x * x_scale);
	var y = (node_pos.y * row_height) + top_margin;
        self._phynodes[node_pos.id].set_position(x, y);
        if (self.subtree_hidden(node.id)) return true;
    });
    this.tree_height = ( (this.leaves().length * row_height)
                         - this.config.box_spacing
                         + (this.config.parent_padding * 2) );

    this.parent.style.transition =
        "height " + this.config.transition_time + " ease-in-out";
    this.parent.style.height = this.tree_height + "px";
    this.container.style.height = this.tree_height + "px";
};

renderer.prototype.max_distance = function() {
    if (this._layout_dirty) this._update_layout();
    return this._max_distance;
};

renderer.prototype.leaves = function() {
    if (this._layout_dirty) this._update_layout();
    return this._leaves;
};

renderer.prototype.layout = function() {
    if (this._layout_dirty) this._update_layout();
    return this._layout;
};

renderer.prototype._update_layout = function() {
    this._do_sort(this._sort);
    var self = this;

    var visible_leaves = [];
    this.tree.iterate_preorder(function(node) {
        if (self.node_hidden[node.id]) return;
        // nodes with hidden children are leaves for layout purposes
        if (node.is_leaf() || self.children_hidden[node.id]) {
            visible_leaves.push(node);
        }
    });
    this._leaves = visible_leaves;

    var roots = this.tree.roots();
    var root_distances = [];
    for (var i = 0; i < roots.length; i++) {
        root_distances.push(roots[i].parent_distance);
    }
    // if we're only showing a subtree, position the leftmost subtree
    // root all the way to the left
    this.x_offset = -min(root_distances);

    this._max_distance = max(this.tree.traverse(
        function(node, down_data) {
            return down_data + node.parent_distance;
        },
        this.x_offset,
        function(node, child_results, down_data) {
            if (self.node_hidden[node.id]) return 0;

            return Math.max(down_data, max(child_results));
        }
    ) );

    this._layout = this._do_layout();
    this._layout_dirty = false;
};

// returns an array of {id, x, y} objects (one per node)
renderer.prototype._do_layout = function() {
    var leaf_counter = 0;
    var self = this;
    var layout_list = Array.prototype.concat.apply([], this.tree.traverse(
        function(node, down_data) {
            return down_data + node.parent_distance;
        },
        this.x_offset,
        function(node, child_results, down_data) {
            // don't lay out the node if it's hidden
            if (self.node_hidden[node.id]) return [];

            // don't try to average child positions if children are hidden
            if (! (node.id in self.children_hidden)) {
                var immediate_child_y_sum = 0;
                for (var i = 0; i < child_results.length; i++) {
                    // child_results will be an array with one element
                    // for each child.  Each of those elements is an
                    // array of position objects.  The first position
                    // object is the position of the immediate child,
                    // and the rest of the position objects are for
                    // that child's descendants.  (see how the return
                    // value is constructed below)
                    immediate_child_y_sum += child_results[i][0].y;
                }
            }
            
            var my_pos = [{
                id: node.id,
                x: down_data,
                y: ( ( node.is_leaf() || self.children_hidden[node.id] )
                     // The traverse method goes depth-first, so we'll
                     // encounter the leaves in leaf-order.  So the
                     // y-coord for leaves is just the number of
                     // leaves we've seen so far.
                     ? leaf_counter++
                     // The internal node y-coord is the mean of its
                     // child y-coords
                     : ( immediate_child_y_sum / child_results.length ) )
            }];
            // flatten child result arrays and append the result to my_pos
            return Array.prototype.concat.apply(my_pos, child_results);
        }
    ) );

    var layout_hash = {};
    for (var i = 0; i < layout_list.length; i++) {
        layout_hash[layout_list[i].id] = layout_list[i];
    }
    return layout_hash;
};

// call this when the width of the tree's parent element changes
renderer.prototype.width_changed = function(parent_width) {
    var leaves = this.leaves();
    var avail_width = ( parent_width 
                        - (this.config.node_size / 2)
                        - (this.config.parent_padding * 2)
                        - this.config.leaf_margin );

    var min_width = Number.MAX_VALUE;
    for (var li = 0; li < leaves.length; li++) {
        var leaf_id = leaves[li].id;
        var phynode = this._phynodes[leaf_id];

        // Each potential width is the width that this.container
        // would have to be so that the leaf label fits into this.parent.
        // We take the minimum because that's the most conservative of
        // all the potential widths we calculate here.
        var potential_width =
            // dividing px by 100 because px is in percentage units
            (avail_width - phynode.width()) / (phynode.px / 100)
        min_width = Math.min(min_width, potential_width);
    }
    this.container.style.width = Math.max(0, min_width | 0) + "px";
};

// hides the subtree under the given node_id; for that node,
// it shows the label and a visual ellipsis
renderer.prototype.hide_subtree = function(node_id) {
    var to_hide_under = this.tree.nodes[node_id];
    if (to_hide_under === undefined) {
        throw "asked to hide non-existent node " + node_id;
    }
    // there's nothing to hide under a leaf node
    if (to_hide_under.is_leaf()) return;

    var self = this;
    to_hide_under.iterate_preorder(function(node) {
        // don't hide the given node
        if (node === to_hide_under) return;

        self.node_hidden[node.id] = true;
        self._phynodes[node.id].hide();
    });
    self.children_hidden[to_hide_under.id] = true;
    self._phynodes[to_hide_under.id].set_children_hidden();

    this._layout_dirty = true;
    this.position_nodes();
    this.width_changed(this.parent.clientWidth);
};

// show a previously-hidden subtree
renderer.prototype.show_subtree = function(node_id) {
    var to_show_under = this.tree.nodes[node_id];
    if (to_show_under === undefined) {
        throw "asked to show non-existent node " + node_id;
    }

    var self = this;
    // remove this node from children_hidden
    delete self.children_hidden[to_show_under.id];
    to_show_under.iterate_preorder(function(node) {
        if (node === to_show_under) return;

        delete self.node_hidden[node.id];
        self._phynodes[node.id].show();
        
        // returning true stops the iteration: if we encounter a
        // previously-hidden subtree under the node that we're
        // showing, we'll leave its children hidden unless it's
        // specifically shown
        if (self.children_hidden[node.id]) return true;
    });
    self._phynodes[to_show_under.id].set_children_visible();

    this._layout_dirty = true;
    this.position_nodes();
    this.width_changed(this.parent.clientWidth);
};

// hide everything except the subtree rooted at the given node
renderer.prototype.show_only_subtree = function(node_id) {
    var to_show = this.tree.nodes[node_id];
    if (to_show === undefined) {
        throw "asked to show non-existent node " + node_id;
    }

    // hide all nodes except those under the given node
    var self = this;
    this.tree.iterate_preorder(function(node) {
        // returning true stops the iteration: we don't want to hide
        // any nodes under this node, so we'll stop the iteration here
        // for the subtree rooted at the current node
        if (node === to_show) return true;

        self.node_hidden[node.id] = true;
        self._phynodes[node.id].hide();
    });
    this.tree.set_roots([to_show.id]);
    this._phynodes[node_id].hide_connector();

    this._layout_dirty = true;
    this.position_nodes();

    this.width_changed(this.parent.clientWidth);
};

// returns true if we're showing only a subtree rooted at the node
// with the given id, false otherwise
renderer.prototype.only_subtree_shown = function(node_id) {
    var node = this.tree.nodes[node_id];
    return contains(this.tree.roots(), node) && node.has_parent();
};

// undo show_only_subtree
renderer.prototype.show_global_root = function() {
    this.tree.clear_roots();
    
    var self = this;
    this.tree.iterate_preorder(function(node) {
        delete self.node_hidden[node.id];
        var phynode = self._phynodes[node.id];
        phynode.show();
        if (! phynode.connector_shown) phynode.show_connector();
        
        // returning true stops the iteration: if we encounter a
        // previously-hidden subtree under the node that we're
        // showing, we'll leave its children hidden unless it's
        // specifically shown
        if (self.children_hidden[node.id]) return true;
    });

    this._layout_dirty = true;
    this.position_nodes();
    this.width_changed(this.parent.clientWidth);
};

renderer.prototype.node_clicked = function() {};

renderer.prototype.set_sort = function(sort) {
    if (sort == this._sort) return;
    this._sort = sort;
    this._layout_dirty = true;
};

// sort the tree according to the given sort ordering
// see available_sorts for available sort arguments
renderer.prototype._do_sort = function(sort) {
    // leaf_counts: for each node, contains the number of its descendant leaves
    var leaf_counts = {};
    this.tree.traverse(
        function() {}, null,
        function(node, child_results, down_data) {
            // if this is a leaf, call the leaf count 1
            var leaf_count = node.is_leaf() ? 1 : sum(child_results);
            leaf_counts[node.id] = leaf_count;
            return leaf_count;
        }
    );

    var available_sorts = {
        ladderize_up: function(a, b) {
            return leaf_counts[b.id] - leaf_counts[a.id];
        },
        ladderize_down: function(a, b) {
            return leaf_counts[a.id] - leaf_counts[b.id];
        },
        alphabetical: function(a, b) {
            if( a.id == b.id ) return 0;
            return (a.id < b.id) ? -1 : 1;
        }
    };

    if ("string" == typeof sort) {
        if( ! sort in available_sorts ) throw "unknown sort " + sort;
        this.tree.sort_children(available_sorts[sort]);
    } else if ("function" == typeof sort) {
        this.tree.sort_children(sort);
    }
};

renderer.prototype.iterate_preorder = function(callback) {
    var self = this;
    this.tree.iterate_preorder(function(node) {
        // if the node is hidden, there won't be anything in self._phynodes
        if (self.node_hidden[node.id]) return;
        return callback(node.id, node.label, node.meta,
                        self._phynodes[node.id].node_elem,
                        node.children);
    });
};

renderer.prototype.traverse = function(down_fun, down_data, up_aggregator) {
    var self = this;
    return this.tree.traverse(down_fun, down_data, up_aggregator);
};

///
/// phylo node html renderer
///

function graph_pnode(node, node_class, leaf_class, height){
    this.node = node;
    this.height = height;
    this.leaf_class = leaf_class;
    this.connector_shown = false;

    var node_elem = document.createElement("div");
    if (node.is_leaf()) {
        node_elem.appendChild(document.createTextNode(node.label));
        node_elem.className = leaf_class;
    } else {
        node_elem.title = node.label;
        node_elem.className = node_class;
    }

    node_elem.node_id = node.id;
    this.node_elem = node_elem;
}

graph_pnode.prototype.set_children_hidden = function() {
    var left_offset = 10;
    this.subtree_box = document.createElement("div");
    this.subtree_box.className = this.leaf_class;
    this.subtree_box.style.backgroundColor = "#eee";
    this.subtree_box.style.left = left_offset + "px";
    this.subtree_box.style.top =
        ((this.height / 2) - (this.node_elem.offsetHeight / 2 ) ) + "px";
    this.subtree_box.appendChild(
        document.createTextNode(this.node.label + " ...")
    );

    this.subtree_box.node_id = this.node.id;
    this.node_elem.appendChild(this.subtree_box);
    this._width = left_offset + this.subtree_box.offsetWidth;
};

graph_pnode.prototype.set_children_visible = function() {
    this._width = this.node_elem.offsetWidth;
    this.node_elem.removeChild(this.subtree_box);
};

graph_pnode.prototype.hide = function() {
    this.node_elem.style.display = "none";
    if (this.parent) this.conn_elem.style.display = "none";
};

graph_pnode.prototype.hide_connector = function() {
    if (this.parent) this.conn_elem.style.display = "none";
    this.connector_shown = false;
};

graph_pnode.prototype.show = function() {
    this.node_elem.style.display = "";
    if (this.parent) this.conn_elem.style.display = "";
};

graph_pnode.prototype.show_connector = function() {
    if (this.parent) this.conn_elem.style.display = "";
    this.connector_shown = true;
};

graph_pnode.prototype.set_position = function(x, y) {
    this.px = x;
    this.py = y;

    this.node_elem.style.left = x + "%";
    this.node_elem.style.top = y + "px";

    if (this.parent && this.connector_shown) {
        var conn_style =
            "top: " + Math.min(this.parent.py, this.py) + "px;"
            + "left: " + this.parent.px + "%;"
            + "width: " + (this.px - this.parent.px) + "%;"
            + "height: " + Math.abs(this.parent.py - this.py) + "px;";

        if (this.py < this.parent.py) {
            // upward connection
            conn_style += "border-bottom: none;";
        } else {
            // downward connection
            conn_style += "border-top: none;";
        }
        this.conn_elem.style.cssText = conn_style;
    }
}

graph_pnode.prototype.set_parent = function(parent, conn_class) {
    this.parent = parent;
    this.conn_elem = document.createElement("div");
    this.conn_elem.className = conn_class;
    this.conn_elem.id=parent.node.id + "-" + this.node.id;
    this.connector_shown = true;
};

graph_pnode.prototype.width = function() {
    if (! ("_width" in this)) this._width = this.node_elem.offsetWidth;
    return this._width;
};

///
/// a tree with distances on each edge
///

function tree() {
    this.nodes = {};
    // if _dirty is true, then the stuff that's calculated in _summarize()
    // is out of date
    this._dirty = true;
}

tree.prototype.add_node = function(id, label, meta) {
    this.nodes[id] = new node(id, label, meta);
    this._dirty = true;
};

tree.prototype.add_edge = function(parent_id, child_id, distance) {
    var parent = this.nodes[parent_id];
    var child = this.nodes[child_id];
    if( "undefined" == typeof parent ){
        throw "parent node " + parent_id + " not found";
    }
    if( "undefined" == typeof child ){
        throw "child node " + child_id + " not found";
    }
    parent.add_child(child, distance);
    this._dirty = true;
};

tree.prototype.sort_children = function(compare_fun) {
    var roots = this.roots();
    roots.sort(compare_fun);
    for (var i = 0; i < roots.length; i++) {
        roots[i].sort_children(compare_fun);
    }
};

tree.prototype.iterate_preorder = function(fun) {
    var roots = this.roots()
    for (var i = 0; i < roots.length; i++) {
        roots[i].iterate_preorder(fun);
    }
};

tree.prototype.iterate_edges = function(fun) {
    for (var id in this.nodes) {
        var parent = this.nodes[id];
        for (var i = 0; i < parent.children.length; i++) {
            fun(parent, parent.children[i]);
        }
    }
};

tree.prototype._summarize = function() {
    if (this._dirty) this.clear_roots();
    this._dirty = false;
};

tree.prototype.roots = function() {
    if (this._dirty) this._summarize();
    return this._roots;
};

// set the roots to be specific nodes
// i.e. to only show a subtree, set_roots(subtree_node_id)
tree.prototype.set_roots = function(root_ids) {
    var roots = [];
    for (var i = 0; i < root_ids.length; i++) {
        roots.push(this.nodes[root_ids[i]]);
    }
    this._roots = roots;
};

// set the list of roots back to the "natural" list of nodes without
// parents
tree.prototype.clear_roots = function() {
    var roots = [];
    for (var id in this.nodes) {
        var node = this.nodes[id];
        if( ! node.has_parent() ) roots.push(node);
    }
    this._roots = roots;
};

// see node.traverse for description
tree.prototype.traverse = function(down_fun, down_data, up_aggregator) {
    var roots = this.roots();
    var results = [];
    for (var i = 0; i < roots.length; i++) {
        results.push(roots[i].traverse(down_fun, down_data, up_aggregator));
    }
    return results;
};

///
/// tree node
///

function node(id, label, meta) {
    this.id = id;
    this.label = label;
    this.meta = meta;
    this.parent = null;
    this.parent_distance = 0;
    this.children = [];
};

node.prototype.add_child = function(child_node, distance) {
    child_node.parent_distance = distance;
    child_node.parent = this;
    this.children.push(child_node);
};

node.prototype.is_leaf = function() {
    return 0 == this.children.length;
};

node.prototype.has_parent = function() {
    return null != this.parent;
};

node.prototype.sort_children = function(compare_fun) {
    for (var i = 0; i < this.children.length; i++) {
        this.children[i].sort_children(compare_fun);
    }
    this.children.sort(compare_fun);
};

// return true from the callback to stop iterating at a node
// (the iteration will continue with siblings but not with children of the
//  node where the callback returns true
node.prototype.iterate_preorder = function(fun) {
    if (! (true == fun(this))) {
        for (var i = 0; i < this.children.length; i++) {
            this.children[i].iterate_preorder(fun);
        }
    }
};

// traverse down and then up the tree, passing some data down
// at each step, and aggregating traversal results from the
// children on the way up
// down_fun: gets called on each node on the way down
//           arguments: node, down_data
// down_data: starting value for the data to pass down
//            (down_fun on a root gets this value for down_data)
// up_aggregator: function to aggregate results on the way back up
//                arguments: node, child_results, down_data
node.prototype.traverse = function(down_fun, down_data, up_aggregator) {
    down_data = down_fun(this, down_data);

    var child_results = new Array(this.children.length);;
    for (var i = 0; i < this.children.length; i++) {
        child_results[i] =
            this.children[i].traverse(down_fun, down_data, up_aggregator)
    }

    return up_aggregator(this, child_results, down_data);
};

///
/// Util functions
///

// takes an object like {"top": "10px", "left": "5px"}
// and return a string like "top: 10px; left: 5px;"
function css_string(css_object) {
    var result = "";
    if ("object" == typeof css_object) {
        for (var key in css_object) {
            result += key + ":" + css_object[key] + ";";
        }
    }
    return result;
}

function contains(arr, elem) {
    for (var i = 0; i < arr.length; i++) {
        if (elem == arr[i]) return true;
    }
    return false;
}

function max(list) {
    if (0 == list.length) return null;
    var result = list[0];
    for (var i = 1; i < list.length; i++) {
        if (list[i] > result) result = list[i];
    }
    return result;
}

function min(list) {
    if (0 == list.length) return null;
    var result = list[0];
    for (var i = 1; i < list.length; i++) {
        if (list[i] < result) result = list[i];
    }
    return result;
}

function sum(list) {
    var result = 0;
    for (var i = 0; i < list.length; i++) {
        result += list[i];
    }
    return result;
}

})();
if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.widget == "undefined" ){ bbop.widget = {}; }
if ( typeof bbop.widget.phylo == "undefined" ){ bbop.widget.phylo = {}; }

(function() {

bbop.widget.phylo.renderer = renderer;

function renderer(parent, golr_loc, golr_conf, config) {
    this.parent = parent;

    var default_config = {
        // these are in pixels
        // row vertical height, including padding and borders
        row_height: 18,
        // vertical space between the contents of adjacent rows
        row_spacing: 2,
        font: "Helvetica, Arial, sans-serif",
        mat_cell_width: 20,
        mat_cell_border: 1,
        transition_time: "0.8s",
        header_height: 100
    };

    this.config = ("object" == typeof config
                   ? bbop.core.merge(default_config, config)
                   : default_config);

    this.phylo_facet_list = [
        "panther_family_label",
        "phylo_graph_json",
        "score"
    ].join(",");
    this.ann_facet_list = [
        "id",
        "bioentity",
        "bioentity_label",
        "taxon_label",
        "bioentity_name",
        "annotation_class_list_map",
        "score"
    ].join(",");

    var golr = new bbop.golr.manager.jquery(golr_loc, golr_conf);
    golr.set_personality('bbop_bio');
    golr.add_query_filter('document_category', 'bioentity', ['*']);
    this.golr = golr;
}

renderer.prototype.show_family = function(family_id) {
    var self = this;
    var pgraph;

    function phyloCallback(response) {
        // make sure we don't show the phylo tree before the doc is ready
        jQuery(document).ready(function() {
            if (response.documents().length > 0) {
                var pgraph_json = response.documents()[0].phylo_graph_json;
                pgraph = (JSON.parse(pgraph_json));

                self.golr.register('search', 's', annCallback);
                self.golr.set_query("panther_family:" + family_id);
                self.golr.current_fl = self.ann_facet_list;
                self.golr.set("fl", self.ann_facet_list);
                self.golr.page(response.total_documents(), 0);
            } else {
                console.log("no documents received");
            }
        });
    }

    function annCallback(response) {
        if (response.documents().length > 0) {
            self.bioentity_map = 
                self.match_pnodes(pgraph.nodes, response.documents());
            self.show_pgraph(pgraph);
        } else {
            console.log("no documents received");
        }
    }
        
    this.golr.register('search', 's', phyloCallback);
    this.golr.set_query("panther_family:" + family_id);
    this.golr.current_fl = this.phylo_facet_list;
    this.golr.set("fl", this.phylo_facet_list);
    this.golr.page(1, 0);
};

renderer.prototype.match_pnodes = function(pnodes, bioentities) {
    var bioent_id_map = {};
    var bioents_by_pthr_id = {};
    var bioents_matched = 0;

    for (var b = 0; b < bioentities.length; b++) {
        bioent_id_map[bioentities[b].id] = bioentities[b];
    }

    for (var n = 0; n < pnodes.length; n++) {
        if ("annotations" in pnodes[n].meta) {
            var pgraph_bioent_ids = pnodes[n].meta.annotations.split("|");
            for (var pbi = 0; pbi < pgraph_bioent_ids.length; pbi++) {
                if (pgraph_bioent_ids[pbi] in bioent_id_map) {
                    bioents_by_pthr_id[pnodes[n].id] =
                        bioent_id_map[pgraph_bioent_ids[pbi]];
                    bioents_matched++;
                    //console.log("found bioentity for " + pnodes[n].id + " (" + pgraph_bioent_ids[pbi] + ")");

                }
            }
            if (! (pnodes[n].id in bioents_by_pthr_id)) {
                //console.log("no bioentity for " + pnodes[n].id + " (" + pgraph_bioent_ids.join(",") + ")");
            }
        } else {
            // this is typically the case for internal nodes
            //console.log("no non-panther IDs for " + pnodes[n].id);
        }
    }
    //console.log(pnodes.length + " phylo nodes");
    //console.log(bioentities.length + " bioentities");
    
    //console.log(bioents_matched + " matched");
    return bioents_by_pthr_id;
};

renderer.prototype.show_pgraph = function(pgraph) {
    var self = this;
    this.parent = ( ( "string" == typeof this.parent )
		    ? document.getElementById(this.parent)
		    : this.parent );

    jQuery(this.parent).empty();

    var parentPos = getStyle(this.parent, "position");
    if (! (("absolute" == parentPos) || ("relative" == parentPos))) {
        this.parent.style.position = "relative";
    }

    this.parent_top_border =
        parseInt(getStyle(this.parent, "border-top-width"));
    this.parent_bot_border =
        parseInt(getStyle(this.parent, "border-bottom-width"));

    this.tree_container = document.createElement("div");
    this.tree_container.style.position = "absolute";
    this.tree_container.style.top =
        (this.config.header_height + this.config.mat_cell_border) + "px";
    //this.tree_container.style.bottom = "100%";
    this.tree_container.style.left = "0px";
    
    this.mat_container = document.createElement("div");
    this.mat_container.style.cssText = "position: absolute; top: 0px; bottom: 100%;";

    var all_go_terms = {};
    var go_term_list = [];
    var node_go_annots = {};
    for (var nid in this.bioentity_map) {
        var bioent = this.bioentity_map[nid];
        var annots = JSON.parse(bioent.annotation_class_list_map);
        node_go_annots[nid] = annots;
        for (var goterm in annots) {
            var term_desc = all_go_terms[goterm];
            if (term_desc === undefined) {
                term_desc = {
                    count: 0,
                    id: goterm,
                    name: annots[goterm]
                };
                all_go_terms[goterm] = term_desc;
                go_term_list.push(term_desc);
            }
            term_desc.count += 1;
        }            
    }

    go_term_list.sort( function(a, b) { return b.count - a.count; } );
    //var coldescs = go_term_list.map( function(x) { return x.id; } );
    //console.log(coldescs);

    var mat_width = go_term_list.length * this.config.mat_cell_width;
    var tree_width = 500;
    this.tree_container.style.width = tree_width + "px";
    this.mat_container.style.width = mat_width + "px";
    this.mat_container.style.left = tree_width + "px";
    //this.parent.style.width = (tree_width + mat_width) + "px";

    this.parent.appendChild(this.tree_container);
    this.parent.appendChild(this.mat_container);
    var tree_renderer = new bbop.widget.phylo_tree.renderer(this.tree_container, {
        box_height: this.config.row_height,
        box_spacing: this.config.row_spacing,
        leaf_font: this.config.font,
        leaf_border: 0,
        leaf_padding: 3,
        node_size: 8,
        transition_time: this.config.transition_time
    });
    tree_renderer.leaf_style.background = "none";
    tree_renderer.leaf_style.cursor = "pointer";
    tree_renderer.node_style.cursor = "pointer";

    var nodes = pgraph.nodes;
    var edges = pgraph.edges;
    //console.log(nodes.length + " nodes");
    //console.log(edges.length + " edges");
    function node_label(node) {
        var bioe =
            node.id in self.bioentity_map ?
            self.bioentity_map[node.id] :
            null;

        var label = node.lbl;
        // abbreviate genus
        if (bioe) {
            var taxon_words = [];
            if (bioe.taxon_label) taxon_words = bioe.taxon_label.split(/\s+/);
            // sometimes there are more than two taxon words (strain name?)
            // but taxon_words[0] appears to be the genus name
            if (taxon_words.length >= 2) {
                taxon_words[0] = taxon_words[0].substr(0, 1) + ".";
            }
            label = taxon_words.join(" ") + ":" + bioe.bioentity_label;
        }
        return label
    }
        

    for (var i = 0; i < nodes.length; i++) {
        tree_renderer.add_node(nodes[i].id,
                               node_label(nodes[i]),
                               nodes[i].meta);
    }

    for (var i = 0; i < edges.length; i++) {
        tree_renderer.add_edge(edges[i].sub,
                               edges[i].obj,
                               parseFloat(edges[i].meta.distance));
    }
    
    tree_renderer.set_sort(function(a, b) {
        return parseInt(a.meta.layout_index) - parseInt(b.meta.layout_index);
    });

    tree_renderer.node_clicked = function(node, node_elem, event) {
        return self.node_clicked(node, node_elem, event);
    };

    var node_colors = {};
    var cur_color = 1;
    tree_renderer.traverse(
        function(node, down_data) {
            if (node.id in node_colors) {
                down_data = node_colors[node.id]
            }
            if ("true" == node.meta.duplication_p) {
                var have_grandchildren = false;
                var nearest_child_dist = Infinity;
                var nearest_child;
                for (var i = 0; i < node.children.length; i++) {
                    if (node.children[i].parent_distance < nearest_child_dist) {
                        nearest_child = node.children[i];
                        nearest_child_dist = nearest_child.parent_distance;
                    }
                    have_grandchildren =
                        have_grandchildren
                        || (! node.children[i].is_leaf() );
                }
                if (have_grandchildren) {
                    // under duplication nodes, we give new colors to
                    // all children other than the nearest
                    for (var i = 0; i < node.children.length; i++) {
                        if (node.children[i] === nearest_child) {
                            node_colors[node.children[i].id] = down_data;
                        } else {
                            node_colors[node.children[i].id] = cur_color++;
                        }
                    }
                }
            }
            if (! (node.id in node_colors)) {
                node_colors[node.id] = down_data;
            }
            return node_colors[node.id];
        },
        0,
        function() {}
    );
    this.node_colors = node_colors;

    this.tree_renderer = tree_renderer;
    this.render_tree();

    // dismiss popovers by clicking outside them
    jQuery(this.tree_container).on("click", function (e) {
        if (self.popover_elem === undefined) return;
        self.popover_elem.popover("destroy");
        self.popover_elem = undefined;
    });

    var node_id_list = tree_renderer.leaves().map(function(x) { return x.id });
    var node_id_map = {};
    for (var i = 0; i < nodes.length; i++) {
        node_id_map[nodes[i].id] = nodes[i];
    }

    function cell_renderer(cell, row, col) {
        var node_go = node_go_annots[row];
        if ((node_go !== undefined) && (col in node_go)) {
            var cell = document.createElement("div");
            cell.style.backgroundColor = "#555";
            cell.title =
                node_label(node_id_map[row]) + " - " + all_go_terms[col].name;
            return cell;
        }
        return null;
    }
    
    var mat_config = {
        cell_width: this.config.mat_cell_width,
        cell_border: this.config.mat_cell_border,
        cell_height: this.config.row_height + 2,
        header_height: this.config.header_height,
        show_headers: true,
        transition_time: this.config.transition_time
    };
    this.mat_renderer =
        new bbop.widget.matrix.renderer(this.mat_container, node_id_list,
                                        go_term_list, cell_renderer,
                                        mat_config);


    var leaf_id_list = tree_renderer.leaves().map(
        function(x) { return x.id }
    );
    this.mat_renderer.show_rows(leaf_id_list);
    this.parent.style.transition =
        "height " + this.config.transition_time + " ease-in-out";
    this.update_heights();
    
};

renderer.prototype.toggle_subtree_shown = function(node_id) {
    if (this.tree_renderer.subtree_hidden(node_id)) {
        this.tree_renderer.show_subtree(node_id);
    } else {
        this.tree_renderer.hide_subtree(node_id);
    }
    this.show_mat_rows_for_tree_leaves();
};

renderer.prototype.show_global_root = function(node_id) {
    this.tree_renderer.show_global_root();
    this.show_mat_rows_for_tree_leaves();
};

renderer.prototype.show_only_subtree = function(node_id) {
    this.tree_renderer.show_only_subtree(node_id);
    this.show_mat_rows_for_tree_leaves();
};

renderer.prototype.show_mat_rows_for_tree_leaves = function() {
    var leaf_id_list = jQuery.map( this.tree_renderer.leaves(),
                                   function(x) { return x.id; } );
    this.mat_renderer.show_rows(leaf_id_list);
    this.update_heights();
};

renderer.prototype.update_heights = function() {
    this.parent.style.height =
        ( this.tree_renderer.tree_height
          + this.config.header_height
          + this.config.mat_cell_border
          + this.parent_top_border
          + this.parent_bot_border ) + "px";
};

renderer.prototype.node_clicked = function(node, node_elem, event) {
    var buttons = [];
    var jqElem = jQuery(node_elem);
    var self = this;

    // if there's an existing popover,
    if (this.popover_elem !== undefined) {
        // destroy it
        this.popover_elem.popover("destroy");
        // if this click is on the same node that the popover was on,
        // then return
        if (this.popover_elem[0] === jqElem[0]) {
            this.popover_elem = undefined;
            return;
        }
        // otherwise this.popover_elem becomes the new popover element
        // (below)
    }
    this.popover_elem = jqElem;
    jQuery.Event(event).stopPropagation();

    var podata = jqElem.data("bs.popover");

    jqElem.popover({
        html: true,
        placement: "auto top",
        container: "body",
        title: node.label
    });
    var podata = jqElem.data("bs.popover");

    if (! node.is_leaf()) {
        podata.tip().append("&nbsp;");

        var hideButton = jQuery("<button type='button' class='btn btn-primary btn-xs'></button>");
        hideButton.click(function() {
            jqElem.popover("destroy");
            self.popover_elem = undefined;
            self.toggle_subtree_shown(node.id);
        });

        hideButton.text( self.tree_renderer.subtree_hidden(node.id)
                         ? "Show subtree" : "Hide subtree" );
        podata.tip().append(hideButton);
    }

    podata.tip().append("&nbsp;");
    var rootButton = jQuery("<button type='button' class='btn btn-primary btn-xs'></button>");
    rootButton.click(function() {
        jqElem.popover("destroy");
        self.popover_elem = undefined;
        if (self.tree_renderer.only_subtree_shown(node.id)) {
            self.show_global_root();
        } else {
            self.show_only_subtree(node.id);
        }
    });
    rootButton.text( self.tree_renderer.only_subtree_shown(node.id)
                     ? "Show global root" : "Show only subtree" );
    podata.tip().append(rootButton);
    podata.tip().append("&nbsp;");

    jqElem.popover("show");
};

renderer.prototype.render_tree = function() {
    this.tree_renderer.display();

    this.tree_renderer.iterate_preorder(
        function(id, label, meta, dom_elem, children) {
            if ("true" == meta.speciation_p) {
                dom_elem.style.borderRadius = "6px";
            } else if ("true" == meta.duplication_p) {
                var has_children = children.length > 0;
                if (has_children) {
                    dom_elem.style.backgroundColor = "black";
                }
            }
        }
    );

    var color_list = [
        "white",
        "rgb(238, 232, 170)",
        "rgb(255, 182, 193)",
        "rgb(135, 206, 250)",
        "rgb(240, 128, 128)",
        "rgb(152, 251, 152)",
        "rgb(216, 191, 216)",
        "rgb(240, 230, 140)",
        "rgb(224, 255, 255)",
        "rgb(255, 218, 185)",
        "rgb(211, 211, 211)",
        "rgb(255, 250, 205)",
        "rgb(176, 196, 222)",
        "rgb(255, 228, 173)",
        "rgb(175, 238, 238)",
        "rgb(244, 164, 96)",
        "rgb(127, 255, 212)",
        "rgb(245, 222, 179)",
        "rgb(255, 160, 122)",
        "rgb(221, 160, 221)"
    ];
    var self = this;
    this.tree_renderer.iterate_preorder(
        function(id, label, meta, dom_elem, children) {
            var is_leaf = 0 == children.length;
            if (is_leaf) {
                dom_elem.style.backgroundColor =
                    color_list[self.node_colors[id] % color_list.length];
                if (id in self.bioentity_map) {
                    dom_elem.style.color = "black";
                } else {
                    dom_elem.style.color = "#aaa";
                }
            }
        }
    );
};

function getStyle(el, styleProp) {
    if (el.currentStyle) {
        var y = el.currentStyle[styleProp];
    } else if (window.getComputedStyle) {
        var y = window.getComputedStyle(el,null).getPropertyValue(styleProp);
    }
    return y;
}

})();
if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.widget == "undefined" ){ bbop.widget = {}; }
if ( typeof bbop.widget.matrix == "undefined" ){ bbop.widget.matrix = {}; }

(function() {

bbop.widget.matrix.renderer = renderer;

// if there are multiple instances of this widget on the page, this will
// make sure that their CSS rules don't step on each other
var this_id = 0;

function renderer(parent, row_descriptors, col_descriptors,
                  cell_renderer, config) {
    var default_config = {
        // cell_width: null means to set the width based on cell contents;
        // otherwise cell_width is a fixed width per cell in pixels
        cell_width: null,
        cell_height: 24,
	cell_border: 1,
        cell_padding: 4,
        cell_font: "Helvetica, Arial, sans-serif",

        header_height: 30,
        header_font: "Helvetica, Arial, sans-serif",
        show_headers: true,
        transition_time: "0.8s"
    };

    if( "object" == typeof config ){
        this.config = bbop.core.merge(default_config, config);
    }else{
        this.config = default_config;
    }

    this.parent = ( ( "string" == typeof parent )
		    ? document.getElementById(parent)
		    : parent );
    if (this.parent === undefined) {
        throw "can't find parent element " + parent;
    }

    // css width/height don't include padding or border, but
    // offsetWidth/offsetHeight do
    this.offset_size_delta = ( ( this.config.cell_padding * 2 )
                               + ( this.config.cell_border ) );
    // setting font size from cell height.  We'd like to set font cap height
    // directly, but we can only set em box size.  Cap height on average is
    // 70% of em box size, so we'll set the font size to the intended
    // height divided by 0.7
    var cell_font_size = ( ( this.config.cell_height
                             - this.offset_size_delta )
                           / 0.7 );
    var header_font_size;
    if (null == this.config.cell_width) {
        header_font_size = ( ( this.config.header_height
                               - this.offset_size_delta )
                             / 0.7 );
    } else {
        header_font_size = ( ( this.config.cell_width
                               - this.offset_size_delta )
                             / 0.7 );
    }

    var css_prefix = "matrix_" + this_id++;
    var header_class = css_prefix + "_header";
    var inner_header_class = css_prefix + "_inner";
    var cell_class = css_prefix + "_cell";
    this.fixed_width = (null != this.config.cell_width);

    this.row_descriptors = row_descriptors;
    this.col_descriptors = col_descriptors;

    this.headers = [];
    this.matrix = [];
    this.num_cols = col_descriptors.length;
    this.num_rows = row_descriptors.length;
    //rowdesc_map: row descriptor -> matrix row index
    this.rowdesc_map = {};
    //coldesc_map: col descriptor -> matrix col index
    this.coldesc_map = {};
    //rowindex_map: displayed row index -> matrix row index
    this.rowindex_map = Array(row_descriptors.length);
    //colindex_map: displayed col index -> matrix col index
    this.colindex_map = Array(col_descriptors.length);
    this.grid_vert = [];
    this.grid_horiz = [];

    var vert_class = css_prefix + "_vert";
    //create vertical grid lines
    for (var i = 0; i < col_descriptors.length; i++) {
        var gridline = document.createElement("div");
        gridline.className = vert_class;
        gridline.style.top = "0px";
        this.parent.appendChild(gridline);
        this.grid_vert.push(gridline);
    }
    this.first_vert_gridline = document.createElement("div");
    this.first_vert_gridline.className = vert_class;
    this.first_vert_gridline.style.cssText = [
        "top: 0px;", "width: 0px;", "left: 0px;",
        "margin-left: 0px;", "margin-right: 0px;",
        "padding-left: 0px;", "padding-right: 0px;"
    ].join("\n");
    this.parent.appendChild(this.first_vert_gridline);

    var horiz_class = css_prefix + "_horiz";
    //create horizontal grid lines
    for (var i = 0; i < row_descriptors.length; i++) {
        var gridline = document.createElement("div");
        gridline.className = horiz_class;
        gridline.style.left = "0px";
        gridline.style.top = ( (this.config.show_headers ?
                                this.config.header_height : 0)
                               + (i * this.config.cell_height) ) + "px";
        this.parent.appendChild(gridline);
        this.grid_horiz.push(gridline);
    }
    this.first_horiz_gridline = document.createElement("div");
    this.first_horiz_gridline.className = horiz_class;
    this.first_horiz_gridline.style.cssText = [
        "top: 0px;", "height: 0px;", "left: 0px;",
        "margin-top: 0px;", "margin-bottom: 0px;",
        "padding-top: 0px;", "padding-bottom: 0px;"
    ].join("\n");
    this.parent.appendChild(this.first_horiz_gridline);
    if (this.config.show_headers) {
        this.header_gridline = document.createElement("div");
        this.header_gridline.className = horiz_class;
        this.header_gridline.style.cssText = [
            "top: " + ( this.config.header_height 
                        - this.config.cell_border ) + "px;",
            "height: 0px;", "left: 0px;",
            //"margin-bottom: 0px;",
            "padding-top: 0px;", "padding-bottom: 0px;"
        ].join("\n");
        this.parent.appendChild(this.header_gridline);
    }

    for (var i = 0; i < col_descriptors.length; i++) {
        if (this.config.show_headers) {
            //create the header cells
            var cell = document.createElement("div");
            cell.className = header_class;
            cell.style.top = "0px";
            if (null == this.config.cell_width) {
                cell.title = col_descriptors[i].name;
                cell.appendChild(document.createTextNode(col_descriptors[i].name));
            } else {
                // create inner rotated element
                var inner = document.createElement("div");
                inner.className = inner_header_class;
                inner.title = col_descriptors[i].name;
                inner.appendChild(document.createTextNode(col_descriptors[i].name));
                cell.appendChild(inner);
            }
            this.parent.appendChild(cell);
            this.headers.push(cell);
        }
        this.colindex_map[i] = i;
        this.coldesc_map[col_descriptors[i].id] = i;
    }

    for( var ri = 0; ri < row_descriptors.length; ri++ ){
        var row = [];

        for (var ci = 0; ci < col_descriptors.length; ci++) {
            var cell = cell_renderer(cell, row_descriptors[ri],
                                     col_descriptors[ci].id);
            if (null != cell) {
                cell.className += " " + cell_class;
                cell.style.top = ( (this.config.show_headers ?
                                    this.config.header_height : 0)
                                   + (ri * this.config.cell_height) ) + "px";
                this.parent.appendChild(cell);
            }
            row.push(cell);
        }

        this.matrix.push(row);
        this.rowindex_map[ri] = ri;
        this.rowdesc_map[row_descriptors[ri]] = ri;
    }

    this.vert_style = [
        "  position: absolute;",
        "  border-right: " + this.config.cell_border + "px solid black;",
        "  padding: " + this.config.cell_padding + "px;",
        "  margin-left: " + this.config.cell_border + "px;",
        "  overflow: hidden;",
        "  z-index: 0;",
        "  box-sizing: content-box;",
        "  -moz-box-sizing: content-box;"
    ].join("\n");

    this.horiz_style = [
        "  position: absolute;",
        "  border-bottom: " + this.config.cell_border + "px solid black;",
        "  padding: " + this.config.cell_padding + "px;",
        "  height: " + (this.config.cell_height
                        - this.offset_size_delta) + "px;",
        "  margin: 0px;",
        "  margin-top: " + this.config.cell_border + "px;",
        "  z-index: 1;",
        "  overflow: hidden;",
        "  box-sizing: content-box;",
        "  -moz-box-sizing: content-box;"
    ].join("\n");

    this.cell_style = [
        "  position: absolute;",
        "  white-space: nowrap;",
        "  height: " + (this.config.cell_height
                        - this.offset_size_delta) + "px;",
        "  margin: " + this.config.cell_border + "px;",
        "  padding: " + this.config.cell_padding + "px;",
        //"  margin: 0px;",
        "  z-index: 10;",
        "  font: " + cell_font_size + "px" + " " + this.config.cell_font + ";",
        "  line-height: 0.7em;",
        "  overflow: hidden;",
        "  box-sizing: content-box;",
        "  -moz-box-sizing: content-box;"
    ].join("\n");

    this.header_style = [
        "  position: absolute;",
        "  white-space: nowrap;",
        "  height: " + (this.config.header_height
                        - this.offset_size_delta) + "px;",
        //"  border: " + this.config.cell_border + "px solid black;",
        "  margin: " + this.config.cell_border + "px;",
        "  padding: " + this.config.cell_padding + "px;",
        "  font: " + header_font_size + "px" + " "
            + this.config.header_font + ";",
        "  line-height: 0.7em;",
        "  overflow: hidden;",
        "  box-sizing: content-box;",
        "  -moz-box-sizing: content-box;"
    ].join("\n");

    var inner_offset = -(this.config.header_height
                         - header_font_size
                         - this.config.cell_padding);
    this.inner_header_style = [
        "-webkit-transform: rotate(-90deg) translate(" + inner_offset + "px);",
        "transform: rotate(-90deg) translate(" + inner_offset + "px);",
        "-ms-transform: rotate(-90deg) translate(" + inner_offset + "px);",
        "-o-transform: rotate(-90deg) translate(" + inner_offset + "px);",
        "filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=3);"
    ].join("\n");

    this.transition_style = [
        "  transition-property: top, left;",
        "  transition-duration:" +  this.config.transition_time + ";",
        "  transition-timing-function: ease-in-out, ease-in-out;"
    ].join("\n");

    //"table." + table_class + " tr:hover td { background-color: #bef195; }"

    this.set_styles([
        "div." + header_class + " { ",
        this.header_style,
        "}",
        "div." + inner_header_class + " { ",
        this.inner_header_style,
        "}",
        "div." + cell_class + " { ",
        this.cell_style,
        "}",
        "div." + vert_class + " { ",
        this.vert_style,
        "}",
        "div." + horiz_class + " { ",
        this.horiz_style,
        "}"
    ].join("\n"));

    this.update_height();
    this.width = this.update_widths();// + this.offset_size_delta;
    this.parent.style.width = this.width + this.config.cell_border + "px";

    this.set_styles([
        "div." + header_class + " { ",
        this.header_style,
        this.transition_style,
        "}",
        "div." + inner_header_class + " { ",
        this.inner_header_style,
        this.transition_style,
        "}",
        "div." + cell_class + " { ",
        this.cell_style,
        this.transition_style,
        "}",
        "div." + vert_class + " { ",
        this.vert_style,
        this.transition_style,
        "}",
        "div." + horiz_class + " { ",
        this.horiz_style,
        this.transition_style,
        "}"
    ].join("\n"));
}

renderer.prototype.update_height = function() {
    this.height = ( (this.config.show_headers ? this.config.header_height : 0)
                    + (this.config.cell_height * this.rowindex_map.length) );
    var grid_height = ( this.height - this.offset_size_delta
                        + (2 * this.config.cell_border) ) + "px";
    for (var ci = 0; ci < this.colindex_map.length; ci++) {
        this.grid_vert[this.colindex_map[ci]].style.height = grid_height;
    }
    this.first_vert_gridline.style.height = grid_height;
    this.parent.style.height = (this.height + this.config.cell_border) + "px";
};

renderer.prototype.set_styles = function(css_string) {
    if( ! this._style_node ){
        head = document.getElementsByTagName('head')[0],
        this._style_node = document.createElement('style');
        this._style_node.type = 'text/css';
        head.appendChild(this._style_node);
    }

    if (this._style_node.styleSheet){
        this._style_node.styleSheet.cssText = css_string; // IE
    } else {
        while (this._style_node.firstChild) {
            this._style_node.removeChild(this._style_node.firstChild);
        }
        this._style_node.appendChild(document.createTextNode(css_string));
    }
};

renderer.prototype.update_widths = function() {
    function max_widths(matrix) {
        // matrix is row-major
        var widths = [];
        for (var row = 0; row < matrix.length; row++) {
            for (var col = 0; col < matrix[row].length; col++) {
                var cell = matrix[row][col];
                if (cell) {
                    cell.style.width = "";
                    if (! (col in widths)) widths[col] = 0;
                    widths[col] = Math.max(widths[col], cell.offsetWidth);
                }
            }
        }
        return widths;
    }

    function set_widths(row, colindex_map, widths, offset_delta) {
        var left = 0;
        for (var col = 0; col < colindex_map.length; col++) {
            var cell = row[colindex_map[col]];
            if (cell) {
                cell.style.width =
                    (widths[colindex_map[col]] - offset_delta) + "px";
                cell.style.left = left + "px";
            }
            left += widths[col];
        }
    }

    var widths = Array(this.num_cols);
    var totalWidth = 0;
    if (this.fixed_width) {
        for (var col = 0; col < this.num_cols; col++) {
            widths[col] = this.config.cell_width;
            totalWidth += widths[col];
        }
    } else {
        var header_widths = max_widths([this.headers]);
        var matrix_widths = max_widths(this.matrix);
        for (var col = 0; col < this.num_cols; col++) {
            // || 0 here in case the matrix and headers don't have the
            // same number of columns
            widths[col] = Math.max(header_widths[col] || 0,
                                   matrix_widths[col] || 0);
            totalWidth += widths[col];
        }
    }

    if (this.config.show_headers) {
        set_widths(this.headers, this.colindex_map, widths,
                   this.offset_size_delta);
    }
    for (var ri = 0; ri < this.matrix.length; ri++) {
        set_widths(this.matrix[ri], this.colindex_map, widths,
                   this.offset_size_delta);
    }
    set_widths(this.grid_vert, this.colindex_map, widths,
               this.offset_size_delta);

    var grid_width = ( totalWidth - this.offset_size_delta
                       + (2 * this.config.cell_border) ) + "px";
    for (var ri = 0; ri < this.grid_horiz.length; ri++) {
        this.grid_horiz[ri].style.width = grid_width;
    }
    this.first_horiz_gridline.style.width = grid_width;
    if (this.config.show_headers) {
        this.header_gridline.style.width = grid_width;
    }
        
    this.widths = widths;
    return totalWidth;
};

renderer.prototype.show_rows = function(row_list) {
    var new_rowindex_map = Array(row_list.length);
    var new_row_map = {};

    var displayed_colindices = Array(this.num_cols);
    for (var dci = 0; dci < this.colindex_map.length; dci++) {
        displayed_colindices[this.colindex_map[dci]] = dci;
    }

    // set new row y-positions
    for( var ri = 0; ri < row_list.length; ri++ ){
        if (row_list[ri] in this.rowdesc_map) {
            var matrix_row_index = this.rowdesc_map[row_list[ri]];
            var row = this.matrix[matrix_row_index];
            var row_top = ( (this.config.show_headers ?
                             this.config.header_height : 0)
                            + (ri * this.config.cell_height) ) + "px";

            var horiz_gridline = this.grid_horiz[matrix_row_index];
            horiz_gridline.style.top = row_top;
            horiz_gridline.style.display = "";

            for (var ci = 0; ci < this.num_cols; ci++) {
                var cell = row[ci];
                if (cell) {
                    cell.style.top = row_top;
                    var displayed_colindex = displayed_colindices[ci];
                    if (displayed_colindex == undefined) {
                        cell.style.display = "none";
                    } else {
                        cell.style.display = "";
                    }
                }
            }

            new_rowindex_map[ri] = matrix_row_index;
            new_row_map[row_list[ri]] = 1;
        }
    }

    this.rowindex_map = new_rowindex_map;

    // hide non-shown rows
    for(var i = 0; i < this.row_descriptors.length; i++) {
        var rowdesc = this.row_descriptors[i];
        if (! (rowdesc in new_row_map)) {
            var row_index = this.rowdesc_map[rowdesc];

            this.grid_horiz[row_index].style.display = "none";

            var row = this.matrix[row_index];
            for (var j = 0; j < row.length; j++) {
                var cell = row[j];
                if (cell) cell.style.display = "none";
            }
        }
    }
    this.update_height();
};

renderer.prototype.show_cols = function(col_list) {
    var new_colindex_map = Array(col_list.length);
    var new_col_map = {};

    var displayed_rowindices = Array(this.num_rows);
    for (var dri = 0; dri < this.rowindex_map.length; dri++) {
        displayed_rowindices[this.rowindex_map[dri]] = dri;
    }

    // set new col x-positions
    var left = 0;
    for( var ci = 0; ci < col_list.length; ci++ ){
        matrix_col_index = this.coldesc_map[col_list[ci]];

        var vert_gridline = this.grid_vert[matrix_col_index];
        vert_gridline.style.left = left + "px";
        vert_gridline.style.display = "";
        for (var ri = 0; ri < this.num_rows; ri++) {
            var row = this.matrix[ri];
            var cell = row[matrix_col_index];
            if (cell) {
                cell.style.left = left + "px";

                var displayed_rowindex = displayed_rowindices[ri];
                if (displayed_rowindex == undefined) {
                    cell.style.display = "none";
                } else {
                    cell.style.display = "";
                }
            }
        }
        if (this.config.show_headers) {
            this.headers[matrix_col_index].style.left = left + "px";
            this.headers[matrix_col_index].style.display = "";
        }

        new_colindex_map[ci] = matrix_col_index;
        new_col_map[col_list[ci]] = 1;
        left += this.widths[matrix_col_index];
    }

    this.colindex_map = new_colindex_map;

    // hide non-shown cols
    for(var i = 0; i < this.col_descriptors.length; i++) {
        var coldesc = this.col_descriptors[i];
        if (! (coldesc.id in new_col_map)) {
            matrix_col_index = this.coldesc_map[coldesc.id];
            for (var j = 0; j < this.matrix.length; j++) {
                var cell = this.matrix[j][matrix_col_index];
                if (cell) cell.style.display = "none";
            }
            this.grid_vert[matrix_col_index].style.display = "none";
            if (this.config.show_headers) {
                this.headers[matrix_col_index].style.display = "none";
            }
        }
    }

    this.width = left;
    var grid_width = ( left - this.offset_size_delta
                       + (2 * this.config.cell_border) ) + "px";
    for (var ri = 0; ri < this.rowindex_map.length; ri++) {
        this.grid_horiz[this.rowindex_map[ri]].style.width = grid_width;
    }
    this.first_horiz_gridline.style.width = grid_width;
    if (this.config.show_headers) {
        this.header_gridline.style.width = grid_width;
    }
    this.parent.style.width = this.width + this.config.cell_border + "px";
};

})();
/*
 * Package: message.js
 * 
 * Namespace: bbop.widget.message
 * 
 * TODO: Code needs to be cleaned with <bbop.html>.
 * 
 * BBOP object to produce a self-constructing/self-destructing
 * sliding message/announcments/warnings.
 * 
 * Note that this is a steal of some older code. We'll probably have
 * to clean this up a bit at some point.
 * 
 * These messages make use of the classes "bbop-js-message" and
 * "bbop-js-message-CTYPE", where CTYPE is one of "error",
 * "warning", or "notice".
 * 
 * Initial placement and the likes should be manipulated through
 * "bbop-js-message"--the created divs are append to the end of
 * the body and will not be particularly useful unless styled.
 * 
 * This is a completely self-contained UI.
 */

if ( typeof bbop == "undefined" ){ var bbop = {}; }
if ( typeof bbop.widget == "undefined" ){ bbop.widget = {}; }

/*
 * Constructor: message
 * 
 * Contructor for the bbop.widget.message object.
 *
 * A trivial invocation might be something like:
 * : var m = new bbop.widget.message();
 * : m.notice("Hello, World!");
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  self
 */
bbop.widget.message = function(){
    
    this._is_a = 'bbop.widget.message';

    var anchor = this;

    // Per-UI logger.
    var logger = new bbop.logger();
    logger.DEBUG = true;
    function ll(str){ logger.kvetch('W (message): ' + str); }

    // Generate tags.
    function _generate_element(ctype, str){

	var message_classes = ['bbop-js-message',
			       'bbop-js-message-' + ctype];

	var message_elt =
	    new bbop.html.tag('div',
			      {'generate_id': true,
			       'class': message_classes.join(' ')},
			      '<h2>' + str + '</h2>');

    	jQuery("body").append(jQuery(message_elt.to_string()).hide());

	// jQuery-ify the element.
    	var elt = jQuery('#' + message_elt.get_id());
    	return elt;
    }

    // Destroy tags.
    function _destroy_element(){
    	jQuery(this).remove();
    }

    ///
    /// Notice and error handling.
    ///
    // elt.show().fadeIn('slow').fadeOut('slow', _destroy_element);

    /*
     * Function: notice
     * 
     * Temporarily display a messsage styled for notices.
     * 
     * Parameters:
     *  msg - the message
     * 
     * Returns
     *  n/a
     */
    this.notice = function(msg){
    	var elt = _generate_element('notice', msg);
    	elt.show().slideDown('slow').slideUp('slow', _destroy_element);
    };

    /*
     * Function: warning
     * 
     * Temporarily display a messsage styled for warnings.
     * 
     * Parameters:
     *  msg - the message
     * 
     * Returns
     *  n/a
     */
    this.warning = function(msg){
    	var elt = _generate_element('warning', msg);
    	elt.show().slideDown('slow').slideUp('slow', _destroy_element);
    };

    /*
     * Function: error
     * 
     * Temporarily display a messsage styled for errors.
     * 
     * Parameters:
     *  msg - the message
     * 
     * Returns
     *  n/a
     */
    this.error = function(msg){
    	var elt = _generate_element('error', msg);
    	elt.show().fadeTo(2500, 0.9).fadeOut(1000, _destroy_element);
    };

};

// If it looks like we're in an environment that supports CommonJS
// Modules 1.0, take the bbop namespace whole and export it. Otherwise
// (browser environment, etc.), take no action and depend on the
// global namespace.
if( typeof(exports) != 'undefined' ){

    // Old style--exporting separate namespace.
    exports.bbop = bbop;

    // New, better, style--assemble; these should not collide.
    bbop.core.each(bbop, function(k, v){
	exports[k] = v;
    });
}


},{"http":7,"ringo/httpclient":undefined,"url":31}],"bbopx":[function(require,module,exports){
// If it looks like we're in an environment that supports CommonJS
// Modules 1.0, bbop-js might not be extant in this namespace. Try and
// get at it. Otherwise, if we're in browser-land, it should be
// included in the global and we can proceed.
if( typeof(exports) != 'undefined' ){
    var bbop = require('bbop').bbop;
}
////
//// The idea here is to have a generic class expression class that
//// can be used at all levels of communication an display (instead of
//// the previous major/minor models).
////

if ( typeof bbopx == "undefined" ){ var bbopx = {}; }
if ( typeof bbopx.minerva == "undefined" ){ bbopx.minerva = {}; }

/**
 * Class expressions.
 * 
 * This is a full-bodied implementation of all the different aspects
 * that we need to capture for type class expressions: information
 * capture from JSON, on-the-fly creations, and display
 * properties. These used to be separate behaviors, but with the
 * client taking over more responsibility from Minerva, a more robust
 * and testable soluton was needed.
 * 
 * Types can be: class ids and the expressions: SVF, union, and
 * intersection. Of the latter group, all are nestable.
 * 
 * Categories is a graphical/UI distinction. They can be: instance_of,
 * <relation id>, union, and intersection.
 * 
 * This model also incorporates whether or not the type is
 * inferred. At this level they are treated the same, but a higher
 * level may (must) treat them as display decorations.
 *
 * The argument "in_type" may be:
 *  - a class id (string)
 *  - a JSON blob as described from Minerva
 *  - another <bbopx.minerva.class_expression>
 *  - null (user will load or interactively create one)
 *
 * Parameters:
 *  in_type - the raw type description (see above)
 *  inferred_p - *[optional]* whether or not the type is inferred (default false)
 */
bbopx.minerva.class_expression = function(in_type, inferred_p){
    this._is_a = 'bbopx.minerva.class_expression';

    // Aliases.
    var anchor = this;
    var each = bbop.core.each;
    var what_is = bbop.core.what_is;

    ///
    /// Initialize.
    ///

    // in_type is always a JSON object, trivial catch of attempt to
    // use just a string as a class identifier.
    if( in_type ){
    	if( what_is(in_type) == 'bbopx.minerva.class_expression' ){
    	    // Unfold and re-parse (takes some properties of new
    	    // host).
    	    in_type = in_type.structure();
    	}else if( what_is(in_type) == 'object' ){
	    // Fine as it is.
    	}else if( what_is(in_type) == 'string' ){
	    // Convert to a safe representation.
	    in_type = {
		'type': 'class',
		'id': in_type,
		'label': in_type
	    };
    	}
    }

    // Inferred type defaults to false.
    this._inferred_p = false;
    if( typeof(inferred_p) !== 'undefined' && inferred_p == true ){
	this._inferred_p = true;
    }

    // Every single one is a precious snowflake (which is necessary
    // for managing some of the aspects of the UI for some use cases).
    this._id = bbop.core.uuid();

    // Derived property defaults.
    this._type = null;
    this._category = 'unknown';
    this._class_id = null;
    this._class_label = null;
    this._property_id = null;
    this._property_label = null;
    // Recursive elements.
    this._frame = [];

    // 
    this._raw_type = in_type;
    if( in_type ){
	anchor.parse(in_type);
    }
};

/**
 * Function: id
 * 
 * Parameters: 
 *  n/a
 *
 * Returns:
 *  string
 */
bbopx.minerva.class_expression.prototype.id = function(){
    return this._id;
};

/**
 * Function: inferred_p
 * 
 * Parameters: 
 *  n/a
 *
 * Returns:
 *  true or false
 */
bbopx.minerva.class_expression.prototype.inferred_p = function(){
    return this._inferred_p;
};

/** 
 * Function: nested_p
 *
 * If the type has a recursive frame.
 *
 * Parameters: 
 *  n/a
 *
 * Returns:
 *  true or false
 */
bbopx.minerva.class_expression.prototype.nested_p = function(){
    var retval = false;
    if( this._frame.length > 0 ){
	retval = true;
    }
    return retval;
};

/**
 * Function: signature
 * 
 * A cheap way of identifying if two class_expressions are the same.
 * This essentially returns a string of the main attributes of a type.
 * It is meant to be semi-unique and collide with dupe inferences.
 *
 * BUG/WARNING: At this point, colliding signatures should mean a
 * dupe, but non-colliding signamtes does *not* guarantee that they
 * are not dupes (think different intersection orderings).
 *
 * Parameters: 
 *  n/a
 *
 * Returns:
 *  string
 */
bbopx.minerva.class_expression.prototype.signature = function(){
    var anchor = this;
    var each = bbop.core.each;

    var sig = [];

    // The easy ones.
    sig.push(anchor.category() || '');
    sig.push(anchor.type() || '');
    sig.push(anchor.class_id() || '');
    sig.push(anchor.property_id() || '');

    // And now recursively on frames.
    if( anchor.frame() ){
	each(anchor.frame(), function(f){
	    sig.push(f.signature() || '');
	});
    }

    return sig.join('_');
};

/** 
 * Function: category
 *
 * Try to put an instance type into some kind of rendering
 * category.
 *
 * Parameters: 
 *  n/a
 *
 * Returns:
 *  string (default 'unknown')
 */
bbopx.minerva.class_expression.prototype.category = function(){
    return this._category;
};

/** 
 * Function: type
 *
 * The "type" of the type.
 *
 * Parameters: 
 *  n/a
 *
 * Returns:
 *  string or null
 */
bbopx.minerva.class_expression.prototype.type = function(){
    return this._type;
};

/** 
 * Function: svf_class_expression
 *
 * The class expression when we are dealing with SVF.
 *
 * Parameters: 
 *  n/a
 *
 * Returns:
 *  type or null
 */
bbopx.minerva.class_expression.prototype.svf_class_expression = function(){
    var ret = null
    if( this.type() == 'svf' ){
	ret = this._frame[0];
    }    
    return ret; 
};

/** 
 * Function: frame
 *
 * If the type has a recursive frame, a list of the types it contains.
 *
 * Parameters: 
 *  n/a
 *
 * Returns:
 *  list of <bbopx.minerva.class_expression>
 */
bbopx.minerva.class_expression.prototype.frame = function(){
    return this._frame;
};

/** 
 * Function: class_id
 *
 * The considered class id.
 *
 * Parameters: 
 *  n/a
 *
 * Returns:
 *  string or null
 */
bbopx.minerva.class_expression.prototype.class_id = function(){
    return this._class_id;
};

/** 
 * Function: class_label
 *
 * The considered class label, defaults to ID if not found.
 *
 * Parameters: 
 *  n/a
 *
 * Returns:
 *  string or null
 */
bbopx.minerva.class_expression.prototype.class_label = function(){
    return this._class_label;
};

/** 
 * Function: property_id
 *
 * The considered class property id.
 * Not defined for 'class' types.
 *
 * Parameters: 
 *  n/a
 *
 * Returns:
 *  string or null
 */
bbopx.minerva.class_expression.prototype.property_id = function(){
    return this._property_id;
};

/** 
 * Function: property_label
 *
 * The considered class property label.
 * Not defined for 'class' types.
 *
 * Parameters: 
 *  n/a
 *
 * Returns:
 *  string or null
 */
bbopx.minerva.class_expression.prototype.property_label = function(){
    return this._property_label;
};

/**
 * Function: parse
 * 
 * Parse a JSON blob into the current instance, clobbering anything in
 * there, except id.
 *
 * Parameters: 
 *  in_type - conformant JSON object
 *
 * Returns:
 *  self
 */
bbopx.minerva.class_expression.prototype.parse = function(in_type){

    var anchor = this;
    var each = bbop.core.each;

    // Helper.
    function _decide_type(type){
	var rettype = null;

	// Easiest case.
	var t = type['type'] || null;
	if( t == 'class' ){
	    rettype = 'class';
	}else if( t == 'union' ){
	    rettype = 'union';
	}else if( t == 'intersection' ){
	    rettype = 'intersection';
	}else if( t == 'svf' ){
	    rettype = 'svf';
	}else{
	    // No idea...
	}

	return rettype;
    }

    // Define the category, and build up an instant picture of what we
    // need to know about the property.
    var t = _decide_type(in_type);
    if( t == 'class' ){

	// Easiest to extract.
	this._type = t;
	this._category = 'instance_of';
	this._class_id = in_type['id'];
	this._class_label = in_type['label'] || this._class_id;
	// No related properties.
	
    }else if( t == 'union' || t == 'intersection' ){ // conjunctions

	// These are simply recursive.
	this._type = t;
	this._category = t;

	// Load stuff into the frame.
	this._frame = [];
	var f_set = in_type['expressions'] || [];
	each(f_set, function(f_type){
	    anchor._frame.push(new bbopx.minerva.class_expression(f_type));
	}); 
    }else if( t == 'svf' ){ // SVF
	    
	// We're then dealing with an SVF: a property plus a class
	// expression. We are expecting a "restriction", although we
	// don't really do anything with that information (maybe
	// later).
	this._type = t;
	// Extract the property information
	this._category = in_type['property']['id'];
	this._property_id = in_type['property']['id'];
	this._property_label =
	    in_type['property']['label'] || this._property_id;	    

	// Okay, let's recur down the class expression. It should just
	// be one, but we'll just reuse the frame. Access should be
	// though svf_class_expression().
	var f_type = in_type['filler'];
	this._frame = [new bbopx.minerva.class_expression(f_type)];
    }else{
	// Should not be possible, so let's stop it here.
	//console.log('unknown type :', in_type);
	throw new Error('unknown type leaked in');
    }

    return anchor;
};

/**
 * Function: as_class
 * 
 * Parse a JSON blob into the current instance, clobbering anything in
 * there, except id.
 *
 * Parameters: 
 *  in_type - string
 *
 * Returns:
 *  self
 */
bbopx.minerva.class_expression.prototype.as_class = function(in_type){

    if( in_type ){
	var ce = new bbopx.minerva.class_expression(in_type);
	this.parse(ce.structure());
    }

    return this;
};

/**
 * Function: as_svf
 * 
 * Convert a null class_expression into an arbitrary SVF.
 *
 * Parameters:
 *  class_expr - ID string (e.g. GO:0022008) or <bbopx.minerva.class_expression>
 *  property_id - string
 *
 * Returns:
 *  self
 */
bbopx.minerva.class_expression.prototype.as_svf = function(
    class_expr, property_id){

    // Cheap our way into this--can be almost anything.
    var cxpr = new bbopx.minerva.class_expression(class_expr);

    // Our list of values must be defined if we go this way.
    var expression = {
	'type': 'svf',
	'property': {
	    'type': "property",
	    'id': property_id
	},
	'filler': cxpr.structure()
    };

    this.parse(expression);

    return this;
};

/**
 * Function: as_set
 * 
 * Convert a null class_expression into a set of class expressions.
 *
 * Parameters:
 *  set_type - 'intersection' || 'union'
 *  set_list - list of ID strings of <bbopx.minerva.class_expressions>
 *
 * Returns:
 *  self
 */
bbopx.minerva.class_expression.prototype.as_set = function(
    set_type, set_list){

    // We do allow empties.
    if( ! set_list ){ set_list = []; }

    if( set_type == 'union' || set_type == 'intersection' ){

	// Work into a viable argument.
	var set = [];
	bbop.core.each(set_list, function(item){
	    var cexpr = new bbopx.minerva.class_expression(item);
	    set.push(cexpr.structure());
	}); 

	// A little massaging is necessary to get it into the correct
	// format here.
	var fset = set_type;
	var parsable = {};
	parsable['type'] = fset;
	parsable['expressions'] = set;
	this.parse(parsable);
    }

    return this;
};

/** 
 * Function: structure
 *
 * Hm. Essentially dump out the information contained within into a
 * JSON object that is appropriate for consumption my Minerva
 * requests.
 *
 * Parameters: 
 *  n/a
 *
 * Returns:
 *  JSON object
 */
bbopx.minerva.class_expression.prototype.structure = function(){

    // Aliases.
    var anchor = this;
    var each = bbop.core.each;

    // We'll return this.
    var expression = {};
    
    // Extract type.
    var t = anchor.type(); 
    if( t == 'class' ){ // trivial

	expression['type'] = 'class';
	expression['id'] = anchor.class_id();

    }else if( t == 'svf' ){ // SVF
	
	// Easy part of SVF.
	expression['type'] = 'svf';
	expression['property'] = {
	    'type': 'property',
	    'id': anchor.property_id()
	};
	
	// Recur for someValuesFrom class expression.
	var svfce = anchor.svf_class_expression();
	var st = svfce.type();
	expression['filler'] = svfce.structure();
	
    }else if( t == 'union' || t == 'intersection' ){ // compositions
	
	// Recursively add all of the types in the frame.
	var ecache = [];
	var frame = anchor.frame();
	each(frame, function(ftype){
	    ecache.push(ftype.structure());
	});

	// Correct structure.
	expression['type'] = t;
	expression['expressions'] = ecache;
	
    }else{
	throw new Error('unknown type in request processing: ' + t);
    }
    
    return expression;
};


bbopx.minerva.class_expression.intersection = function(list){
    var ce = new bbopx.minerva.class_expression();
    ce.as_set('intersection', list);
    return ce;
};

bbopx.minerva.class_expression.union = function(list){
    var ce = new bbopx.minerva.class_expression();
    ce.as_set('union', list);
    return ce;
};

bbopx.minerva.class_expression.svf = function(cls_expr, prop_id){
    var ce = new bbopx.minerva.class_expression();
    ce.as_svf(cls_expr, prop_id);
    return ce;
};

bbopx.minerva.class_expression.cls = function(id){
    var ce = new bbopx.minerva.class_expression();
    ce.as_class(id);
    return ce;
};
/* 
 * Package: manager.js
 *
 * Namespace: bbopx.minerva.manager
 *
 * jQuery manager for communication with Minerva (via Barista).
 *
 * See also:
 *  <bbopx.barista.response>
 */

if ( typeof bbopx == "undefined" ){ var bbopx = {}; }
if ( typeof bbopx.minerva == "undefined" ){ bbopx.minerva = {}; }

/*
 * Constructor: manager
 * 
 * A manager for handling the AJAX and registry.
 * Initial take from bbop.golr.manager.
 * 
 * Arguments:
 *  barista_location - string for invariant part of API
 *  namespace - string for namespace of API to use
 *  app_blob - JSON object that defines targets
 *  user_token - identifying string for the user of the manager (Barista token)
 *  engine - *[optional]* AJAX manager client to use (default: jquery)
 *  use_jsonp - *[optional]* wrap requests in JSONP (only usable w/jquery, default: true)
 * 
 * Returns:
 *  a classic manager
 */
bbopx.minerva.manager = function(barista_location, namespace, user_token, 
				 engine, use_jsonp){
    bbop.registry.call(this, ['prerun', // internal; anchor only
			      'postrun', // internal
			      'manager_error', // internal/external...odd
			      //'success', // uninformative
			      'merge',
			      'rebuild',
			      'meta',
			      'warning', // trump
			      'error' //trump
			     ]);
    this._is_a = 'bbopx.minerva.manager';
    var anchor = this;

    // Aliases.
    var each = bbop.core.each;
    var is_empty = bbop.core.is_empty;

    //var url = barista_location + '/api/' + namespace + '/m3Batch';
    anchor._url = null;
    // 
    anchor._user_token = user_token;

    // Will use this one other spot, where the user can change the
    // token.
    function _set_url_from_token(in_token){	
	var url = null;
	if( in_token ){
	    url = barista_location + '/api/' + namespace + '/m3BatchPrivileged';
	}else{
	    url = barista_location + '/api/' + namespace + '/m3Batch';
	}
	anchor._url = url;
	return url;
    }
    _set_url_from_token(user_token);

    // // Helper function to add get_undo_redo when the user token
    // // (hopefully good) is defined.
    // function _add_undo_redo_req(req_set, model_id){
    // 	if( anchor._user_token ){
    // 	    var req = new bbopx.minerva.request('model', 'get-undo-redo');
    // 	    req.model(model_id);
    // 	    req_set.add(req);
    // 	}
    // }

    // Select an internal manager for handling the unhappiness of AJAX
    // callbacks.
    var jqm = null;
    if( ! engine ){ engine = 'jquery'; } // default to jquery
    if( engine.toLowerCase() == 'jquery' ){
	jqm = new bbop.rest.manager.jquery(bbopx.barista.response);
    }else if( engine.toLowerCase() == 'node' ){
	jqm = new bbop.rest.manager.node(bbopx.barista.response);
    }else{
	// Default to jQuery.
	engine = 'jquery';
	jqm = new bbop.rest.manager.jquery(bbopx.barista.response);
    }

    // Should JSONP be used for these calls, only for jQuery.
    if( engine.toLowerCase() == 'jquery' ){
	var jsonp_p = true;
	if( typeof(use_jsonp) !== 'undefined' && ! use_jsonp ){
	    jsonp_p = false;
	}
	jqm.use_jsonp(true); // we are definitely doing this remotely
    }

    // How to deal with failure.
    function _on_fail(resp, man){
	// See if we got any traction.
	if( ! resp || ! resp.message_type() || ! resp.message() ){
	    // Something dark has happened, try to put something
	    // together.
	    // console.log('bad resp!?: ', resp);
	    var resp_seed = {
		'message_type': 'error',
		'message': 'deep manager error'
	    };
	    resp = new bbopx.barista.response(resp_seed);
	}
	anchor.apply_callbacks('manager_error', [resp, anchor]);
    }
    jqm.register('error', 'foo', _on_fail);

    // When we have nominal success, we still need to do some kind of
    // dispatch to the proper functionality.
    function _on_nominal_success(resp, man){
	
	// Switch on message type when there isn't a complete failure.
	var m = resp.message_type();
	if( m == 'error' ){
	    // Errors trump everything.
	    anchor.apply_callbacks('error', [resp, anchor]);
	}else if( m == 'warning' ){
	    // Don't really have anything for warning yet...remove?
	    anchor.apply_callbacks('warning', [resp, anchor]);
	}else if( m == 'success' ){
	    var sig = resp.signal();
	    if( sig == 'merge' || sig == 'rebuild' || sig == 'meta' ){
		//console.log('run on signal: ' + sig);
		anchor.apply_callbacks(sig, [resp, anchor]);		
	    }else{
		alert('unknown signal: very bad');
	    }
	}else{
	    alert('unimplemented message_type');	    
	}

	// Postrun goes no matter what.
	anchor.apply_callbacks('postrun', [resp, anchor]);
    }
    jqm.register('success', 'bar', _on_nominal_success);

    ///
    /// Control our identity.
    ///

    /*
     * Method: user_id
     * 
     * DEPRECATED: use user_token()
     * 
     * Arguments:
     *  user_id - string
     * 
     * Returns:
     *  user token
     */
    anchor.user_id = function(user_token){
	return anchor.user_token(user_token);
    };

    /*
     * Method: user_token
     * 
     * Get/set the user token.
     * 
     * Arguments:
     *  user_token - string
     * 
     * Returns:
     *  current user token
     */
    anchor.user_token = function(user_token){

	// Adjust the internal token.
	if( user_token ){
	    anchor._user_token = user_token;
	}

	// Make sure we're using the right URL considering how we're
	// identified.
	_set_url_from_token(anchor._user_token);

	return anchor._user_token;
    };

    ///
    /// Actual mechanism.
    ///

    /*
     * Method: get_model
     * 
     * Trigger a rebuild <bbopx.barista.response> with a model.
     * 
     * Intent: "query".
     * Expect: "success" and "rebuild".
     * 
     * Arguments:
     *  model_id - string
     * 
     * Returns:
     *  n/a
     */
    anchor.get_model = function(model_id){

	var reqs = new bbopx.minerva.request_set(anchor.user_token(), model_id);
	reqs.get_model();

 	anchor.request_with(reqs);
    };
    
    // /*
    //  * Method: get_model_ids
    //  * 
    //  * Trigger meta <bbopx.barista.response> with a list of all model
    //  * ids.
    //  * 
    //  * Intent: "query".
    //  * Expect: "success" and "meta".
    //  * 
    //  * Arguments:
    //  *  n/a
    //  * 
    //  * Returns:
    //  *  n/a
    //  */
    // anchor.get_model_ids = function(){

    // 	// 
    // 	var reqs = new bbopx.minerva.request_set(anchor.user_token());
    // 	var req = new bbopx.minerva.request('model', 'all-model-ids');
    // 	reqs.add(req);

    // 	var args = reqs.callable();	
    // 	anchor.apply_callbacks('prerun', [anchor]);
    // 	jqm.action(anchor._url, args, 'GET');
    // };
    
    /*
     * Method: get_meta
     * 
     * Trigger meta <bbopx.barista.response> with a list of all model
     * meta-information.
     * 
     * Intent: "query".
     * Expect: "success" and "meta".
     * 
     * Arguments:
     *  n/a
     * 
     * Returns:
     *  n/a
     */
    anchor.get_meta = function(){

	var reqs = new bbopx.minerva.request_set(anchor.user_token());
	reqs.get_meta();

 	anchor.request_with(reqs);
    };

    /*
     * Method: get_model_undo_redo
     * 
     * Trigger meta <bbopx.barista.response> of requested model's
     * undo/redo information.
     * 
     * This will make the request whether or not the user has an okay
     * token defined (as opposed to the helper function
     * _add_undo_redo()).
     *
     * Intent: "query".
     * Expect: "success" and "meta".
     * 
     * Arguments:
     *  model_id - string
     * 
     * Returns:
     *  n/a
     */
    anchor.get_model_undo_redo = function(model_id){

	// 
	var reqs = new bbopx.minerva.request_set(anchor.user_token(), model_id);
	reqs.get_undo_redo();

 	anchor.request_with(reqs);
    };
    
    /*
     * Method: perform_undo
     * 
     * Trigger rebuild <bbopx.barista.response> after an attempt to
     * roll back the model to "last" state.
     *
     * Intent: "action".
     * Expect: "success" and "rebuild".
     * 
     * Arguments:
     *  model_id - string
     * 
     * Returns:
     *  n/a
     */
    anchor.perform_undo = function(model_id){

	var reqs = new bbopx.minerva.request_set(anchor.user_token(), model_id);
	reqs.undo_last_model_batch();

 	anchor.request_with(reqs);
    };
    
    /*
     * Method: perform_redo
     * 
     * Trigger rebuild <bbopx.barista.response> after an attempt to
     * roll forward the model to "next" state.
     *
     * Intent: "action".
     * Expect: "success" and "rebuild".
     * 
     * Arguments:
     *  model_id - string
     * 
     * Returns:
     *  n/a
     */
    anchor.perform_redo = function(model_id){

	var reqs = new bbopx.minerva.request_set(anchor.user_token(), model_id);
	reqs.redo_last_model_batch();

 	anchor.request_with(reqs);
    };
    
    /*
     * Method: add_fact
     * 
     * Trigger merge (or possibly a rebuild) <bbopx.barista.response>
     * on attempt to add a single fact to a model.
     *
     * Intent: "action".
     * Expect: "success" and "merge".
     * 
     * Arguments:
     *  model_id - string
     *  source_id - string
     *  target_id - string
     *  rel_id - string
     * 
     * Returns:
     *  n/a
     */
    anchor.add_fact = function(model_id, source_id, target_id, rel_id){

	var reqs = new bbopx.minerva.request_set(anchor.user_token(), model_id);
	reqs.add_fact([source_id, target_id, rel_id]);

 	anchor.request_with(reqs);
    };
    
    /*
     * Method: remove_fact
     * 
     * Trigger merge (or possibly a rebuild) <bbopx.barista.response>
     * on attempt to remove a single fact to a model.
     *
     * Intent: "action".
     * Expect: "success" and "merge".
     * 
     * Arguments:
     *  model_id - string
     *  source_id - string
     *  target_id - string
     *  rel_id - string
     * 
     * Returns:
     *  n/a
     */
    anchor.remove_fact = function(model_id, source_id, target_id, rel_id){

	var reqs = new bbopx.minerva.request_set(anchor.user_token(), model_id);
	reqs.remove_fact([source_id, target_id, rel_id]);

 	anchor.request_with(reqs);
    };
    
    /*
     * Method: add_simple_composite
     * 
     * Trigger merge (or possibly a rebuild) <bbopx.barista.response>
     * on attempt to add a simple composite unit (class, enabled_by,
     * and occurs_in) to a model.
     *
     * Intent: "action".
     * Expect: "success" and "merge".
     * 
     * Arguments:
     *  model_id - string
     *  cls_exp - anything taken by <bbopx.minerva.class_expression>
     *  enabled_by_expr - *[optional]* anything taken by <bbopx.minerva.class_expression>
     *  occurs_in_expr - *[optional]* anything taken by <bbopx.minerva.class_expression>
     * 
     * Returns:
     *  n/a
     */
    anchor.add_simple_composite = function(model_id, cls_expr,
    					   enabled_by_expr, occurs_in_expr){

	// Minimal requirements.
	var reqs = new bbopx.minerva.request_set(anchor.user_token(), model_id);
     	var ind = reqs.add_individual(cls_expr);

	// Optional set expressions.
	if( enabled_by_expr ){
	    reqs.add_type_to_individual(
		bbopx.minerva.class_expression.svf(enabled_by_expr,
						   'RO:0002333'),
	    ind);
	}
	if( occurs_in_expr ){
	    reqs.add_type_to_individual(
		bbopx.minerva.class_expression.svf(occurs_in_expr,
						   'occurs_in'),
	    ind);
	}

 	anchor.request_with(reqs);
    };
    
    // /*
    //  * Method: add_class
    //  * 
    //  * Trigger merge (or possibly a rebuild) <bbopx.barista.response>
    //  * on attempt to add just a class (instance of a class) to an
    //  * individual in a model.
    //  *
    //  * Intent: "action".
    //  * Expect: "success" and "merge".
    //  * 
    //  * Arguments:
    //  *  model_id - string
    //  *  individual_id - string
    //  *  class_id - string
    //  * 
    //  * Returns:
    //  *  n/a
    //  */
    // anchor.add_class = function(model_id, individual_id, class_id){

    // 	// 
    // 	var reqs = new bbopx.minerva.request_set(anchor.user_token());
    // 	var req = new bbopx.minerva.request('individual', 'add-type');
    // 	req.model(model_id);
    // 	req.individual(individual_id);
    // 	req.add_class_expression(class_id);

    // 	reqs.add(req);

    // 		anchor.request_with(reqs);
    // };
    
    // /*
    //  * Method: add_svf
    //  * 
    //  * Trigger merge (or possibly a rebuild) <bbopx.barista.response>
    //  * on attempt to add an SVF expression to an individual in a
    //  * model.
    //  *
    //  * Intent: "action".
    //  * Expect: "success" and "merge".
    //  * 
    //  * Arguments:
    //  *  model_id - string
    //  *  individual_id - string
    //  *  class_id - string
    //  *  property_id - string
    //  * 
    //  * Returns:
    //  *  n/a
    //  */
    // anchor.add_svf = function(model_id, individual_id, class_id, property_id){

    // 	var reqs = new bbopx.minerva.request_set(anchor.user_token(), model_id);
    // 	reqs.add_svf_expression(type, individual_id);

    // 	// 
    // 	var reqs = new bbopx.minerva.request_set(anchor.user_token());
    // 	var req = new bbopx.minerva.request('individual', 'add-type');
    // 	req.model(model_id);
    // 	req.individual(individual_id);
    // 	req.add_svf_expression(class_id, property_id);

    // 	reqs.add(req);

    // 		anchor.request_with(reqs);
    // };
    
    // /*
    //  * Method: remove_class
    //  * 
    //  * Trigger merge (or possibly a rebuild) <bbopx.barista.response>
    //  * on attempt to remove a class from an individual in a model.
    //  *
    //  * Intent: "action".
    //  * Expect: "success" and "merge".
    //  * 
    //  * Arguments:
    //  *  model_id - string
    //  *  individual_id - string
    //  *  class_id - string
    //  * 
    //  * Returns:
    //  *  n/a
    //  */
    // anchor.remove_class = function(model_id, individual_id, class_id){

    // 	// 
    // 	var reqs = new bbopx.minerva.request_set(anchor.user_token());
    // 	var req = new bbopx.minerva.request('individual', 'remove-type');
    // 	req.model(model_id);
    // 	req.individual(individual_id);
    // 	req.add_class_expression(class_id);

    // 	reqs.add(req);

    // 		anchor.request_with(reqs);
    // };
    
    /*
     * Method: add_class_expression
     * 
     * Trigger merge (or possibly a rebuild) <bbopx.barista.response>
     * on attempt to add a complex class expression to an individual
     * in a model.
     *
     * Intent: "action".
     * Expect: "success" and "merge".
     * 
     * Arguments:
     *  model_id - string
     *  individual_id - string
     *  cls_expr - anything acceptible to <bbopx.minerva.class_expression>
     * 
     * Returns:
     *  n/a
     */
    anchor.add_class_expression = function(model_id, individual_id, cls_expr){

	var reqs = new bbopx.minerva.request_set(anchor.user_token(), model_id);
	reqs.add_type_to_individual(cls_expr, individual_id);

	anchor.request_with(reqs);
    };
    
    /*
     * Method: remove_class_expression
     * 
     * Trigger merge (or possibly a rebuild) <bbopx.barista.response>
     * on attempt to remove a complex class expression from an
     * individual in a model.
     *
     * Intent: "action".
     * Expect: "success" and "merge".
     * 
     * Arguments:
     *  model_id - string
     *  individual_id - string
     *  cls_expr - anything acceptible to <bbopx.minerva.class_expression>
     * 
     * Returns:
     *  n/a
     */
    anchor.remove_class_expression = function(model_id, individual_id, cls_expr){

	var reqs = new bbopx.minerva.request_set(anchor.user_token(), model_id);
	reqs.remove_type_from_individual(cls_expr, individual_id);

	anchor.request_with(reqs);
    };
    
    /*
     * Method: remove_individual
     * 
     * Trigger a rebuild <bbopx.barista.response> on attempt to remove
     * an individual from a model.
     *
     * Intent: "action".
     * Expect: "success" and "rebuild".
     * 
     * Arguments:
     *  model_id - string
     *  individual_id - string
     * 
     * Returns:
     *  n/a
     */
    anchor.remove_individual = function(model_id, indv_id){

	var reqs = new bbopx.minerva.request_set(anchor.user_token(), model_id);
	reqs.remove_individual(indv_id);

	anchor.request_with(reqs);
    };
    
    /*
     * Method: add_model
     * 
     * Trigger a rebuild response <bbopx.barista.response> on
     * attempting to create a new model...from nothing. Or something!
     *
     * Intent: "action".
     * Expect: "success" and "rebuild".
     * 
     * Arguments:
     *  taxon_id - *[DEPRECATED]* *[optional]* string (full ncbi)
     *  class_id - *[DEPRECATED]* *[optional]* string
     * 
     * Returns:
     *  n/a
     */
    anchor.add_model = function(taxon_id, class_id){

	// Conditions taken care of by request_set.
	var reqs = new bbopx.minerva.request_set(anchor.user_token());
	reqs.add_model({'class-id': class_id, 'taxon_id': taxon_id});
	
	anchor.request_with(reqs);
    };
    
    /*
     * Method: export_model
     * 
     * *[DEPRECATED]*
     * 
     * Trigger a meta <bbopx.barista.response> containing model export
     * text.
     *
     * Intent: "action".
     * Expect: "success" and "meta".
     * 
     * Arguments:
     *  model_id - string
     *  format - *[optional]* string (for legacy, "gaf" or "gpad")
     * 
     * Returns:
     *  n/a
     */
    anchor.export_model = function(model_id, format){

	if( typeof(format) === 'undefined' ){ format = 'default'; }

	var reqs = new bbopx.minerva.request_set(anchor.user_token());
	var req = null;
	if( format == 'gaf' ){
	    req = new bbopx.minerva.request('model', 'export-legacy');
	    req.special('format', 'gaf');
	}else if( format == 'gpad' ){
	    req = new bbopx.minerva.request('model', 'export-legacy');
	    req.special('format', 'gpad');
	}else{
	    // Default (non-legacy) case is simpler.
	    req = new bbopx.minerva.request('model', 'export');
	}

	// Add the model to the request.
	req.model(model_id);
	reqs.add(req);

	anchor.request_with(reqs);
    };
    
    /*
     * Method: import_model
     * 
     * *[DEPRECATED]*
     * 
     * Trigger a rebuild response <bbopx.barista.response> for a new
     * model seeded/created from the argument string.
     *
     * Intent: "action".
     * Expect: "success" and "rebuild".
     * 
     * Arguments:
     *  model_string - string representation of a model
     * 
     * Returns:
     *  n/a
     */
    anchor.import_model = function(model_string){

	// 
	var reqs = new bbopx.minerva.request_set(anchor.user_token());
	var req = new bbopx.minerva.request('model', 'import');
	req.special('importModel', model_string);
	reqs.add(req);

	anchor.request_with(reqs);
    };
    
    /*
     * Method: store_model
     * 
     * Trigger a rebuild response <bbopx.barista.response> on a
     * "permanent" store operation on a model.
     *
     * What?! A "rebuild" and not "meta"? Yes. This allows a workflow
     * where a model is created, edited, and stored all in one pass.
     *
     * Intent: "action".
     * Expect: "success" and "rebuild".
     * 
     * Arguments:
     *  model_id - string
     * 
     * Returns:
     *  n/a
     */
    anchor.store_model = function(model_id){

	var reqs = new bbopx.minerva.request_set(anchor.user_token(), model_id);
	reqs.store_model();

	anchor.request_with(reqs);
    };
    
    /*
     * Method: add_individual_annotation
     * 
     * Trigger a rebuild response <bbopx.barista.response> on an
     * annotation addition to an individual in a model.
     *
     * Intent: "action".
     * Expect: "success" and "rebuild".
     * 
     * Arguments:
     *  model_id - string
     *  indv_id - string
     *  key - string
     *  value - string
     * 
     * Returns:
     *  n/a
     */
    anchor.add_individual_annotation = function(model_id, indv_id, key, value){

	var reqs = new bbopx.minerva.request_set(anchor.user_token(), model_id);
	reqs.add_annotation_to_individual(key, value, indv_id);

	anchor.request_with(reqs);
    };
    
    /*
     * Method: add_fact_annotation
     * 
     * Trigger a rebuild response <bbopx.barista.response> on an
     * annotation addition to a referenced fact (edge) in a model.
     *
     * Intent: "action".
     * Expect: "success" and "rebuild".
     * 
     * Arguments:
     *  model_id - string
     *  source_id - string
     *  target_id - string
     *  rel_id - string
     *  key - string
     *  value - string
     * 
     * Returns:
     *  n/a
     */
    anchor.add_fact_annotation = function(model_id,
					  source_id, target_id, rel_id,
					  key, value){

	var reqs = new bbopx.minerva.request_set(anchor.user_token(), model_id);
	reqs.add_annotation_to_fact(key, value, [source_id, target_id, rel_id]);

	anchor.request_with(reqs);
    };
    
    /*
     * Method: add_model_annotation
     * 
     * Trigger a rebuild response <bbopx.barista.response> on an
     * annotation addition to a model.
     *
     * Intent: "action".
     * Expect: "success" and "rebuild".
     * 
     * Arguments:
     *  model_id - string
     *  key - string
     *  value - string
     * 
     * Returns:
     *  n/a
     */
    anchor.add_model_annotation = function(model_id, key, value){

	var reqs = new bbopx.minerva.request_set(anchor.user_token(), model_id);
	reqs.add_annotation_to_model(key, value);

	anchor.request_with(reqs);
    };
    
    /*
     * Method: remove_individual_annotation
     * 
     * Trigger a rebuild response <bbopx.barista.response> on an
     * annotation removeal from an individual in a model.
     *
     * Intent: "action".
     * Expect: "success" and "rebuild".
     * 
     * Arguments:
     *  model_id - string
     *  indv_id - string
     *  key - string
     *  value - string
     * 
     * Returns:
     *  n/a
     */
    anchor.remove_individual_annotation =function(model_id, indv_id, key, value){

	var reqs = new bbopx.minerva.request_set(anchor.user_token(), model_id);
	reqs.remove_annotation_from_individual(key, value, indv_id);

	anchor.request_with(reqs);
    };
    
    /*
     * Method: remove_fact_annotation
     * 
     * Trigger a rebuild response <bbopx.barista.response> on an
     * annotation removeal from a referenced fact (edge) in a model.
     *
     * Intent: "action".
     * Expect: "success" and "rebuild".
     * 
     * Arguments:
     *  model_id - string
     *  source_id - string
     *  target_id - string
     *  rel_id - string
     *  key - string
     *  value - string
     * 
     * Returns:
     *  n/a
     */
    anchor.remove_fact_annotation = function(model_id,
					     source_id, target_id, rel_id,
					     key, value){

	var reqs = new bbopx.minerva.request_set(anchor.user_token(), model_id);
	reqs.remove_annotation_from_fact(key, value,
					 [source_id, target_id, rel_id]);

	anchor.request_with(reqs);
    };
    
    /*
     * Method: remove_model_annotation
     * 
     * Trigger a rebuild response <bbopx.barista.response> on an
     * annotation removal from a model.
     *
     * Intent: "action".
     * Expect: "success" and "rebuild".
     * 
     * Arguments:
     *  model_id - string
     *  key - string
     *  value - string
     * 
     * Returns:
     *  n/a
     */
    anchor.remove_model_annotation =function(model_id, key, value){

	var reqs = new bbopx.minerva.request_set(anchor.user_token(), model_id);
	reqs.remove_annotation_from_model(key, value);

	anchor.request_with(reqs);
    };
    
    /*
     * Method: capella_bootstrap_model
     * 
     * DEPRECATED: This is currently very very old code and is mostly
     * here as a bookmark on where to restart.
     * 
     * Trigger a rebuild response <bbopx.barista.response> on
     * attempting to create a new model with information provided by
     * Capella.
     *
     * If you're attempting to use this, you probably want to revisit
     * everything and everbody first...
     *
     * Intent: "action".
     * Expect: "success" and "rebuild".
     * 
     * Arguments:
     *  bootstrap_obj - JSON object ???
     *  term2aspect - ???
     * 
     * Returns:
     *  n/a
     */
    anchor.capella_bootstrap_model = function(bootstrap_obj, term2aspect){

	var reqs = new bbopx.minerva.request_set(anchor.user_token());

	// Just get a new model going.
	var req = new bbopx.minerva.request('model', 'generate-blank');
	//req.special('db', db_id); // unecessary
	reqs.add(req);

	each(bootstrap_obj, function(ob){

	    // Now, for each of these, we are going to be adding
	    // stuff to MF instances. If there is no MF coming
	    // in, we are just going to use GO:0003674.
	    var mfs = [];
	    var bps = [];
	    var ccs = [];
	    each(ob['terms'], function(tid){
		if( term2aspect[tid] == 'molecular_function' ){
		    mfs.push(tid);
		}else if( term2aspect[tid] == 'biological_process' ){
		    bps.push(tid);
		}else if( term2aspect[tid] == 'cellular_component' ){
		    ccs.push(tid);
		}
	    });
	    // There must be this no matter what.
	    if( is_empty(mfs) ){
 		mfs.push('GO:0003674');
	    }

	    // We are going to be creating instances off of the
	    // MFs.
	    each(mfs, function(mf){
		var req = new bbopx.minerva.request('individual', 'add');
			  
		// Add in the occurs_in from CC.
		each(ccs, function(cc){
		    req.add_svf_expression(cc, 'occurs_in');
		});

		// Add in the enabled_by from entities.
		each(ob['entities'], function(ent){
		    req.add_svf_expression(ent, 'RO:0002333');
		});
	    });
	});


	// Final send-off.
	anchor.request_with(reqs);
    };
    
    /*
     * Method: request_with
     * 
     * Make a custom request with your own request set.
     *
     * Intent: ??? - whatever you set
     * Expect: "success" and ??? (depends on your request)
     * 
     * Arguments:
     *  request_set - <bbopx.noctua.request_set>
     *  model_id - *[TODO?]* string
     * 
     * Returns:
     *  n/a
     */
    anchor.request_with = function(request_set, model_id){
	// Run.
	var args = request_set.callable();	
    	anchor.apply_callbacks('prerun', [anchor]);
    	jqm.action(anchor._url, args, 'GET');
    };    
    
};
bbop.core.extend(bbopx.minerva.manager, bbop.registry);
/* 
 * Package: requests.js
 */

if ( typeof bbopx == "undefined" ){ var bbopx = {}; }
if ( typeof bbopx.minerva == "undefined" ){ bbopx.minerva = {}; }

/*
 * Namespace: bbopx.minerva.request_variable
 * 
 * Internal usage variable for keeping track of implicit
 * assignToVariable on the client (see Minerva).
 * 
 * NOTE: This might eventually find its way into bbop-js.
 */

/*
 * Constructor: request_variable
 * 
 * Contructor for a request variable, used to relate references during
 * a request.
 * 
 * Arguments:
 *  varvalue - *[optional]* string representing a future variable value
 * 
 * Returns:
 *  request variable object
 */
bbopx.minerva.request_variable = function(varvalue){
    var anchor = this;
    anchor._is_a = 'bbopx.minerva.request_variable';

    var uuid = bbop.core.uuid;

    anchor._var = uuid(); // primo
    anchor._use_var_p = false;

    function _value(value){
	if( value ){
	    anchor._var = value;
	    anchor._use_var_p = true;
	}
	return anchor._var;
    }
    // Do an initial revalue depending on the constructor's incoming
    // arguments.
    _value(varvalue);

    /*
     * Function: value
     *
     * The value of the variable to be used.
     *
     * Parameters: 
     *  n/a 
     *
     * Returns: 
     *  string
     */
    anchor.value = _value;

    /*
     * Function: set_p
     *
     * Returns true or false on whether or not the user changed the
     * value of the setting.
     *
     * Parameters: 
     *  n/a
     *
     * Returns: 
     *  boolean
     */
    anchor.set_p = function(){
	return anchor._use_var_p;
    };
};

/*
 * Namespace: bbopx.minerva.request
 * 
 * Handle requests to Minerva in a somewhat structured way.
 * 
 * NOTE: This might eventually find its way into bbop-js.
 */

/*
 * Constructor: request
 * 
 * Contructor for a Minerva request item. See table for
 * operation/entity combinations:
 * https://github.com/berkeleybop/bbopx-js/wiki/MinervaRequestAPI .
 * 
 * Arguments:
 *  entity - string, see table
 *  operation - string, see table
 * 
 * Returns:
 *  request object
 */
bbopx.minerva.request = function(entity, operation){
    var anchor = this;
    anchor._is_a = 'bbopx.minerva.request';

    var each = bbop.core.each;
    var what_is = bbop.core.what_is;

    // Minerva entity to make a call against.
    anchor._entity = entity;

    // Minerva operation to perform on entity.
    anchor._operation = operation;

    // Almost all non-meta operations require a model id. However,
    // this is sometimes implied in the case of new model creation.
    anchor._model_id = null;

    // Tons of ops require individuals, and they need to be implicitly
    // passable.
    anchor._individual_id = new bbopx.minerva.request_variable();

    // Hold most other additional arguments to the request.
    // TODO: Could use some checking here? Maybe per-entity?
    // Could possibly explore using swagger or json-schema?
    anchor._arguments = {};

    ///
    /// Internal helper functions.
    ///

    // Our list of values must be defined if we go this way.
    anchor._ensure_list = function(key){
	if( ! anchor._arguments[key] ){
	    anchor._arguments[key] = [];
	}
    };

    // Add generic property (non-list).
    anchor._add = function(key, val){
	anchor._arguments[key] = val;
	return anchor._arguments[key];
    };

    // Get generic property (non-list).
    anchor._get = function(key){
	var ret = null;
	var t = anchor._arguments[key];
	if( t != null ){
	    ret = t;
	}
	return ret;
    };

    // Getter/setter (non-list).
    anchor._get_set = function(key, variable){
	if( variable ){
	    anchor._add(key, variable);
	}
	return anchor._get(key);
    };

    ///
    /// Public API.
    ///

    /*
     * Function: entity
     *
     * The specified entity string.
     *
     * Parameters:
     *  n/a
     *
     * Returns: 
     *  string or null
     */
    anchor.entity = function(){
	return anchor._entity;
    };

    /*
     * Function: special
     *
     * Add a "special" variable to the request. For a subset of
     * requests, this may be required. See table:
     * https://github.com/berkeleybop/bbopx-js/wiki/MinervaRequestAPI .
     *
     * Parameters: 
     *  name - string
     *  val - string
     *
     * Returns: 
     *  added value
     */
    anchor.special = function(name, val){
	return anchor._get_set(name, val);
    };

    /*
     * Function: objectify
     *
     * Should only be used in the context of making a request set.
     *
     * Return a higher-level representation/"serialization" of the
     * complete object.
     *
     * Parameters: 
     *  n/a
     *
     * Returns: 
     *  simple object
     */
    anchor.objectify = function(){

	// Things we will always return.
	var base = {
	    'entity': anchor._entity,
	    'operation': anchor._operation,
	    'arguments': anchor._arguments
	};

	// If we're using an implicitly set individual id, make sure
	// that is added to the call.
	if( anchor._entity == 'individual' && ! anchor._individual_id.set_p() ){
	    base['arguments']['assign-to-variable'] =
		anchor._individual_id.value();
	}

	return base;
    };

    /*
     * Function: individual
     *
     * Get/set the instance of this request. If not set explicitly,
     * will fall back to a default value.
     *
     * Parameters: 
     *  ind_id - *[optional]* individual id we're going to refer to
     *
     * Returns: 
     *  string
     */
    anchor.individual = function(ind_id){
	if( ind_id ){
	    anchor._individual_id.value(ind_id);
	    anchor._add('individual', ind_id);
	}else{
	    // Fallback to using anonymous one (no change to default).
	}
	//anchor._add('individual', anchor._individual_id.value());
	return anchor._individual_id.value();
    };

    /*
     * Function: subject
     *
     * Get/set the subject of this request.
     *
     * Parameters: 
     *  sub - *[optional]* string
     *
     * Returns: 
     *  string or null
     */
    anchor.subject = function(sub){
	return anchor._get_set('subject', sub);
    };

    /*
     * Function: object
     *
     * Get/set the object of this request. This will be used in
     * fact/edge requests, but not much else.
     *
     * Parameters: 
     *  obj - *[optional]* a string
     *
     * Returns: 
     *  string or null
     */
    anchor.object = function(obj){
	return anchor._get_set('object', obj);
    };

    /*
     * Function: predicate
     *
     * Get/set the predicate of this request. This will be used in
     * fact/edge requests, but not much else.
     *
     * Parameters: 
     *  pred - *[optional]* a string
     *
     * Returns: 
     *  string or null
     */
    anchor.predicate = function(pred){
	return anchor._get_set('predicate', pred);
    };

    /*
     * Function: model
     *
     * Get/set the topic model of this request.
     *
     * If a model is not set, like during requests in a set to a
     * not-yet-created model, Minerva will often add this itself if it
     * can after the fact.
     *
     * Parameters: 
     *  model - *[optional]* a string id
     *
     * Returns: 
     *  string or null
     */
    anchor.model = function(model){
	return anchor._get_set('model-id', model);
    };
    
    /*
     * Function: fact
     *
     * Add a fact to the request. The same as adding subject, object,
     * and predicate all separately.
     *
     * Parameters: 
     *  sub - string
     *  obj - string
     *  pred - string
     *
     * Returns: 
     *  n/a
     */
    anchor.fact = function(sub, obj, pred){
	// Update the request's internal variables.
	anchor.subject(sub);
	anchor.object(obj);
	anchor.predicate(pred);
    };

    /*
     * Function: add_annotation
     *
     * Add an annotation pair (or series of pairs) to the request.
     *
     * Parameters: 
     *  key - string
     *  vals - string or list of strings
     *
     * Returns: 
     *  number of annotations
     */
    anchor.add_annotation = function(key, vals){

	// Convert val to a list if necessary.
	if( what_is(vals) == 'string' ){ vals = [vals]; }
	if( what_is(vals) != 'array' ){ throw new Error('unknown argument'); }

	// Our list of values must be defined if we go this way.
	anchor._ensure_list('values');

	// Add all of the incoming values.
	each(vals, function(val){
	    anchor._arguments['values'].push({'key': key, 'value': val});
	});

	return anchor._arguments['values'].length;
    };

    /*
     * Function: annotations
     *
     * Return list of annotations in request.
     *
     * Parameters: 
     *  n/a
     *
     * Returns: 
     *  (actual) list of request "values" pairs
     */
    anchor.annotations = function(){
	return anchor._arguments['values'];
    };

    /*
     * Function: add_class_expression
     *
     * General use for whatever.
     *
     * Parameters: 
     *  class_expr - anything that can be taken by <bbopx.minerva.class_expression> constructor
     *  property_id - string
     *
     * Returns: 
     *  number of expressions
     */
    anchor.add_class_expression = function(class_expr){
	// Our list of values must be defined if we go this way.
	anchor._ensure_list('expressions');

	var expr = new bbopx.minerva.class_expression(class_expr);
	anchor._arguments['expressions'].push(expr.structure());

	return anchor._arguments['expressions'].length;
    };

    /*
     * Function: add_svf_expression
     *
     * Special use.
     * A short form for "addition" requests that can overload the
     * literal (on the server side) with Manchester syntax.
     *
     * Parameters: 
     *  class_expr - anything that can be taken by <bbopx.minerva.class_expression> constructor
     *  property_id - string (id or...something more complicated?!?)
     *
     * Returns: 
     *  number of expressions
     */
    anchor.add_svf_expression = function(class_expr, property_id){
	// Our list of values must be defined if we go this way.
	anchor._ensure_list('expressions');

	var expr = new bbopx.minerva.class_expression();
	expr.as_svf(class_expr, property_id);
	anchor._arguments['expressions'].push(expr.structure());

	return anchor._arguments['expressions'].length;
    };

    /*
     * Function: add_set_class_expression
     *
     * Intersections and unions.
     *
     * Parameters: 
     *  type - 'intersection' or 'union'
     *  class_expr_list - a list of anything that can be taken by <bbopx.minerva.class_expression> constructor
     *
     * Returns: 
     *  number of expressions
     */
    anchor.add_set_class_expression = function(type, class_expr_list){
    	// Our list of values must be defined if we go this way.
    	anchor._ensure_list('expressions');

	var expr = new bbopx.minerva.class_expression();
	expr.as_set(type, class_expr_list);
	anchor._arguments['expressions'].push(expr.structure());

    	return anchor._arguments['expressions'].length;
    };

    /*
     * Function: expressions
     *
     * Return list of expressions in request.
     *
     * Parameters: 
     *  n/a
     *
     * Returns: 
     *  (actual) list of request "expressions".
     */
    anchor.expressions = function(){
	return anchor._arguments['expressions'];
    };
};

/*
 * Namespace: bbopx.minerva.request_set
 * 
 * Handle sets of requests and serialize for Minerva call.
 * 
 * NOTE: This might eventually find its way into bbop-js.
 */

/*
 * Constructor: request_set
 * 
 * Constructor for a Minerva request item set.
 * 
 * Request sets are essentially serial request queues, that reference
 * eachother using the request_variables contained in invididual
 * requests.
 * 
 * As the request_set operations almost always produce request_sets
 * (with senisible defaults and fail modes), they can easily be
 * chained together.
 * 
 * If a model_id is given, it will be applied to any request that does
 * not have one.
 *
 * Arguments:
 *  user_token - string
 *  model_id - *[optional]* string
 * 
 * Returns:
 *  request set object
 */
bbopx.minerva.request_set = function(user_token, model_id){
    var anchor = this;
    anchor._is_a = 'bbopx.minerva.request_set';

    var each = bbop.core.each;
    //var uuid = bbop.core.uuid;
    var what_is = bbop.core.what_is;

    // 
    anchor._user_token = user_token || null;
    //anchor._intention = intention;
    anchor._model_id = model_id || null;
    anchor._requests = [];
    anchor._last_entity_id = null;

    // Intentions, whether one wants their actions to be communicated
    // to the outside world ('action' vs 'query') are now silently
    // handled withint the request_set framework. The default is the
    // weakest, unles less (almost always) a creative operation is
    // attempted.
    anchor._intention = 'query';

    /*
     * Method: last_individual_id
     * 
     * Return the ID of the last individual identified in a call
     * (implicitly or explicitly).
     * 
     * Arguments:
     *  number_to_skip - *[optional]* number of matches to skip (default: 0)
     * 
     * Returns:
     *  string or null
     *
     * See also:
     *  <bbopx.minerva.request_set.last_fact_triple>
     */
    anchor.last_individual_id = function(number_to_skip){
	var retval = null;

	// Get the last thing identifiable as an individual.
	// 'for' necessary for backwards breakable iteration.
	for( var ugh = anchor._requests.length; ugh > 0; ugh-- ){
	    var req = anchor._requests[ugh -1];
	    if( req.entity() === 'individual' ){
		if( number_to_skip > 0 ){ // knock off skippables
		    number_to_skip--;
		}else{
		    retval = req.individual();
		    break;
		}
	    }
	};
	
	return retval;
    };

    /*
     * Method: last_fact_triple
     * 
     * In our model, facts are anonymous (do not have an ID) and need
     * to be referred to by their unique triple: subject id, object
     * id, and predicate (edge type) id.
     * 
     * This methods return a list of the three string or null.
     * 
     * Arguments:
     *  number_to_skip - *[optional]* number of matches to skip (default: 0)
     * 
     * Returns:
     *  list of three strings or null
     *
     * See also:
     *  <bbopx.minerva.request_set.last_individual_id>
     */
    anchor.last_fact_triple = function(number_to_skip){
	var retval = null;

	// Get the last thing identifiable as an individual.
	// 'for' necessary for backwards breakable iteration.
	for( var ugh = anchor._requests.length; ugh > 0; ugh-- ){
	    var req = anchor._requests[ugh -1];
	    if( req.entity() === 'edge' ){
		if( number_to_skip > 0 ){ // knock off skippables
		    number_to_skip--;
		}else{
		    retval = [];
		    retval.push(req.subject());
		    retval.push(req.object());
		    retval.push(req.predicate());
		    break;
		}
	    }
	};
	
	return retval;
    };

    /*
     * Method: add
     * 
     * Add a request to the queue. This is the most "primitive" method
     * of adding things to the request queue and should only be used
     * when other methods (look at the API) are not available.
     * 
     * Arguments:
     *  req - <bbopx.minerva.request>
     *  intention - *[optional]* 'action' or 'query' ('action' default)
     * 
     * Returns:
     *  <bbopx.minerva.request_set>
     */
    anchor.add = function(req, intention){

	// We always want the "strongest" intention for the batch.
	// If no explicit intention is mentioned, assume that this is
	// a custom op (outside of the API) and is there for an
	// 'action'.
	if( ! intention ){
	    anchor._intention = 'action';
	}else if( intention == 'action' ){
	    anchor._intention = intention;
	}else if( intention == 'query' ){
	    // Skip as it is at least weaker than a possibly set
	    // 'action'.
	}

	anchor._requests.push(req);
	return anchor;
    };

    /*
     * Method: add_individual
     * 
     * Requests necessary to add an instance of with type class to the
     * model.
     * 
     * Expect: "success" and "merge".
     * 
     * Arguments:
     *  class_expr - anything that can be taken by <bbopx.minerva.class_expression> constructor
     *  model_id - *[optional]* string
     * 
     * Returns:
     *  id of individual added, as string
     */
    anchor.add_individual = function(class_expr, model_id){

	var retval = null;
	if( class_expr ){

	    var ind_req = new bbopx.minerva.request('individual', 'add');
	    if( model_id ){ ind_req.model(model_id); } // optionally add

	    ind_req.add_class_expression(class_expr);

	    anchor.add(ind_req, 'action');

	    retval = ind_req.individual();
	}

	//return anchor;
	return retval;
    };

    /*
     * Method: remove_individual
     * 
     * Requests necessary to remove an individual.
     * 
     * Expect: "success" and "rebuild".
     * 
     * Arguments:
     *  individual_id - string
     *  model_id - *[optional]* string
     * 
     * Returns:
     *  <bbopx.minerva.request_set>
     */
    anchor.remove_individual = function(individual_id, model_id){

	if( individual_id ){

	    var ind_req = new bbopx.minerva.request('individual', 'remove');
	    if( model_id ){ ind_req.model(model_id); } // optionally add

	    ind_req.individual(individual_id); 

	    anchor.add(ind_req, 'action');
	}

	return anchor;
    };

    //  value - string
    //  model_id - (optional with fact and individual) string
    anchor._op_type_to_individual = function(op, class_expr, individual_id,
					     model_id){

	if( op && class_expr && individual_id ){
	    if( op != 'add' && op != 'remove' ){
		throw new Error('unknown type operation');
	    }else{
		var type_req =
			new bbopx.minerva.request('individual', op + '-type');
		type_req.individual(individual_id);

		if( model_id ){ type_req.model(model_id); } // optionally add

		// 
		type_req.add_class_expression(class_expr);

		anchor.add(type_req, 'action');
	    }
	}

	return anchor;
    };

    /*
     * Method: add_type_to_individual
     * 
     * Add the identified type to the individual. Multiple calls are
     * logicially treated as an "intersection", but not processed and
     * displayed as such.
     * 
     * Arguments:
     *  class_expr - anything that can be taken by <bbopx.minerva.class_expression> constructor
     *  individual_id - string
     *  model_id - *[optional]* string
     * 
     * Returns:
     *  <bbopx.minerva.request_set>
     */
    anchor.add_type_to_individual = function(class_expr, individual_id,
					     model_id){
	return anchor._op_type_to_individual('add', class_expr, individual_id,
					     model_id);
    };

    /*
     * Method: remove_type_from_individual
     * 
     * Remove the identified type from the individual.
     * 
     * Arguments:
     *  class_expr - anything that can be taken by <bbopx.minerva.class_expression> constructor
     *  individual_id - string
     *  model_id - *[optional]* string
     * 
     * Returns:
     *  <bbopx.minerva.request_set>
     */
    anchor.remove_type_from_individual = function(class_expr, individual_id,
						  model_id){
	return anchor._op_type_to_individual('remove', class_expr, individual_id,
					     model_id);
    };

    // Throw an error if no subject, object, predicate triple as
    // argument.
    anchor._ensure_fact = function(triple){
	if( triple && triple[0] && triple[1] && triple[2] ){
	    // Okay.
	}else{
	    throw new Error('triple did not look like a proper fact');
	}
    };

    /*
     * Method: add_fact
     * 
     * Requests necessary to add an edge between two instances in a
     * model.
     *
     * Expect: "success" and "merge".
     * 
     * Arguments:
     *  triple - list of three strings: [SUBJECT_ID, OBJECT_ID, PREDICATE_ID]
     *  model_id - *[optional]* string
     * 
     * Returns:
     *  <bbopx.minerva.request_set>
     */
    anchor.add_fact = function(triple, model_id){
	anchor._ensure_fact(triple);

	var edge_req = new bbopx.minerva.request('edge', 'add');
	if( model_id ){ edge_req.model(model_id); } // optionally add

	edge_req.fact(triple[0], triple[1], triple[2]);

	anchor.add(edge_req, 'action');

	return triple;
    };

    /*
     * Method: remove_fact
     * 
     * Requests necessary to remove an edge between two instances in a
     * model.
     *
     * Expect: "success" and "rebuild".
     * 
     * Arguments:
     *  triple - list of three strings: [SUBJECT_ID, OBJECT_ID, PREDICATE_ID]
     *  model_id - *[optional]* string
     * 
     * Returns:
     *  <bbopx.minerva.request_set>
     */
    anchor.remove_fact = function(triple, model_id){
	anchor._ensure_fact(triple);

	var edge_req = new bbopx.minerva.request('edge', 'remove');
	if( model_id ){ edge_req.model(model_id); } // optionally add
	
	edge_req.fact(triple[0], triple[1], triple[2]);
	
	anchor.add(edge_req, 'action');

	return anchor;
    };

    /*
     * Method: add_evidence
     * 
     * Adds "anonymous" evidence individual that is referenced in the
     * individual's or fact's annotations to the batch.
     * 
     * Arguments:
     *  evidence_id - string
     *  source_ids - string or list of strings (i.e. PMIDs)
     *  target_identifier - string (individual_id) or list of 3 strings (fact)
     *  model_id - *[optional]* string
     * 
     * Returns:
     *  <bbopx.minerva.request_set>
     */
    anchor.add_evidence = function(evidence_id, source_ids,
				   target_identifier, model_id){

	// Quick check.
	if( evidence_id && source_ids ){

	    // Create floating evidence instance...
	    var ev_ind_req = new bbopx.minerva.request('individual', 'add');
	    if( model_id ){ ev_ind_req.model(model_id); } // optional
	    ev_ind_req.add_class_expression(evidence_id);
	    anchor.add(ev_ind_req, 'action');

	    // Add each source as an annotation to the floating
	    // evidence instance.
	    var ev_ind_ann_req =
		    new bbopx.minerva.request('individual', 'add-annotation');
	    if( model_id ){ ev_ind_ann_req.model(model_id); } // optional
	    ev_ind_ann_req.individual(ev_ind_req.individual());
	    ev_ind_ann_req.add_annotation('source', source_ids);
	    anchor.add(ev_ind_ann_req, 'action');

	    // Switch the final tie-down object--either individual or
	    // fact (triple).
	    if( ! target_identifier ){
		throw new Error('no target identified for evidence add');
	    }else if( what_is(target_identifier) == 'string' ){

		// Tie the floating evidence to the individual
		// with an annotation to it.
		var ind_ann_req = new bbopx.minerva.request('individual',
							    'add-annotation');
		if( model_id ){ ind_ann_req.model(model_id); } // optional
		ind_ann_req.individual(target_identifier);
		ind_ann_req.add_annotation('evidence', ev_ind_req.individual());
		anchor.add(ind_ann_req, 'action');
		
	    }else{
		// Bomb if not a legit triple.
		anchor._ensure_fact(target_identifier);
		
		// Tie the floating evidence to the edge with an
		// annotation to the edge.
		var ed_ann_req = new bbopx.minerva.request('edge',
							   'add-annotation');
		if( model_id ){ ed_ann_req.model(model_id); } // optional
		var t = target_identifier;
		ed_ann_req.fact(t[0], t[1], t[2]);
		ed_ann_req.add_annotation('evidence', ev_ind_req.individual());
		anchor.add(ed_ann_req, 'action');
	    }
	}

	return anchor;
    };

    /*
     * Method: remove_evidence
     * 
     * Remove an evidence annotation from an individual or edge.
     * 
     * Do not need to worry about the "floating" evidence instance
     * made by evidence creation--clean-up will be taken care of by
     * Minerva.
     * 
     * Arguments:
     *  evidence_individual_id - string
     *  model_id - *[optional]* string
     * 
     * Returns:
     *  <bbopx.minerva.request_set>
     */
    anchor.remove_evidence = function(evidence_individual_id, model_id){

	// In our simplified world, evidence deletion just becomes a
	// specific case of individual deletion.
    	if( evidence_individual_id ){
	    anchor.remove_individual(evidence_individual_id, model_id);
	}

    	return anchor;
    };

    /*
     * Method: add_evidence_to_last_individual
     * 
     * Adds "anonymous" evidence individual that is referenced in the
     * individual's annotations, as well as a fact of it's own to the
     * batch.
     * 
     * *[WARNING: Should only be used once, probably not at all!]*
     * 
     * Arguments:
     *  evidence_id - string
     *  source_ids - null, string, or list of strings (PMIDs, etc.)
     *  model_id - *[optional]* string
     * 
     * Returns:
     *  <bbopx.minerva.request_set>
     */
    anchor.add_evidence_to_last_individual = function(evidence_id, source_ids,
						      model_id){

	var tmp_indv = anchor.last_individual_id();
	if( tmp_indv ){
	    anchor.add_evidence(evidence_id, source_ids, tmp_indv, model_id);
	}

	return anchor;
    };

    /*
     * Method: add_evidence_to_last_fact
     * 
     * Adds "anonymous" evidence individual that is referenced in the
     * fact's annotations, as well as a fact of it's own to the batch.
     * 
     * *[WARNING: Should only be used once, probably not at all!]*
     * 
     * Arguments:
     *  evidence_id - string
     *  source_ids - null, string, or list of strings (PMIDs, etc.)
     *  model_id - *[optional]* string
     * 
     * Returns:
     *  <bbopx.minerva.request_set>
     */
    anchor.add_evidence_to_last_fact = function(evidence_id, source_ids,
						model_id){

	var tmp_triple = anchor.last_fact_triple();
	if( tmp_triple ){
	    anchor.add_evidence(evidence_id, source_ids, tmp_triple, model_id);
	}

	return anchor;
    };

    // A helper function to sort out all of the different annotation
    // operations and targets in one function.
    //
    // Args:
    //  op - "add" | "remove"
    //  thing - "model" | "individual" | "edge" 
    //  thing_identifier - ind: id; fact: triple; model: implied
    //  key - string 
    //  value - string
    //  model_id - (optional with fact and individual) string
    anchor._op_annotation_to_target = function(op, target, target_identifier,
					       key, value, model_id){

	// First, decide the request.
	var req = null;
	if( op == 'add' || op == 'remove' ){
	    req = new bbopx.minerva.request(target, op + '-annotation');
	    if( model_id ){ req.model(model_id); } // optional
	}else{
	    throw new Error('unknown annotation operation');
	}

	// Add necessary arguments to identify the target.
	if( target == 'model' ){
	    // Already done.
	}else if( target == 'individual' ){
	    req.individual(target_identifier);
	}else if( target == 'edge' ){
	    anchor._ensure_fact(target_identifier);
	    req.fact(target_identifier[0],
		     target_identifier[1],
		     target_identifier[2]);
	}else{
	    throw new Error('unknown annotation target');
	}

	// Add the annotation.
	if( key && value ){	
	    req.add_annotation(key, value);
	    anchor.add(req, 'action');
	}
    };

    /*
     * Method: add_annotation_to_model
     * 
     * Adds unique key/value set to model.
     * 
     * Arguments:
     *  key - string
     *  value - string
     *  model_id - *[optional]* string
     * 
     * Returns:
     *  <bbopx.minerva.request_set>
     */
    anchor.add_annotation_to_model = function(key, value, model_id){
	anchor._op_annotation_to_target('add', 'model', null,
					key, value, model_id);
	return anchor;
    };

    /*
     * Method: remove_annotation_from_model
     * 
     * Adds unique key/value set to model.
     * 
     * Arguments:
     *  key - string
     *  value - string
     *  model_id - *[optional]* string
     * 
     * Returns:
     *  <bbopx.minerva.request_set>
     */
    anchor.remove_annotation_from_model = function(key, value, model_id){
	anchor._op_annotation_to_target('remove', 'model', null,
					key, value, model_id);
	return anchor;
    };

    /*
     * Method: add_annotation_to_individual
     * 
     * Adds unique key/value set to an individual.
     * 
     * Arguments:
     *  key - string
     *  value - string
     *  individual_id - string
     *  model_id - *[optional]* string
     * 
     * Returns:
     *  <bbopx.minerva.request_set>
     */
    anchor.add_annotation_to_individual = function(key, value, individual_id,
						   model_id){
	anchor._op_annotation_to_target('add', 'individual', individual_id,
					key, value, model_id);
	return anchor;
    };

    /*
     * Method: remove_annotation_from_individual
     * 
     * Removes unique key/value set from an individual.
     * 
     * Arguments:
     *  key - string
     *  value - string
     *  individual_id - string
     *  model_id - *[optional]* string
     * 
     * Returns:
     *  <bbopx.minerva.request_set>
     */
    anchor.remove_annotation_from_individual = function(key, value,
							individual_id, model_id){
	anchor._op_annotation_to_target('remove', 'individual', individual_id,
					key, value, model_id);
	return anchor;
    };

    /*
     * Method: add_annotation_to_fact
     * 
     * Adds unique key/value set to a fact.
     * 
     * Arguments:
     *  key - string
     *  value - string
     *  triple - list of three strings: [SUBJECT_ID, OBJECT_ID, PREDICATE_ID]
     *  model_id - *[optional]* string
     * 
     * Returns:
     *  <bbopx.minerva.request_set>
     */
    anchor.add_annotation_to_fact = function(key, value, triple, model_id){
	anchor._ensure_fact(triple);
	anchor._op_annotation_to_target('add', 'edge',
					triple,	key, value, model_id);
	return anchor;
    };

    /*
     * Method: remove_annotation_from_fact
     * 
     * Removes unique key/value set from a fact.
     * 
     * Arguments:
     *  key - string
     *  value - string
     *  triple - list of three strings: [SUBJECT_ID, OBJECT_ID, PREDICATE_ID]
     *  model_id - *[optional]* string
     * 
     * Returns:
     *  <bbopx.minerva.request_set>
     */
    anchor.remove_annotation_from_fact = function(key, value, triple, model_id){
	anchor._ensure_fact(triple);
	anchor._op_annotation_to_target('remove', 'edge', triple,
					key, value, model_id);
	return anchor;
    };

    /*
     * Method: undo_last_model_batch
     * 
     * Undo the last batch of operations performed on the model.
     * 
     * Arguments:
     *  model_id - *[optional]* string
     * 
     * Returns:
     *  <bbopx.minerva.request_set>
     */
    anchor.undo_last_model_batch = function(model_id){

	var mod_req = new bbopx.minerva.request('model', 'undo');
	if( model_id ){ mod_req.model(model_id); } // optionally add

	anchor.add(mod_req, 'action');

	return anchor;
    };

    /*
     * Method: redo_last_model_batch
     * 
     * Redo the last batch of operations performed on the model.
     * 
     * Arguments:
     *  model_id - *[optional]* string
     * 
     * Returns:
     *  <bbopx.minerva.request_set>
     */
    anchor.redo_last_model_batch = function(model_id){

	var mod_req = new bbopx.minerva.request('model', 'redo');
	if( model_id ){ mod_req.model(model_id); } // optionally add

	anchor.add(mod_req, 'action');

	return anchor;
    };

    /*
     * Method: get_meta
     * 
     * Essentially, get the list of relations.
     * 
     * Arguments:
     *  n/a
     * 
     * Returns:
     *  <bbopx.minerva.request_set>
     */
    anchor.get_meta = function(){

	var req = new bbopx.minerva.request('meta', 'get');

	// Just personal question.
	anchor.add(req, 'query');
	
	return anchor;
    };

    /*
     * Method: get_model
     * 
     * The the state of a model.
     * 
     * This *[CANNOT]* be used with any other request.
     * 
     * Arguments:
     *  model_id - string
     * 
     * Returns:
     *  <bbopx.minerva.request_set>
     */
    anchor.get_model = function(model_id){
	
	var req = new bbopx.minerva.request('model', 'get');
	if( model_id ){ req.model(model_id); }
	
	// Just personal question.
	anchor.add(req, 'query');
	
	return anchor;
    };

    /*
     * Method: get_undo_redo
     * 
     * Get the current undo/redo information for a model.
     * 
     * This *[CANNOT]* be used with any other request.
     * 
     * Arguments:
     *  model_id - *[optional]* string
     * 
     * Returns:
     *  <bbopx.minerva.request_set>
     */
    anchor.get_undo_redo = function(model_id){

	var req = new bbopx.minerva.request('model', 'get-undo-redo');
	if( model_id ){ req.model(model_id); }
	
	// Just personal question.
	anchor.add(req, 'query');

	return anchor;
    };

    /*
     * Method: add_model
     * 
     * Essentially a wrapper for the "generate" class of model
     * methods. The possible seeding arguments fir the argument hash
     * are:
     *  class-id - *[optional]* string; an initial class to build around
     *  taxon-id - *[optional]* string; the background species
     * 
     * Arguments:
     *  argument_hash - string (see above for properties)
     * 
     * Returns:
     *  <bbopx.minerva.request_set>
     */
    anchor.add_model = function(argument_hash){

	// Work out all incoming arguments to testable state.
	var cls_id = null;
	var tax_id = null;
	if( argument_hash ){	    
	    if( argument_hash['class-id'] ){
		cls_id = argument_hash['class-id'];
	    }
	    if( argument_hash['taxon-id'] ){
		tax_id = argument_hash['taxon-id'];
	    }
	}

	// Now that all arguments are defined, build up the request.
	var model_req = new bbopx.minerva.request('model', 'add');
	if( cls_id ){ model_req.special('class-id', cls_id); }
	if( tax_id ){ model_req.special('taxon-id', tax_id); }
	// Unlikely to have any listeners though...
	anchor.add(model_req, 'action');

	return anchor;
    };

    /*
     * Method: store_model
     * 
     * Store the model to the model store (file on disk as of this
     * writing, but may change soon).
     * 
     * Arguments:
     *  model_id - *[optional]* string
     * 
     * Returns:
     *  <bbopx.minerva.request_set>
     */
    anchor.store_model = function(model_id){

	var store_req = new bbopx.minerva.request('model', 'store');
	if( model_id ){ store_req.model(model_id); } // optionally add

	// No need to broadcast and disrupt to others on the model if
	// it's just this.
	anchor.add(store_req, 'query');

	return anchor;
    };

    /*
     * Method: structure
     * 
     * Create the JSON object that will be passed to the Minerva
     * server.
     * 
     * Arguments:
     *  n/a
     * 
     * Returns:
     *  final object of all queued requests
     */
    anchor.structure = function(){

	// Ready the base return.
	var rset = {
	    'token': anchor._user_token,
	    'intention': anchor._intention
	};

	// Add a JSON stringified request arguments.
	var reqs = [];
	each(anchor._requests,
	     function(req){
		 // If possible, add model in cases where is was not
		 // supplied.
		 if( ! req.model() && anchor._model_id ){
		     req.model(anchor._model_id);
		 }
		 reqs.push(req.objectify());
	     });
	rset['requests'] = reqs;

	return rset;
    };

    /*
     * Method: callable
     * 
     * Serialize a request set and the component requests.
     * 
     * Arguments:
     *  n/a
     * 
     * Returns:
     *  serialization of all queued requests
     */
    anchor.callable = function(){

	var rset = anchor.structure();
	var reqs = rset['requests'];

	var str = bbop.json.stringify(reqs);
	var enc = encodeURIComponent(str);
	rset['requests'] = enc;

	return rset;
    };
};
/* 
 * Package: response.js
 * 
 * Namespace: bbopx.barista.response
 * 
 * Generic BBOP handler for dealing with the gross parsing of
 * responses from the GO Molecular Model Manager REST server JSON
 * responses.
 * 
 * It will detect if the incoming response is structured correctly and
 * give safe access to fields and properties.
 * 
 * It is not meant to be a model for the parts in the data section.
 */

// if ( typeof bbop == "undefined" ){ var bbop = {}; }
// if ( typeof bbop.rest == "undefined" ){ bbop.rest = {}; }
// if ( typeof bbop.rest.response == "undefined" ){ bbop.rest.response = {}; }
// TODO/BUG: workaround until I get this properly folded into bbop-js.
if ( typeof bbopx == "undefined" ){ var bbopx = {}; }
if ( typeof bbopx.barista == "undefined" ){ bbopx.barista = {}; }

/*
 * Constructor: response
 * 
 * Contructor for a Minerva REST JSON response object.
 * 
 * The constructor argument is an object or a string.
 * 
 * Arguments:
 *  raw - the JSON object as a string or object
 * 
 * Returns:
 *  response object
 */
bbopx.barista.response = function(raw){
    bbop.rest.response.call(this);
    this._is_a = 'bbopx.barista.response';

    // Required top-level strings in the response.
    // message and message_type are defined in the superclass.
    this._uid = null; // initiating user
    this._packet_id = null; // identify the packet
    this._intention = null; // what the user wanted to do ('query', 'action')
    this._signal = null; // 'merge', 'rebuild', 'meta', etc.

    // Optional top-level strings in the response.
    this._commentary = null;

    // Optional top-level objects.
    // Data contains model_id, inconsistency, etc.
    this._data = null;

    // Start with the assumption that the response is bad, try and
    // prove otherwise.
    this.okay(false);

    // Raw will only be provided in that cases that it makes sense.
    this._raw = null;
    
    // If we have no data coming in, there is a problem...
    if( ! raw ){
	
	this.message('empty response in handler');
	this.message_type('error');

    }else{

	// If we do have something coming in, And it looks like
	// something we might be able to deal with, do our best to
	// decode it.
	var itsa = bbop.core.what_is(raw);
	if( itsa != 'string' && itsa != 'object' ){
	    
	    // No idea what this thing is...
	    this.message('bad argument type in handler');
	    this.message_type('error');

	}else{
	    
	    // Try to make the string an object.
	    if( itsa == 'string' ){
		try {
		    this._raw = bbop.json.parse(raw);
		}catch(e){
		    // Didn't make it--chuck it to create a signal.
		    this._raw = null;
		    this.message('handler could not parse string response');
		    this.message_type('error');
		}
	    }else{
		// Looks like somebody else got here first.
		this._raw = raw;
	    }

	    // If we managed to define some kind of raw incoming data
	    // that is (or has been parsed to) a model, start probing
	    // it out to see if it is structured correctly.
	    if( this._raw ){

		// Check required fields.
		var jresp = this._raw;
		// These must always be defined.
		if( ! jresp['message-type'] || ! jresp['message'] ){
		    // Core info.
		    this.message_type('error');
		    this.message('message and message_type must always exist');
		}else{

		    // Take out the individual optional bits for
		    // examination.
		    var cdata = jresp['commentary'] || null;
		    var odata = jresp['data'] || null;

		    // If data, object.
		    if( odata && bbop.core.what_is(odata) != 'object' ){
		    // if( odata && bbop.core.what_is(odata) != 'object' &&
		    // 	bbop.core.what_is(odata) != 'array' ){
			this.message('data not object');
			this.message_type('error');
		    }else{
			// If commentary, string.
			if( cdata && bbop.core.what_is(cdata) != 'string' ){
			    this.message('commentary not string');
			    this.message_type('error');
			}else{
			    // Looks fine then I guess.
			    this.okay(true);

			    // Super-class.
			    this.message_type(jresp['message-type']);
			    this.message(jresp['message']);

			    // Plug in the other required fields.
			    this._uid = jresp['uid'] || 'unknown';
			    this._intention = jresp['intention'] || 'unknown';
			    this._signal = jresp['signal'] || 'unknown';
			    this._packet_id = jresp['packet-id'] || 'unknown';

			    // Add any additional fields.
			    if( cdata ){ this._commentary = cdata; }
			    if( odata ){ this._data = odata; }
			}
		    }
		}
	    }
	}
    }
};
bbop.core.extend(bbopx.barista.response, bbop.rest.response);

/*
 * Function: user_id
 * 
 * Returns the user id (uid) for a call if it was generated my a known
 * user.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  string or null
 */
bbopx.barista.response.prototype.user_id = function(){
    var ret = null;
    if( this._uid ){ ret = this._uid; }
    return ret;
};

/*
 * Function: intention
 * 
 * Returns the user intention for a call.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  string or null
 */
bbopx.barista.response.prototype.intention = function(){
    var ret = null;
    if( this._intention ){ ret = this._intention; }
    return ret;
};

/*
 * Function: signal
 * 
 * Returns the server's action signal, if there was one.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  string or null
 */
bbopx.barista.response.prototype.signal = function(){
    var ret = null;
    if( this._signal ){ ret = this._signal; }
    return ret;
};

/*
 * Function: packet_id
 * 
 * Returns the response's unique id. Usful to make sure you're not
 * talking to yourself in some cases.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  string or null
 */
bbopx.barista.response.prototype.packet_id = function(){
    var ret = null;
    if( this._packet_id ){ ret = this._packet_id; }
    return ret;
};

/*
 * Function: commentary
 * 
 * Returns the commentary object (whatever that might be in any given
 * case).
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  copy of commentary object or null
 */
bbopx.barista.response.prototype.commentary = function(){
    var ret = null;
    if( this._commentary ){
	ret = bbop.core.clone(this._commentary);
    }
    return ret;
};

/*
 * Function: data
 * 
 * Returns the data object (whatever that might be in any given
 * case). This grossly returns all response data, if any.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  copy of data object or null
 */
bbopx.barista.response.prototype.data = function(){
    var ret = null;
    if( this._data ){
	ret = bbop.core.clone(this._data);
    }
    return ret;
};

/*
 * Function: model_id
 * 
 * Returns the model id of the response.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  string or null
 */
bbopx.barista.response.prototype.model_id = function(){
    var ret = null;
    if( this._data && this._data['id'] ){
	ret = this._data['id'];
    }
    return ret;
};

/*
 * Function: inconsistent_p
 * 
 * Returns true or false on whether or not the returned model is
 * thought to be inconsistent. Starting assumption is that it is not.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  true or false
 */
bbopx.barista.response.prototype.inconsistent_p = function(){
    var ret = false;
    if( this._data &&
	typeof(this._data['inconsistent-p']) !== 'undefined' &&
	this._data['inconsistent-p'] == true ){
	ret = true;
    }
    return ret;
};

/*
 * Function: has_undo_p
 * 
 * Returns a true or false depending on the existence an undo list.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  boolean
 */
bbopx.barista.response.prototype.has_undo_p = function(){
    var ret = false;
    if( this._data && this._data['undo'] && 
	bbop.core.is_array(this._data['undo']) &&
	this._data['undo'].length > 0 ){
	ret = true;
    }
    return ret;
};

/*
 * Function: has_redo_p
 * 
 * Returns a true or false depending on the existence a redo list.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  boolean
 */
bbopx.barista.response.prototype.has_redo_p = function(){
    var ret = false;
    if( this._data && this._data['redo'] && 
	bbop.core.is_array(this._data['redo']) &&
	this._data['redo'].length > 0 ){
	ret = true;
    }
    return ret;
};

/*
 * Function: facts
 * 
 * Returns a list of the facts in the response. Empty list if none.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  list
 */
bbopx.barista.response.prototype.facts = function(){
    var ret = [];
    if( this._data && this._data['facts'] && 
	bbop.core.is_array(this._data['facts']) ){
	ret = this._data['facts'];
    }
    return ret;
};

/*
 * Function: properties
 * 
 * Returns a list of the properties in the response. Empty list if none.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  list
 */
bbopx.barista.response.prototype.properties = function(){
    var ret = [];
    if( this._data && this._data['properties'] && 
	bbop.core.is_array(this._data['properties']) ){
	ret = this._data['properties'];
    }
    return ret;
};

/*
 * Function: individuals
 * 
 * Returns a list of the individuals in the response. Empty list if none.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  list
 */
bbopx.barista.response.prototype.individuals = function(){
    var ret = [];
    if( this._data && this._data['individuals'] && 
	bbop.core.is_array(this._data['individuals']) ){
	ret = this._data['individuals'];
    }
    return ret;
};

/*
 * Function: inferred_individuals
 * 
 * Returns a list of the inferred_individuals in the response. Empty
 * list if none.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  list
 */
bbopx.barista.response.prototype.inferred_individuals = function(){
    var ret = [];
    if( this._data && this._data['individuals-i'] && 
	bbop.core.is_array(this._data['individuals-i']) ){
	ret = this._data['individuals-i'];
    }
    return ret;
};

/*
 * Function: annotations
 * 
 * Returns a list of the (complex) annotations found in the
 * response. Sometimes not there, so check the return.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  list
 */
bbopx.barista.response.prototype.annotations = function(){
    var ret = [];
    if( this._data && this._data['annotations'] && 
	bbop.core.is_array(this._data['annotations']) ){
	ret = this._data['annotations'];
    }
    return ret;
};

/*
 * Function: export
 * 
 * Returns the string of the export found in the return.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  string
 */
bbopx.barista.response.prototype.export_model = function(){
    var ret = '';
    if( this._data && this._data['export'] ){
	ret = this._data['export'];
    }
    return ret;
};

/*
 * Function: relations
 * 
 * Returns a list of the relations found in the response. Sometimes not
 * there, so check the return.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  list
 */
bbopx.barista.response.prototype.relations = function(){
    var ret = [];
    if( this._data && this._data['meta'] && this._data['meta']['relations'] && 
	bbop.core.is_array(this._data['meta']['relations']) ){
	ret = this._data['meta']['relations'];
    }
    return ret;
};

/*
 * Function: evidence
 * 
 * Returns a list of the evidence found in the response. Sometimes not
 * there, so check the return.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  list
 */
bbopx.barista.response.prototype.evidence = function(){
    var ret = [];
    if( this._data && this._data['meta'] && this._data['meta']['evidence'] && 
	bbop.core.is_array(this._data['meta']['evidence']) ){
	ret = this._data['meta']['evidence'];
    }
    return ret;
};

/*
 * Function: model_ids
 * 
 * Returns a list the model ids found in the response. Sometimes not
 * there, so check the return.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  list
 *
 * See Also:
 *  <models_meta>
 */
bbopx.barista.response.prototype.model_ids = function(){
    var ret = [];
    if( this._data && this._data['meta'] && this._data['meta']['model-ids'] && 
	bbop.core.is_array(this._data['meta']['model-ids']) ){
	ret = this._data['meta']['model-ids'];
    }
    return ret;
};

/*
 * Function: models_meta
 * 
 * Returns a hash of the model ids to models properties found in the
 * response.
 *
 * Sometimes not there, so check the return.
 *
 * WARNING: A work in progress, but this is intended as an eventual
 * replacement to model_ids.
 * 
 * Arguments:
 *  n/a
 * 
 * Returns:
 *  hash
 *
 * See Also:
 *  <model_ids>
 */
bbopx.barista.response.prototype.models_meta = function(){
    var ret = {};
    if( this._data && this._data['meta'] && this._data['meta']['models-meta'] && 
	bbop.core.is_hash(this._data['meta']['models-meta']) ){
	ret = this._data['meta']['models-meta'];
    }
    return ret;
};
/*
 * Package: client.js
 *
 * Namespace: bbopx.barista.client
 * 
 * Let's try and communicate with the socket.io server (Barista) for
 * messages and the like--client-to-client communication.
 *
 * There are two major categories: "relay" and "query". Relays are for
 * passing information on to other clients (e.g. "where I am");
 * queries are for asking barista information about what it might know
 * (e.g. "where is X").
 */

if ( typeof bbopx == "undefined" ){ var bbopx = {}; }
if ( typeof bbopx.barista == "undefined" ){ bbopx.barista = {}; }

/*
 * Constructor: client
 *
 * Registry for client-to-client communication via Barista.
 */
bbopx.barista.client = function(barista_location, token){
    bbop.registry.call(this, ['connect',
			      'initialization',
			      //'disconnect',
			      'relay', // catch-all
			      'merge', // data is raw response 
			      'rebuild', // data is raw response 
			      'message',
			      'clairvoyance',
			      'telekinesis',
			      'query']); // asking barista something for yourself
    this._is_a = 'bbopx.barista.client';

    var anchor = this;
    anchor._token = token;
    anchor.socket = null;
    anchor.model_id = null;
    anchor.okay_p = null;

    // These are the non-internal ones that we know about.
    var known_relay_classes = {
	'relay': true,
	// Specific forms of relay.
	'message': true,
	'merge': true,
	'rebuild': true,
	'clairvoyance': true,
	'telekinesis': true
    };
    var known_query_classes = {
	'query': true
    };

    var logger = new bbop.logger('barista client');
    logger.DEBUG = true;
    //logger.DEBUG = false;
    function ll(str){ logger.kvetch(str); }

    // Check to make sure that the optional library was correctly
    // loaded.
    if( typeof(io) === 'undefined' || typeof(io.connect) === 'undefined' ){
	ll('was unable to load server.io from messaging server (io undefined)');
	anchor.okay_p = false;
    }else{
	ll('likely have the right setup--attempting');
	anchor.okay_p = true;
    }	

    /*
     * Method: okay
     */
    anchor.okay = function(){
	var ret = false;
	//if( anchor.okay_p && anchor.socket && anchor.model_id ){
	if( anchor.okay_p ){
	    ret = true;
	}
	return ret;
    };

    /*
     * Method: token
     *
     * Operate on your identifying token.
     */
    anchor.token = function(in_token){
	if( in_token ){
	    anchor._token = in_token;
	}
	return anchor._token;
    };

    /*
     * Method: relay
     *
     * General structure for relaying information between clients.
     * Always check that the comm is on.
     * Always inject 'token' and 'model_id'.
     */
    anchor.relay = function(relay_class, data){
	if( ! anchor.okay() ){
	    ll('no good socket on location; did you connect()?');
	}else{
	    //ll('relay: (' + anchor.model_id + ', ' + anchor.token() + ')');

	    // Inject our data.
	    data['class'] = relay_class;
	    data['model_id'] = anchor.model_id;
	    data['token'] = anchor.token();

	    anchor.socket.emit('relay', data);
	}
    };

    /*
     * Method: query
     *
     * General structure for requesting information from Barista about
     * things it might know.
     * Always check that the comm is on.
     * Always inject 'token' and 'model_id'.
     */
    anchor.query = function(query_class, data){
	if( ! anchor.okay() ){
	    ll('no good socket on location; did you connect()?');
	}else{
	    ll('sending query: ('+ anchor.model_id +', '+ anchor.token() +')');

	    // Inject our data.
	    data['class'] = query_class;
	    data['model_id'] = anchor.model_id;
	    data['token'] = anchor.token();

	    anchor.socket.emit('query', data);
	}
    };

    /*
     * Method: get_layout
     *
     * Wrapper for the only thing query is currently used for.
     */
    anchor.get_layout = function(){
	anchor.query('query', {'query': 'layout'});
    };

    /*
     * Method: connect
     *
     * Required call before using messenger.
     *
     * TODO: Specify the channel over and above the general server.
     * For the time being, just using the model id in the message.
     */
    anchor.connect = function(model_id){
	if( ! anchor.okay() ){
	    ll('no good socket on connect; did you connect()?');
	}else{

	    // Set internal variables and make actual connection.
	    //anchor.socket = io.connect(barista_location + '/messenger');
	    anchor.socket = io.connect(barista_location);
	    anchor.model_id = model_id;
	    anchor.socket_id = anchor.socket.id;
	    
	    function _inject_data_with_client_info(data){
		if( ! data ){
		    data = {};
		    //}else{
		}

		// // Standard.
		// data['model_id'] = anchor.model_id;
		// data['socket_id'] = anchor.socket_id;
		// data['token'] = anchor.token();

		// // Optional.
		// data['message_type'] = null;
		// data['message'] = null;
		// data['signal'] = null;
		// data['intention'] = null;
		// data['top'] = null;
		// data['left'] = null;
		// data['data'] = null;
		// data['state'] = null;
		
		return data;
	    }

	    // Check whether ot not we should ignore the incoming
	    // data.
	    function _applys_to_us_p(data){
		var ret = false;

		var mid = data['model_id'] || null;
		if( ! mid || mid != anchor.model_id ){
		    ll('skip packet--not for us');
		}else{
		    ret = true;
		}

		return ret;
	    }

	    // This internal connect is special since no data is
	    // actually coming from the outsice world.
	    anchor.socket.on('connect', function (empty_placeholder){
		var data = _inject_data_with_client_info(empty_placeholder);

		// Let others know that I have connected using the 
		data['message_type'] = 'success';
		data['message'] = 'new client connected';
		//anchor.socket.emit('relay', data);
		anchor.relay('message', data);

		// Run appropriate callbacks.
		ll('apply "connect" callbacks');
		anchor.apply_callbacks('connect', [data]);
	    });

	    // Our initialization data from the server.
	    anchor.socket.on('initialization', function (data){
		data = _inject_data_with_client_info(data);
		//ll('received initialization info from socket: ' + sid);
		
		// Run appropriate callbacks.
		ll('apply "initialization" callbacks');
		anchor.apply_callbacks('initialization', [data]);
	    });

	    // Setup to catch info events from the clients and pass
	    // them on if they were meant for us. 
	    anchor.socket.on('relay', function(data){
		data = _inject_data_with_client_info(data);

		// Check to make sure it interests us.
		if( _applys_to_us_p(data) ){

		    var dclass = data['class'];
		    if( ! dclass ){
			ll('no relay class found');
		    }else if( ! known_relay_classes[dclass] ){
			ll('unknown relay class: ' + dclass);
		    }else{
			// Run appropriate callbacks.
			ll('apply (relay) "'+ dclass +'" callbacks');
			anchor.apply_callbacks(dclass, [data]);
		    }
		}
	    });

	    // Setup to catch query events from things we'veasked
	    // barista.
	    anchor.socket.on('query', function(data){
		data = _inject_data_with_client_info(data);

		// Check to make sure it interests us.
		if( _applys_to_us_p(data) ){

		    var dclass = data['class'];
		    if( ! dclass ){
			ll('no query class found');
		    }else if( ! known_query_classes[dclass] ){
			ll('unknown query class: ' + dclass);
		    }else{
			// Run appropriate callbacks.
			ll('apply (query) "'+ dclass +'" callbacks');
			anchor.apply_callbacks(dclass, [data]);
		    }
		}
	    });
     	}
    };

    /*
     * Method: message
     *
     * Just a message.
     */
    anchor.message = function(m){
	m['class'] = 'message';
	// var packet = {
	//     'class': 'message',
	//     'message_type': m['message_type'],
	//     'message': m['message'],
	//     'me': m['message_type'],
	//     'message_type': m['message_type']
	// };
	// anchor.relay('message', packet);
	anchor.relay('message', m);
    };

    /*
     * Method: clairvoyance
     *
     * Remote awareness of our location.
     */
    anchor.clairvoyance = function(top, left){
	var packet = {
	    'class': 'clairvoyance',
	    'top': top,
	    'left': left
	};
	anchor.relay('clairvoyance', packet);
    };

    /*
     * Method: telekinesis
     *
     * Move objects at a distance.
     */
    anchor.telekinesis = function(item_id, top, left){
	var packet = {
	    'class': 'telekinesis',
	    'objects': [{
		'item_id': item_id,
		'top': top,
		'left': left
	    }]
	};
	anchor.relay('telekinesis', packet);
    };

};
bbop.core.extend(bbopx.barista.client, bbop.registry);
/*
 * Package: context.js
 *
 * A handful of functions for drawing entities in different contexts.
 */

if ( typeof bbopx == "undefined" ){ var bbopx = {}; }
if ( typeof bbopx.noctua == "undefined" ){ bbopx.noctua = {}; }

/*
 * Function: type_to_minimal
 *
 * Return a single-line text-only one-level representation of a type.
 */
bbopx.noctua.type_to_minimal = function(in_type, aid){

    var ret = '[???]';
    
    var t = in_type.type();
    var f = in_type.frame();

    if( t == 'class' ){
	ret = in_type.class_label();
    }else if( t == 'union' || t == 'intersection' ){
	ret = t + '[' + f.length + ']';
    }else{
	// SVF a little harder.
	var ctype = in_type.category();
	var ctype_r = aid.readable(ctype);

	// Probe it a bit.
	var ce = in_type.svf_class_expression();
	var cetype = ce.type();

	var inner_lbl = '???';
	if( cetype == 'class' ){
	    inner_lbl = ce.class_label();
	}else if( cetype == 'union' || cetype == 'intersection' ){
	    var cef = ce.frame();
	    inner_lbl = cetype + '[' + cef.length + ']';
	}else{
	    inner_lbl = '[SVF]';
	}

	//var cr = aid.readable(cat);
	ret = ctype_r + '(' + inner_lbl + ')';
    }

    // A little special "hi" for inferred types.
    if( in_type.inferred_p() ){
	ret = '[' + ret + ']';
    }

    return ret;
};

/*
 * Function: type_to_span
 *
 * Essentially, minimal rendered as a usable span, with a color
 * option.
 */
bbopx.noctua.type_to_span = function(in_type, aid, color_p){

    var min = bbopx.noctua.type_to_minimal(in_type, aid);

    var text = null;
    if( color_p ){
	text = '<span ' +
	    'style="background-color: ' + aid.color(in_type.category()) + ';" ' +
	    'alt="' + min + '" ' +
	    'title="' + min +'">' +
	    min + '</span>';
    }else{
	text = '<span alt="' + min + '" title="' + min +'">' + min + '</span>';
    }

    return text;
};

/*
 * Function: type_to_full
 *
 * A recursive writer for when we no longer care--a table that goes on
 * and on...
 */
bbopx.noctua.type_to_full = function(in_type, aid){
    var anchor = this;
    var each = bbop.core.each;

    var text = '[???]';

    var t = in_type.type();
    if( t == 'class' ){ // if simple, the easy way out
	text = bbopx.noctua.type_to_minimal(in_type, aid);
    }else{
	// For everything else, we're gunna hafta do a little
	// lifting...
	var cache = [];
	if( t == 'union' || t == 'intersection' ){
	    
	    // Some kind of recursion on a frame then.
	    cache = [
		'<table width="80%" class="table table-bordered table-hover table-condensed mme-type-table" ' +
		    'style="background-color: ' +
	     	    aid.color(in_type.category()) + ';">',
		'<caption>' + t + '</caption>',
		//'<thead style="background-color: white;">',
		'<thead style="">',
		'</thead>',
		'<tbody>'
	    ];
	    // cache.push('<tr>'),
	    var frame = in_type.frame();
	    each(frame,
		 function(ftype){
		     cache.push('<tr style="background-color: ' +
		     		aid.color(ftype.category()) + ';">'),
		     cache.push('<td>');
		     // cache.push('<td style="background-color: ' +
	     	     // 		aid.color(ftype.category()) + ';">'),
		     cache.push(bbopx.noctua.type_to_full(ftype, aid));
		     cache.push('</td>');
		     cache.push('</tr>');
		 });	
	    // cache.push('</tr>');
	    cache.push('</tbody>');
	    cache.push('</table>');
	    
	    text = cache.join('');	    

	}else{

	    // A little harder: need to a an SVF wrap before I recur.
	    var pid = in_type.property_id();
	    var plabel = in_type.property_label();
	    var svfce = in_type.svf_class_expression();
	    cache = [
		'<table width="80%" class="table table-bordered table-hover table-condensed mme-type-table">',
		'<thead style="background-color: ' + aid.color(pid) + ';">',
		plabel,
		'</thead>',
		'<tbody>'
	    ];
	    cache.push('<tr style="background-color: ' +
		       aid.color(svfce.category()) + ';"><td>'),
	    cache.push(bbopx.noctua.type_to_full(svfce, aid));
	    cache.push('</td></tr>');
	    cache.push('</tbody>');
	    cache.push('</table>');
	    
	    text = cache.join('');
	}
    }


    // var min = bbopx.noctua.type_to_minimal(in_type, aid);
    // var exp = bbopx.noctua.type_to_expanded(in_type, aid);
    // var text = '<span alt="' + exp + '" title="' + exp +'">' + min + '</span>';

    return text;
};
/*
 * Package: draggable-canvas.js
 *
 * Namespace: bbopx.noctua.draggable_canvas
 *
 * Playing with graph area scroll.
 * Take a look at:
 *  http://hitconsultants.com/dragscroll_scrollsync/scrollpane.html
 */

if ( typeof bbopx == "undefined" ){ var bbopx = {}; }
if ( typeof bbopx.noctua == "undefined" ){ bbopx.noctua = {}; }

/*
 * Constructor: draggable_canvas
 *
 * Make the div a draggable canvas.
 */
bbopx.noctua.draggable_canvas = function(container_id){

    var logger = new bbop.logger('drag');
    //logger.DEBUG = true;
    logger.DEBUG = false;
    function ll(str){ logger.kvetch(str); }

    var container_div = '#' + container_id;

    // TODO: This /should/ have worked, but the way the SVG is layed in
    // seems to make in not work very well at all.
    //jQuery(graph_div).draggable();

    // Hand made--not great either...
    var px = -1;
    var py = -1;
    function _update_start_pos(down_evt){
    	px = down_evt.pageX;
    	py = down_evt.pageY;
    	ll("down at: " + px + "," + py);
	// TODO: start cursor drag
    }
    function _scroller(move_evt){
	var page_x = move_evt.pageX;
	var page_y = move_evt.pageY;
    	var offx = page_x - px;
    	var offy = page_y - py;
	var pos_left = jQuery(container_div).position().left;
	var pos_top = jQuery(container_div).position().top;
	var old_left = jQuery(container_div).scrollLeft();
	var old_top = jQuery(container_div).scrollTop();
	var scroll_width = jQuery(container_div).get(0).scrollWidth;
	var scroll_height= jQuery(container_div).get(0).scrollHeight;
	var dim_width = jQuery(container_div).width();
	var dim_height = jQuery(container_div).height();
    	ll('scrolling: ' +
	   //'p:' + px + "," + py + '; ' +
	   'page:' + page_x + "," + page_y + '; ' +
	   'off: ' + offx + "," + offy + '; ' +
	   'pos: ' + pos_left + "," + pos_top + '; ' + 
	   'old: ' + old_left + "," + old_top + '; ' + 
	   'scroll: ' + scroll_width + "," + scroll_height + '; ' + 
	   'dim: ' + dim_width + "," + dim_height);

	// Check bounds, unbind if we stray.
	// TODO: complete if this is actually effective; get the
	// feeling it's not.
	if( pos_top >= page_y || // top
	    dim_height + pos_top <= page_y ){ //bottom
	    ll('dimensional unbind');
	    _unbind_scroller();
	}else{
	    // Otherwise, make the move.
	    jQuery(container_div).scrollLeft(old_left - offx);
	    jQuery(container_div).scrollTop(old_top - offy);
    	    px = move_evt.pageX;
    	    py = move_evt.pageY;	    
	}
    }
    function _unbind_scroller(){
    	jQuery(container_div).unbind('mousemove', _scroller);
	// TODO: revert cursor
    }
    
    // Stat on mouse down.
    jQuery(container_div).mousedown(
    	function(e){
	    if( this == e.target ){ // only stat if actual, not child
    		_update_start_pos(e);
    		// Bind to moving.
    		jQuery(container_div).bind('mousemove', _scroller);
	    }
    	});

    // Stop for almost any reason.
    jQuery(container_div).mouseup(
    	function(e){
    	    ll('unbind on mouseup');
    	    _unbind_scroller();
    	});
    jQuery(container_div).mouseout(
    	function(e){
    	    ll('unbind on mouseup');
    	    _unbind_scroller();
    	});
    jQuery(container_div).mouseleave(
    	function(e){
    	    ll('unbind on mouseleave');
    	    _unbind_scroller();
    	});
    jQuery(container_div).select( // to trigger, we're moving fast
    	function(e){
    	    ll('unbind on select');
    	    _unbind_scroller();
    	});
    // jQuery(container_div).blur(
    // 	function(e){
    // 	    ll('unbind on blur');
    // 	    _unbind_scroller();
    // 	});
    // jQuery(container_div).focusout(
    // 	function(e){
    // 	    ll('unbind on focusout');
    // 	    _unbind_scroller();
    // 	});
};
///
/// Core edit model. Essentially several sets and an order.
/// This is meant to be changed when we get a richer model working,
/// but for the prototype, I don't want to lock in to the bbop
/// graph model, so I'm using something much dumber than can
/// be easily wrapped or changed later, but still have some editing
/// options.
///

if ( typeof bbopx == "undefined" ){ var bbopx = {}; }
if ( typeof bbopx.noctua == "undefined" ){ bbopx.noctua = {}; }
if ( typeof bbopx.noctua.edit == "undefined" ){ bbopx.noctua.edit = {}; }

// BUG/TODO:
// Temporary cleansing until 
//bbopx.noctua.context = new bbop.context(amigo.data.context);
bbopx.noctua.clean = function(str){
    //return bbopx.noctua.context.cleanse(str);  
    return str;
};

/*
 * Edit annotations.
 * Everything can take annotations.
 * 
 * This structure of the raw key-value set has been updated in the
 * wire protocol. It now looks like:
 * 
 * : {"key": "contributor", "value": "GOC:kltm" }
 * 
 * Parameters:
 *  kv_set - *[optional]* a set of keys and values; a simple object
 */
bbopx.noctua.edit.annotation = function(kv_set){
    this._id = bbop.core.uuid();

    this._properties = {};

    if( kv_set && bbop.core.what_is(kv_set) == 'object' ){

	// Attempt to convert
	if( kv_set['key'] && kv_set['value'] ){
	    var key = kv_set['key'];
	    var val = kv_set['value'];
	    var adj_set = {};
	    adj_set[key] = val;
	    this._properties = bbop.core.clone(adj_set);
	}else{
	    console.log('bad annoatation k/v set: ', kv_set);
	}
    }
};

bbopx.noctua.edit.annotation.prototype.id = function(){ return this._id; };

bbopx.noctua.edit.annotation.prototype.property = function(key, value){

    var anchor = this;
    var ret = null;

    // Set if the key and value are there.
    if( key ){
	if( typeof(value) !== 'undefined' ){
	    anchor._properties[key] = value;
	}
	ret = anchor._properties[key];
    }

    return ret;
};

bbopx.noctua.edit.annotation.prototype.delete_property = function(key){

    var anchor = this;
    var ret = null;

    if( key ){
	ret = delete anchor._properties[key];
    }

    return ret;
};

///
/// Generic annotation operations
///

bbopx.noctua.edit._annotations = function(in_ann){
    if( in_ann && bbop.core.what_is(in_ann) == 'array' ){
	this._annotations = in_ann;
    }
    return this._annotations;
};
bbopx.noctua.edit._add_annotation = function(in_ann){
    if( in_ann && bbop.core.what_is(in_ann) != 'array' ){
	this._annotations.push(in_ann);
    }
    return this._annotations;
};
bbopx.noctua.edit._get_annotations_by_filter = function(filter){

    var anchor = this;
    var ret = [];
    bbop.core.each(anchor._annotations, function(ann){
	var res = filter(ann);
	if( res && res == true ){
	    ret.push(ann);
	}
    });
    return ret;
};
bbopx.noctua.edit._get_annotation_by_id = function(aid){

    var anchor = this;
    var ret = null;
    bbop.core.each(anchor._annotations, function(ann){
	if( ann.id() == aid ){
	    ret = ann;
	}
    });
    return ret;
};

/*
 *  Edit control.
 * 
 * Parameters:
 *  n/a
 */
bbopx.noctua.edit.core = function(){
    this.core = {
	//'id': [], // currently optional
	'id': null, // currently optional
	'nodes': {}, // map of id to edit_node
	'edges': {}, // map of id to edit_edge
	'node_order': [], // initial table order on redraws
	'node2elt': {}, // map of id to physical object id
	'elt2node': {},  // map of physical object id to id
	// Remeber that edge ids and elts ids are the same, so no map
	// is needed.
	'edge2connector': {}, // map of edge id to virtual connector id
	'connector2edge': {}  // map of virtual connector id to edge id 
    };

    this._annotations = [];
};

bbopx.noctua.edit.core.prototype.add_id = function(id){
    // TODO: make this smarter/useful
    //this.core['id'].push(id);
    this.core['id'] = id;
    return this.core['id'];
};

bbopx.noctua.edit.core.prototype.get_id = function(){
    return this.core['id'];
};

bbopx.noctua.edit.core.prototype.add_node = function(enode){

    // Add/update node.
    var enid = enode.id();
    this.core['nodes'][enid] = enode; // add to nodes

    // Only create a new elt ID and order if one isn't already in
    // there (or reuse things to keep GUI working smoothly).
    var elt_id = this.core['node2elt'][enid];
    if( ! elt_id ){ // first time
	this.core['node_order'].unshift(enid); // add to default order
	elt_id = bbop.core.uuid(); // generate the elt id we'll use from now on
	this.core['node2elt'][enid] = elt_id; // map it
	this.core['elt2node'][elt_id] = enid; // map it	
    }
};

// Convert the JSON-LD lite model into the edit core.
// Creates or adds as necessary.
bbopx.noctua.edit.core.prototype.add_node_from_individual = function(indv){
    var anchor = this;

    var ret = null;

    // Add individual to edit core if properly structured.
    var iid = indv['id'];
    if( iid ){
	//var nn = new bbop.model.node(indv['id']);
	//var meta = {};
	//ll('indv');
	
	// See if there is type info that we want to add.
	var itypes = indv['type'] || [];
	if( bbop.core.what_is(itypes) != 'array' ){
	    throw new Error('types is wrong');
	}

	// Create the node.
	var ne = new bbopx.noctua.edit.node(iid, itypes, ianns);

	// See if there is type info that we want to add.
	var ianns = indv['annotations'] || [];
	if( bbop.core.what_is(ianns) != 'array' ){
	    throw new Error('annotations is wrong');
	}else{
	    // Add the annotations individually.
	    bbop.core.each(ianns, function(ann_kv_set){
		var na = new bbopx.noctua.edit.annotation(ann_kv_set);
		ne.add_annotation(na);
	    });
	}

	anchor.add_node(ne);
	ret = ne;
    }
    
    return ne;
};

bbopx.noctua.edit.core.prototype.edit_node_order = function(){
    return this.core['node_order'] || [];
};

bbopx.noctua.edit.core.prototype.get_node = function(enid){
    return this.core['nodes'][enid] || null;
};

bbopx.noctua.edit.core.prototype.get_node_elt_id = function(enid){
    return this.core['node2elt'][enid] || null;
};

bbopx.noctua.edit.core.prototype.get_node_by_elt_id = function(elt_id){
    var ret = null;
    var enid = this.core['elt2node'][elt_id] || null;
    if( enid ){
	ret = this.core['nodes'][enid] || null;
    }
    return ret;
};

bbopx.noctua.edit.core.prototype.get_node_by_individual = function(indv){
    var anchor = this;

    var ret = null;

    // Add individual to edit core if properly structured.
    var iid = indv['id'];
    if( iid ){	
	ret = this.core['nodes'][iid] || null;
    }
    
    return ret;
};

bbopx.noctua.edit.core.prototype.get_nodes = function(){
    return this.core['nodes'] || {};
};

bbopx.noctua.edit.core.prototype.remove_node = function(enid){

    var anchor = this;

    if( this.core['nodes'][enid] ){
	var enode = this.core['nodes'][enid];

	// Removing node removes all related edges.
	// TODO: Dumb scan right now.
	bbop.core.each(this.core['edges'], function(edge_id, edge){
	    if( edge.source() == enid || edge.target() == enid ){
		var eeid = edge.id();
		anchor.remove_edge(eeid);
	    }
	});
	
	// Also remove the node from the order list.
	// TODO: Is this a dumb scan?
	var ni = this.core['node_order'].indexOf(enid);
	if( ni != -1 ){
	    this.core['node_order'].splice(ni, 1);
	}

	// Clean the maps.
	var elt_id = this.core['node2elt'][enid];
	delete this.core['node2elt'][enid];
	delete this.core['elt2node'][elt_id];

	// Finally, remove the node itself.
	delete this.core['nodes'][enid];
    }
};

bbopx.noctua.edit.core.prototype.add_edge = function(eedge){
    var eeid = eedge.id();
    this.core['edges'][eeid] = eedge;
    var elt_id = bbop.core.uuid(); // generate the elt id we'll use
    //this.core['edge2elt'][eeid] = elt_id; // map it
    //this.core['elt2edge'][elt_id] = eeid; // map it
};

// 
bbopx.noctua.edit.core.prototype.add_edge_from_fact = function(fact, aid){

    var anchor = this;
    var each = bbop.core.each;

    var ret_fact = null;
    
    // Add individual to edit core if properly structured.
    var sid = fact['subject'];
    var oid = fact['object'];
    var pid = fact['property'];
    var anns = fact['annotations'] || [];
    if( sid && oid && pid ){

	var en = new bbopx.noctua.edit.edge(sid, pid, oid, anns);
	if( bbop.core.what_is(anns) != 'array' ){
	    throw new Error('annotations is wrong');
	}else{
	    // Add the annotations individually.
	    bbop.core.each(anns, function(ann_kv_set){
		var na = new bbopx.noctua.edit.annotation(ann_kv_set);
		en.add_annotation(na);
	    });
	}

	// Add and ready to return edge.
	anchor.add_edge(en);
	ret_fact = en;
    }
    
    return ret_fact;
};

// // TODO/BUG: aid is used as a crutch here to scan out the edges
// bbopx.noctua.edit.core.prototype.add_edges_from_individual = function(indv, aid){

//     var anchor = this;
//     var each = bbop.core.each;

//     var ret_facts = [];
    
//     // Add individual to edit core if properly structured.
//     var iid = indv['id'];
//     if( iid ){
// 	// Now, let's probe the model to see what edges
// 	// we can find.
// 	var possible_rels = aid.all_known();
// 	each(possible_rels,
// 	     function(try_rel){
// 		 if( indv[try_rel] && indv[try_rel].length ){
		     
// 		     // Cycle through each of the found
// 		     // rels.
// 		     var found_rels = indv[try_rel];
// 		     each(found_rels,
// 			  function(rel){
// 			      var tid = rel['id'];
// 			      var rt = rel['type'];
// 			      if( tid && rt && rt == 'NamedIndividual'){
// 				  var en =
// 				      new bbopx.noctua.edit.edge(iid, try_rel, tid);
// 				  anchor.add_edge(en);
// 				  ret_facts.push(en);
// 			      }
// 			  });
// 		 }
// 	     });
//     }
    
//     return ret_facts;
// };

bbopx.noctua.edit.core.prototype.get_edge_id_by_connector_id = function(cid){
    return this.core['connector2edge'][cid] || null;
};

bbopx.noctua.edit.core.prototype.get_connector_id_by_edge_id = function(eid){
    return this.core['edge2connector'][eid] || null;
};

// // Get all of the edges by individual.
// bbopx.noctua.edit.core.prototype.get_edges_by_individual = function(indv){

//     var anchor = this;
//     var each = bbop.core.each;

//     var ret_facts = [];
    
//     // Add individual to edit core if properly structured.
//     var iid = indv['id'];
//     if( iid ){
// 	// Now, let's probe the model to see what edges
// 	// we can find.
// 	var possible_rels = aid.all_known();
// 	each(possible_rels,
// 	     function(try_rel){
// 		 if( indv[try_rel] && indv[try_rel].length ){
		     
// 		     // Cycle through each of the found
// 		     // rels.
// 		     var found_rels = indv[try_rel];
// 		     each(found_rels,
// 			  function(rel){
// 			      var tid = rel['id'];
// 			      var rt = rel['type'];
// 			      if( tid && rt && rt == 'NamedIndividual'){
// 				  var en =
// 				      new bbopx.noctua.edit.edge(iid, try_rel, tid);
// 				  anchor.add_edge(en);
// 				  ret_facts.push(en);
// 			      }
// 			  });
// 		 }
// 	     });
//     }
    
//     return ret_facts;
// };

bbopx.noctua.edit.core.prototype.get_edge = function(eeid){
    return this.core['edges'][eeid] || null;
};

bbopx.noctua.edit.core.prototype.get_edges = function(){
    return this.core['edges'] || [];
};

/*
 * Function: 
 * 
 * Return a list of edges that are concerned with the nodes as source.
 */
bbopx.noctua.edit.core.prototype.get_edges_by_source = function(srcid){

    var rete = [];
    bbop.core.each(this.core['edges'], function(edge_id, edge){
	var src = edge.source();
	if( src == srcid ){
	    rete.push(edge);
	}
    });

    return rete;
};

/*
 * Function: 
 * 
 * Return a list of edges that are concerned with the nodes as target.
 */
bbopx.noctua.edit.core.prototype.get_edges_by_target = function(tgtid){

    var rete = [];
    bbop.core.each(this.core['edges'], function(edge_id, edge){
	var tgt = edge.target();
	if( tgt == tgtid ){
	    rete.push(edge);
	}
    });

    return rete;
};

bbopx.noctua.edit.core.prototype.remove_edge = function(eeid){
    if( this.core['edges'][eeid] ){

	// Main bit out.
	delete this.core['edges'][eeid];

	// And clean the maps.
	var cid = this.core['edge2connector'][eeid];
	delete this.core['edge2connector'][eeid];
	delete this.core['connector2edge'][cid];
    }
};

bbopx.noctua.edit.core.prototype.create_edge_mapping = function(eedge, connector){
    var eid = eedge.id();
    var cid = connector.id;
    this.core['edge2connector'][eid] = cid;
    this.core['connector2edge'][cid] = eid;
};

// Debugging text output function.
bbopx.noctua.edit.core.prototype.dump = function(){

    //
    var dcache = [];
    
    bbop.core.each(this.core['nodes'], function(node_id, node){

	var ncache = ['node'];
	ncache.push(node.id());
	// ncache.push(node.enabled_by());
	// ncache.push(node.activity());
	// ncache.push(node.unknown().join('|'));
	// ncache.push(node.process());
	// ncache.push(node.location().join('|'));
	dcache.push(ncache.join("\t"));
    });
    
    bbop.core.each(this.core['edges'], function(edge_id, edge){
	var ecache = ['edge'];
	ecache.push(edge.source());
	ecache.push(edge.relation());
	ecache.push(edge.target());
	dcache.push(ecache.join("\t"));
    });
    
    return dcache.join("\n");
};

// Return gross high-level topology.
bbopx.noctua.edit.core.prototype.to_graph = function(){

    // 
    var ex_graph = new bbop.model.graph();
    
    // Add nodes.
    bbop.core.each(this.core['nodes'], function(node_id, node){

	// Create node.
	var ex_node = new bbop.model.node(node_id);
	//ex_node.metadata(ex_meta);
	
	// Add to export graph.
	ex_graph.add_node(ex_node);
    });
    
    // Add edges to the export graph.
    bbop.core.each(this.core['edges'], function(edge_id, edge){
	//
	var ex_edge =
	    new bbop.model.edge(edge.source(), edge.target(), edge.relation());
	ex_graph.add_edge(ex_edge);
    });
    
    return ex_graph;
};

// Add annotation operations to prototype.
bbopx.noctua.edit.core.prototype.annotations =
    bbopx.noctua.edit._annotations;
bbopx.noctua.edit.core.prototype.add_annotation =
    bbopx.noctua.edit._add_annotation;
bbopx.noctua.edit.core.prototype.get_annotations_by_filter =
    bbopx.noctua.edit._get_annotations_by_filter;
bbopx.noctua.edit.core.prototype.get_annotation_by_id =
    bbopx.noctua.edit._get_annotation_by_id;

/**
 * Edit nodes.
 * 
 * Parameters:
 *  in_id - *[optional]* generated if not given
 *  in_types - *[serially optional]*
 */
bbopx.noctua.edit.node = function(in_id, in_types){

    var anchor = this;

    this._types = [];
    this._id2type = {};
    this._annotations = [];

    if( typeof(in_id) === 'undefined' ){
	this._id = bbop.core.uuid();
    }else{
	//this._id = in_id;
	this._id = bbopx.noctua.clean(in_id);
    }
    if( typeof(in_types) !== 'undefined' ){
	bbop.core.each(in_types, function(in_type){
	    var new_type = new bbopx.minerva.class_expression(in_type);
	    anchor._id2type[new_type.id()] = new_type;
	    anchor._types.push(new bbopx.minerva.class_expression(in_type));
	});
    }
    
    // Optional layout hints.
    this._x_init = null; // initial layout hint
    this._y_init = null;
    // this.xlast = null; // last known location
    // this.ylast = null;
};

// (possibly generated) ID is RO
bbopx.noctua.edit.node.prototype.id = function(value){
    return this._id;
};

/**
 * Function: types
 * 
 * Get current types; replace current types.
 * 
 * Parameters:
 *  in_types - *[optional]* raw JSON type objects
 * 
 * Returns:
 *  array
 */
bbopx.noctua.edit.node.prototype.types = function(in_types){
    var anchor = this;    

    if( in_types && bbop.core.what_is(in_types) == 'array' ){

	// Wipe previous type set.
	anchor._id2type = {};
	anchor._types = [];

	bbop.core.each(in_types, function(in_type){
	    var new_type = new bbopx.minerva.class_expression(in_type);
	    anchor._id2type[new_type.id()] = new_type;
	    anchor._types.push(new_type);
	});
    }
    return this._types;
};

/**
 * Function: add_types
 * 
 * Add types to current types.
 * 
 * Parameters:
 *  in_types - raw JSON type objects
 *  inferred_p - whether or not the argument types are inferred
 * 
 * Returns:
 *  boolean
 */
bbopx.noctua.edit.node.prototype.add_types = function(in_types, inferred_p){
    var anchor = this;    
    var inf_p = inferred_p || false;

    var ret = false;

    if( in_types && bbop.core.what_is(in_types) == 'array' ){
	bbop.core.each(in_types, function(in_type){
	    var new_type = new bbopx.minerva.class_expression(in_type, inf_p);
	    anchor._id2type[new_type.id()] = new_type;
	    anchor._types.push(new_type);
	    
	    ret = true; // return true if did something
	});
    }
    return ret;
};

/**
 * Function: get_type_by_id
 * 
 * Get the 
 * 
 * Parameters:
 *  type_id - type id
 * 
 * Returns:
 *  type or null
 */
bbopx.noctua.edit.node.prototype.get_type_by_id = function(type_id){
    var anchor = this;

    var ret = null;
    ret = anchor._id2type[type_id];

    return ret;
};

bbopx.noctua.edit.node.prototype.x_init = function(value){
    if(value) this._x_init = value; return this._x_init; };

bbopx.noctua.edit.node.prototype.y_init = function(value){
    if(value) this._y_init = value; return this._y_init; };

// Add annotation operations to prototype.
bbopx.noctua.edit.node.prototype.annotations =
    bbopx.noctua.edit._annotations;
bbopx.noctua.edit.node.prototype.add_annotation =
    bbopx.noctua.edit._add_annotation;
bbopx.noctua.edit.node.prototype.get_annotations_by_filter =
    bbopx.noctua.edit._get_annotations_by_filter;
bbopx.noctua.edit.node.prototype.get_annotation_by_id =
    bbopx.noctua.edit._get_annotation_by_id;

/*
 * Edit edges.
 * 
 * Parameters:
 *  src_id - source id
 *  rel_id - relation id
 *  tgt_id - target/object id
 */
bbopx.noctua.edit.edge = function(src_id, rel_id, tgt_id){
    this._id = bbop.core.uuid();
    // this._source_id = src_id;
    // this._relation_id = rel_id;
    // this._target_id = tgt_id;
    this._source_id = bbopx.noctua.clean(src_id);
    this._relation_id = bbopx.noctua.clean(rel_id);
    this._target_id = bbopx.noctua.clean(tgt_id);

    this._annotations = [];
};
bbopx.noctua.edit.edge.prototype.id = function(){ // ID is RO
    return this._id; };
bbopx.noctua.edit.edge.prototype.source = function(value){
    if(value) this._source_id = value; return this._source_id; };
bbopx.noctua.edit.edge.prototype.relation = function(value){
    if(value) this._relation_id = value; return this._relation_id; };
bbopx.noctua.edit.edge.prototype.target = function(value){
    if(value) this._target_id = value; return this._target_id; };

// Add annotation operations to prototype.
bbopx.noctua.edit.edge.prototype.annotations =
    bbopx.noctua.edit._annotations;
bbopx.noctua.edit.edge.prototype.add_annotation =
    bbopx.noctua.edit._add_annotation;
bbopx.noctua.edit.edge.prototype.get_annotations_by_filter =
    bbopx.noctua.edit._get_annotations_by_filter;
bbopx.noctua.edit.edge.prototype.get_annotation_by_id =
    bbopx.noctua.edit._get_annotation_by_id;
/*
 * Package: location-store.js
 *
 * Namespace: bbopx.noctua.location-store
 *
 * Simple abstraction to take care of operating on stored locations.
 */

if ( typeof bbopx == "undefined" ){ var bbopx = {}; }
if ( typeof bbopx.noctua == "undefined" ){ bbopx.noctua = {}; }

/*
 * Constructor: location_store
 *
 * Object to track object locations.
 */
bbopx.noctua.location_store = function(){

    var anchor = this;

    var logger = new bbop.logger('lcstr');
    logger.DEBUG = true;
    //logger.DEBUG = false;
    function ll(str){ logger.kvetch(str); }

    // 
    var lstore = {};

    /*
     * Function: add
     *
     * True if new, false if update. 
     *
     * Parameters: 
     *  id - string
     *  x - number 
     *  y - number 
     *
     * Returns: 
     *  true (new id) or false (known id)
     */
    anchor.add = function(id, x, y){
	var ret = true;

	if( lstore[id] ){
	    ret = false;
	}
	lstore[id] = {'x': x, 'y': y};

	return ret;
    };

    /*
     * Function: remove
     *
     * True is removal, false if wasn't there.
     *
     * Parameters: 
     *  id - string
     *
     * Returns: 
     *  boolean
     */
    anchor.remove = function(id){
	var ret = false;

	if( lstore[id] ){
	    ret = true;
	}
	delete lstore[id];

	return ret;
    };

    /*
     * Function: get
     *
     * Get x/y coord of id.
     *
     * Parameters: 
     *  id - string
     *
     * Returns: 
     *  x/y object pair
     */
    anchor.get = function(id){
	var ret = null;

	if( lstore[id] ){
	    ret = lstore[id];
	}

	return ret;
    };

};
/* 
 * Package: widgets.js
 *
 * Namespace: bbopx.noctua.widgets
 *
 * Namespace for large drawing routines.
 */

if ( typeof bbopx == "undefined" ){ var bbopx = {}; }
if ( typeof bbopx.noctua == "undefined" ){ bbopx.noctua = {}; }
if ( typeof bbopx.noctua.widgets == "undefined" ){ bbopx.noctua.widgets = {}; }

/*
 * Function: build_token_link
 *
 * "Static" function.
 *
 * For the time being, the cannonical way of building a link with a
 * token.
 */
bbopx.noctua.widgets.build_token_link = function(url, token){
    var new_url = url;
    
    if( token ){
	if( new_url.indexOf('?') == -1 ){
	    new_url = new_url + '?' + 'barista_token=' + token;
	}else{
	    new_url = new_url + '&' + 'barista_token=' + token;
	}
    }
    
    return new_url;
};

/*
 * Function: repaint_info
 *
 * Add edit model node contents to a descriptive table.
 */
bbopx.noctua.widgets.repaint_info = function(ecore, aid, info_div){

    // Node and edge counts.
    var nds = bbop.core.get_keys(ecore.get_nodes()) || [];
    var eds = bbop.core.get_keys(ecore.get_edges()) || [];

    // Any annotation information that came in.
    var anns = '';
    bbop.core.each(ecore.annotations(), function(ann){
	if( ann.property('comment') ){
	    anns += '<dd>' +
		'<small><strong>comment</strong></small> ' +
		ann.property('comment') +
		'</dd>';
	}
    });
    if( anns == '' ){
	anns = '<dd>none</dd>';
    }

    // Try and get a title out of the model.
    var mtitle = '???';
    var tanns = ecore.get_annotations_by_filter(function(a){
	var ret = false;
	if( a.property('title') ){
	    ret = true;
	}
	return ret;
    });
    if( tanns && tanns[0] ){ mtitle = tanns[0].property('title'); }

    var str_cache = [
	'<dl class="dl-horizontal">',
	// '<dt></dt>',
	// '<dd>',
	// '</dd>',
	'<dt>ID</dt>',
	'<dd>',
	ecore.get_id(),
	'</dd>',
	'<dt>Name</dt>',
	'<dd>',
	mtitle,
	'</dd>',
	'<dt>Individuals</dt>',
	'<dd>',
	nds.length || 0,
	'</dd>',
	'<dt>Indv. Rels.</dt>',
	'<dd>',
	eds.length || 0,
	'</dd>',
	'<dt>Annotations</dt>',
	anns
    ];
    
    // Add to display.
    jQuery(info_div).empty();
    jQuery(info_div).append(str_cache.join(' '));
};

/*
 * Function: repaint_exp_table
 *
 * Add edit model node contents to a descriptive table.
 */
bbopx.noctua.widgets.repaint_exp_table = function(ecore, aid, table_div){

    var each = bbop.core.each;

    // First, lets get the headers that we'll need by poking the
    // model and getting all of the possible categories.	
    var cat_list = [];
    each(ecore.get_nodes(), function(enode_id, enode){
	each(enode.types(), function(in_type){
	    cat_list.push(in_type.category());
	});
    });
    // Dedupe list.
    var tmph = bbop.core.hashify(cat_list);
    cat_list = bbop.core.get_keys(tmph);

    // If we actually got something, render the table. Otherwise,
    // a message.
    if( bbop.core.is_empty(cat_list) ){
	
	// Add to display.
	jQuery(table_div).empty();
	jQuery(table_div).append('<p><h4>no instances</h4></p>');

    }else{
	
	// Sort header list according to known priorities.
	cat_list = cat_list.sort(function(a, b){
	    return aid.priority(b) - aid.priority(a);
	});
	
	// Convert the ids into readable headers.
	var nav_tbl_headers = [];
	each(cat_list, function(cat_id){
	    var hdrc = [
		aid.readable(cat_id),
		'&uarr;&darr;'
	    ];
	    nav_tbl_headers.push(hdrc.join(' '));
	});
	
	var nav_tbl =
	    new bbop.html.table(nav_tbl_headers, [],
				{'generate_id': true,
				 'class': ['table', 'table-bordered',
					   'table-hover',
					   'table-condensed'].join(' ')});
	
	//each(ecore.get_nodes(),
	each(ecore.edit_node_order(), function(enode_id){
	    var enode = ecore.get_node(enode_id);
	    
	    // Now that we have an enode, we want to mimic the order
	    // that we created for the header (cat_list). Start by
	    // binning the types.
	    var bin = {};
	    each(enode.types(), function(in_type){
		var cat = in_type.category();
		if( ! bin[cat] ){ bin[cat] = []; }
		bin[cat].push(in_type);
	    });
	    
	    // Now unfold the binned types into the table row
	    // according to the sorted order.
	    var table_row = [];
	    each(cat_list, function(cat_id){
		var accumulated_types = bin[cat_id];
		var cell_cache = [];
		each(accumulated_types, function(atype){
		    var tt = bbopx.noctua.type_to_span(atype, aid);
		    cell_cache.push(tt);
		});
		table_row.push(cell_cache.join('<br />'));
	    });
	    nav_tbl.add_to(table_row);		     
	});
	
	// Add to display.
	jQuery(table_div).empty();
	jQuery(table_div).append(nav_tbl.to_string());

	// Make it sortable using the plugin.
	jQuery('#' + nav_tbl.get_id()).tablesorter(); 
    }
};

/*
 * Function: repaint_edge_table
 *
 * Add edit model edge contents to a descriptive table.
 */
bbopx.noctua.widgets.repaint_edge_table = function(ecore, aid, table_div){

    var each = bbop.core.each;

    var edge_list = ecore.get_edges();

    // If we actually got something, render the table. Otherwise,
    // a message.
    if( bbop.core.is_empty(edge_list) ){
	
	// Add to display.
	jQuery(table_div).empty();
	jQuery(table_div).append('<p><h4>no relations</h4></p>');

    }else{
	
	// Make the (obvjously known) headers pretty.
	var nav_tbl_headers = [];
	each(['subject', 'relation', 'object'], function(hdr){
	    var hdrc = [
		hdr,
		'&uarr;&darr;'
	    ];
	    nav_tbl_headers.push(hdrc.join(' '));
	});
		
	var nav_tbl =
	    new bbop.html.table(nav_tbl_headers, [],
				{'generate_id': true,
				 'class': ['table', 'table-bordered',
					   'table-hover',
					   'table-condensed'].join(' ')});
	
	each(edge_list, function(edge_id){
	    var edge = ecore.get_edge(edge_id);
	    var s = edge.source();
	    var r = edge.relation();
	    var t = edge.target();

	    // according to the sorted order.
	    var table_row = [
		aid.readable(s),
		aid.readable(r),
		aid.readable(t)
	    ];
	    
	    nav_tbl.add_to(table_row);		     
	});
	
	// Add to display.
	jQuery(table_div).empty();
	jQuery(table_div).append(nav_tbl.to_string());

	// Make it sortable using the plugin.
	jQuery('#' + nav_tbl.get_id()).tablesorter(); 
    }
};

/*
 * Function: wipe
 *
 * Wipe out the contents of a jQuery-identified div.
 */
bbopx.noctua.widgets.wipe = function(div){
    jQuery(div).empty();
};

/*
 * Function: enode_to_stack
 *
 * Takes a core edit node as the argument, categorize the
 * contained types, order them.
 *
 * As a secondary function, remove overly "dupe-y" inferred types.
 */
bbopx.noctua.widgets.enode_to_stack = function(enode, aid){
	
    var each = bbop.core.each;
    var pare = bbop.core.pare;

    // 
    var sig_lookup = {};
    var bin_stack = enode.types() || [];

    // Get ready to remove "dupes", first by collecting the signatures
    // of the non-inferred individual types.
    each(bin_stack, function(t){
	if( ! t.inferred_p() ){
	    sig_lookup[t.signature()] = true;
	}
    });

    // Sort the types within the stack according to the known
    // type priorities.
    function _sorter(a, b){

	// Inferred nodes always have ??? priority.
	var ainf = a.inferred_p();
	var binf = b.inferred_p();
	if( ainf != binf ){
	    if( binf ){
		return 1;
	    }else{
		return -1;
	    }
	}
	
	// Otherwise, use aid property priority.
	var bpri = aid.priority(b.property_id());
	var apri = aid.priority(a.property_id());
	return apri - bpri;
    };

    // Filter anything out that has a matching signature.
    function _filterer(item){
	var ret = false;
	if( item.inferred_p() ){
	    if( sig_lookup[item.signature()] ){
		ret = true;
	    }
	}
	return ret;
    }

    bin_stack = pare(bin_stack, _filterer, _sorter);

    return bin_stack;
};
    
/*
 * Function: render_node_stack
 *
 * ???
 */
bbopx.noctua.widgets.render_node_stack = function(enode, aid){

    var each = bbop.core.each;

    // Create a colorful label stack into an individual table.
    var enode_stack_table = new bbop.html.tag('table',
					      {'class':'bbop-mme-stack-table'});

    // Add type/color information.
    var inferred_type_count = 0;
    var ordered_types = bbopx.noctua.widgets.enode_to_stack(enode, aid);
    each(ordered_types, function(item){
	
	// Special visual handling of inferred types.
	if( item.inferred_p() ){ inferred_type_count++; }
	
	var trstr = '<tr class="bbop-mme-stack-tr" ' +
		 'style="background-color: ' +
	    aid.color(item.category()) +
	    ';"><td class="bbop-mme-stack-td">' 
	    + bbopx.noctua.type_to_span(item, aid) + '</td></tr>';   
	enode_stack_table.add_to(trstr);
    });

    // Inject meta-information if extant.
    var anns = enode.annotations();
    if( anns.length != 0 ){

	// Meta counts.
	var n_ev = 0;
	var n_other = 0;
	each(anns, function(ann){
	    if( ann.property('evidence') ){ n_ev++; }
	    else{ n_other++; }
	});

	// Add to top.
	var trstr = '<tr class="bbop-mme-stack-tr">' +
	    '<td class="bbop-mme-stack-td"><small style="color: grey;">' 
	    + 'evidence: ' + n_ev + '; other: ' + n_other + 
	    '</small></td></tr>';
	enode_stack_table.add_to(trstr);
    }
    
    // Add external visual cue if there were inferred types.
    if( inferred_type_count > 0 ){
	var itcstr = '<tr class="bbop-mme-stack-tr">' +
	    '<td class="bbop-mme-stack-td"><small style="color: grey;">' +
	    'inferred types: ' + inferred_type_count + '</small></td></tr>';
	enode_stack_table.add_to(itcstr);
    }

    return enode_stack_table;
};

/*
 * Function: add_enode
 *
 * Add a new enode.
 */
bbopx.noctua.widgets.add_enode = function(ecore, enode, aid, graph_div){

    var each = bbop.core.each;

    // Node as table nested into bbop.html div.
    var div_id = ecore.get_node_elt_id(enode.id());
    var style_str = 'top: ' + enode.y_init() + 'px; ' + 
	'left: ' + enode.x_init() + 'px;';
    //ll('style: ' + style_str);
    var w = new bbop.html.tag('div',
			      {'id': div_id,
			       'class': 'demo-window',
			       'style': style_str});
    
    var enode_stack_table = bbopx.noctua.widgets.render_node_stack(enode, aid);
    w.add_to(enode_stack_table);
    
    // Box to drag new connections from.	
    var konn = new bbop.html.tag('div', {'class': 'konn'});
    w.add_to(konn);
    
    // Box to click for edit dialog.
    var opend = new bbop.html.tag('div', {'class': 'open-dialog'});
    w.add_to(opend);
    
    // // Box to click for annotation dialog.
    // var openann = new bbop.html.tag('div', {'class': 'open-annotation-dialog'});
    // w.add_to(openann);
    
    jQuery(graph_div).append(w.to_string());
};

/*
 * Function: update_enode
 *
 * Update the displayed contents of an enode.
 */
bbopx.noctua.widgets.update_enode = function(ecore, enode, aid){

    var each = bbop.core.each;

    // Node as table nested into bbop.html div.
    var uelt = ecore.get_node_elt_id(enode.id());
    jQuery('#' + uelt).empty();

    var enode_stack_table = bbopx.noctua.widgets.render_node_stack(enode, aid);
    jQuery('#' + uelt).append(enode_stack_table.to_string());
    
    // Box to drag new connections from.	
    var konn = new bbop.html.tag('div', {'class': 'konn'});
    jQuery('#' + uelt).append(konn.to_string());
    
    // Box to drag new connections from.	
    var opend = new bbop.html.tag('div', {'class': 'open-dialog'});
    jQuery('#' + uelt).append(opend.to_string());

    // // Box to click for annotation dialog.
    // var openann = new bbop.html.tag('div', {'class': 'open-annotation-dialog'});
    // jQuery('#' + uelt).append(openann.to_string());
};

/*
 * Constructor: contained_modal
 *
 * Object.
 * 
 * The contained_modal is a simple modal dialog 
 * Node modal: invisible until it's not modal dialog.
 * 
 * NOTE: We're skipping some of the bbop.html stuff since we
 * specifically want BS3 stuff and not the jQuery-UI stuff that is
 * sometimes haning around in there.
 * 
 * arg_title may be null, string, or bbop.html
 * arg_body may be null, string, or bbop.html
 * 
 */
bbopx.noctua.widgets.contained_modal = function(type, arg_title, arg_body){
    
    var tag = bbop.html.tag;

    var shield_p = false;
    if( type && type == 'shield' ){
	shield_p = true;
    }else{
	// ???
    }

    // Define buttons first.
    var x_btn_args = {
	'type': 'button',
	'class': 'close',
	'data-dismiss': 'modal',
	'aria-hidden': 'true'
    };
    var x_btn = new tag('button', x_btn_args, '&times;');
    var close_btn_args = {
	'type': 'button',
	'class': 'btn btn-default',
	'data-dismiss': 'modal'
    };
    var close_btn = new tag('button', close_btn_args, 'Close');

    // Then the title.
    var title_args = {
	'generate_id': true,
	'class': 'modal-title'	
    };
    var title = new tag('div', title_args, arg_title);

    // One button and the title are in the header.
    var header_args = {
	'class': 'modal-header'
    };
    var header = null;
    if( shield_p ){
	header = new tag('div', header_args, title);
    }else{
	header = new tag('div', header_args, [x_btn, title]);
    }

    // The footer has the other button.
    var footer_args = {
	'generate_id': true,
	'class': 'modal-footer'
    };
    var footer = new tag('div', footer_args, close_btn);

    // Ready the body.
    var body_args = {
	'generate_id': true,
	'class': 'modal-body'	
    };
    var body = new tag('div', body_args, arg_body);

    // Content has header, body, and footer.
    var content_args = {
	'class': 'modal-content'
    };
    var content = null;
    if( shield_p ){
	content = new tag('div', content_args, [header, body]);
    }else{
	content = new tag('div', content_args, [header, body, footer]); 
    }

    // Dialog contains content.
    var dialog_args = {
	'class': 'modal-dialog'
    };
    var dialog = new tag('div', dialog_args, content); 
    
    // And the container contains it all.
    var container_args = {
	'generate_id': true,
	'class': 'modal fade',
	'tabindex': '-1',
	'role': 'dialog',
	'aria-labelledby': body.get_id(),
	'aria-hidden': 'true'
    };
    var container = new tag('div', container_args, dialog); 

    // Attach the assembly to the DOM.
    var modal_elt = '#' + container.get_id();
    jQuery('body').append(container.to_string());
    var modal_opts = {
    };
    if( shield_p ){
	modal_opts['backdrop'] = 'static';
	modal_opts['keyboard'] = false;
    }

    // Add destructor to hidden listener--clicking on the close with
    // eliminate this dialog from the DOM completely.
    jQuery(modal_elt).on('hidden.bs.modal',
			 function(){ jQuery(this).remove(); });

    // Add activities.
    // TODO

    ///
    /// Add external controls, etc.
    ///

    // To be used before show--add elements (as a string) to the main
    // modal DOM (which can have events attached).
    this.add_to_body = function(str){
	var add_to_elt = '#' + body.get_id();
	jQuery(add_to_elt).append(str);
    };
    
    // // To be used before show--add elements (as a string) to the main
    // // modal DOM (which can have events attached).
    // this.reset_footer = function(){
    // 	var add_to_elt = '#' + footer.get_id();
    // 	jQuery(add_to_elt).append(str);
    // };
    
    // To be used before show--add elements (as a string) to the main
    // modal DOM (which can have events attached).
    this.add_to_footer = function(str){
	var add_to_elt = '#' + footer.get_id();
	jQuery(add_to_elt).append(str);
    };
    
    //
    this.show = function(){
	jQuery(modal_elt).modal(modal_opts);	
    };
    
    //
    // Will end up destorying it since we are listening for the
    // "hidden" event above.
    this.destroy = function(){
	jQuery(modal_elt).modal('hide');
    };
};

/*
 * Constructor: compute_shield
 * 
 * Contained blocking shield for general compute activity.
 * 
 * Function that returns object.
 * 
 * TODO: make subclass?
 */ 
bbopx.noctua.widgets.compute_shield = function(){

    var tag = bbop.html.tag;

    // Text.
    var p = new tag('p', {},
		    'Doing remote processing. This may take a minute...');

    // Progress bar.
    var pb_args = {
	'class': 'progress-bar',
	'role': 'progressbar',
	'aria-valuenow': '100',
	'aria-valuemin': '0',
	'aria-valuemax': '100',
	'style': 'width: 100%'
    };
    var pb = new tag('div', pb_args, '<span class="sr-only">Working...</span>');
    var pb_container_args = {
	'class': 'progress progress-striped active'
    };
    var pb_container = new tag('div', pb_container_args, pb);

    var mdl = new bbopx.noctua.widgets.contained_modal('shield', 'Relax',
						   [p, pb_container]);
    return mdl;
};

/*
 * Function: sorted_relation_list
 *
 * Function that returns a sorted relation list of the form [[id, label], ...]
 * 
 * Optional boost when we don't care using the boolean "relevant" field.
 * The boost is 10.
 * 
 * TODO: make subclass?
 */
bbopx.noctua.widgets.sorted_relation_list = function(relations, aid){
    
    var each = bbop.core.each;

    var boost = 10;

    // Get a sorted list of known rels.
    //var rels = aid.all_entities();
    var rels = relations.sort(function(a,b){ 
	var id_a = a['id'];
	var id_b = b['id'];
	
	var pr_a = aid.priority(id_a);
	var pr_b = aid.priority(id_b);
	
	// Looking at the optional boolean "relevant" field, if we
	// showed no preference in our context, give these a
	// boost.
	if( pr_a == 0 && a['relevant'] ){ pr_a = boost; }
	if( pr_b == 0 && b['relevant'] ){ pr_b = boost; }
	
	return pr_b - pr_a;
    });
    var rellist = [];
    each(rels, function(rel){
	// We have the id.
	var r = [rel['id']];
	if( rel['label'] ){ // use their label
	    r.push(rel['label']);
	}else{ // otherwise, try readable
	    r.push(aid.readable(rel['id']));
	}
	rellist.push(r);
    });

    return rellist;
};

/*
 * Constructor: add_edge_modal
 * 
 * Contained shield for creating new edges between nodes.
 * 
 * Function that returns object.
 * 
 * TODO: make subclass?
 */
bbopx.noctua.widgets.add_edge_modal = function(ecore, manager,
					       relations, aid,
					       source_id, target_id){
    var each = bbop.core.each;
    var tag = bbop.html.tag;

    // Get a sorted list of known rels.
    var rellist = bbopx.noctua.widgets.sorted_relation_list(relations, aid);
    
    // Preamble.
    var mebe = [
	'<h4>Relation selection</h4>',
	'<b>Edge source:</b>',
	source_id,
	'<br />',
	'<b>Edge target:</b>',
	target_id
    ];

    // Randomized radio.
    var radio_name = bbop.core.uuid();
    var tcache = [mebe.join(' '),
		  '<div style="height: 25em; overflow-y: scroll;">'];
    each(rellist, function(tmp_rel, rel_ind){
	tcache.push('<div class="radio"><label>');
	tcache.push('<input type="radio" ');
	tcache.push('name="' + radio_name + '" ');
	tcache.push('value="' + tmp_rel[0] +'"');
	if( rel_ind == 0 ){
	    tcache.push('checked>');
	}else{
	    tcache.push('>');
	}
	tcache.push(tmp_rel[1] + ' ');
	tcache.push('(' + tmp_rel[0] + ')');
	tcache.push('</label></div>');	     
    });
    tcache.push('</div>');
    
    var save_btn_args = {
	'generate_id': true,
	'type': 'button',
	'class': 'btn btn-primary'
    };
    var save_btn = new tag('button', save_btn_args, 'Save');

    // Setup base modal.
    var mdl = new bbopx.noctua.widgets.contained_modal('dialog', 'Add Relation');
    mdl.add_to_body(tcache.join(''));
    mdl.add_to_footer(save_btn.to_string());

    // Add action listener to the save button.
    function _rel_save_button_start(){

	//
	//ll('looks like edge (in cb): ' + eeid);
	var qstr ='input:radio[name=' + radio_name + ']:checked';
	var rval = jQuery(qstr).val();
	// ll('rval: ' + rval);
	
	// // TODO: Should I report this too? Smells a
	// // bit like the missing properties with
	// // setParameter/s(),
	// // Change label.
	// //conn.setLabel(rval); // does not work!?
	// conn.removeOverlay("label");
	// conn.addOverlay(["Label", {'label': rval,
	// 			 'location': 0.5,
	// 			 'cssClass': "aLabel",
	// 			 'id': 'label' } ]);

	// Kick off callback.	
	manager.add_fact(ecore.get_id(), source_id,
			 target_id, rval);

	// Close modal.
	mdl.destroy();
    }
    // And add the new one for this instance.
    jQuery('#' + save_btn.get_id()).click(function(evt){
	evt.stopPropagation();
	_rel_save_button_start();
    });
    
    // Return our final product.
    return mdl;
};

/*
 * Constructor: edit_node_modal
 * 
 * Contained shield for editing the properties of a node (including
 * deletion).
 * 
 * Function that returns object.
 * 
 * TODO: make subclass?
 */
bbopx.noctua.widgets.edit_node_modal = function(ecore, manager, enode,
						relations, aid,
						gserv, gconf){
    var each = bbop.core.each;
    var tag = bbop.html.tag;

    // Start with ID.
    var tid = enode.id();

    // Create a list of types associated with the instance, as well as
    // capture their information for further editing.
    var elt2type = {};
    var type_list = [];
    each(bbopx.noctua.widgets.enode_to_stack(enode, aid), function(item){
	var type_str = bbopx.noctua.type_to_full(item, aid);
	var eid = bbop.core.uuid();
	elt2type[eid] = item;		 
	var acache = [];
	acache.push('<li class="list-group-item" style="background-color: '
		    + aid.color(item.category()) + ';">');
	acache.push(type_str);
	if( ! item.inferred_p() ){
	    acache.push('<span id="'+ eid +
			'" class="badge app-delete-mark">X</span>');
	}
	acache.push('<div class="clearfix"></div>');
	acache.push('</li>');
	type_list.push(acache.join(''));
    });

    // Generate embedded autocomplete for the relations.
    var svf_prop_text_args = {
    	'generate_id': true,
    	'type': 'text',
    	'class': 'form-control',
    	'placeholder':
	'Enter property to use (e.g. directly_activates, has_input)'
    };
    var svf_prop_text = new tag('input', svf_prop_text_args);

    // Create autocomplete box (enabled_by).
    var svf_class_text_args = {
    	'generate_id': true,
    	'type': 'text',
    	'class': 'form-control',
    	'placeholder': 'Enter ID or complex expression (enabled_by only)'
    };
    var svf_class_text = new tag('input', svf_class_text_args);

    // Create delete button.
    var add_svf_btn_args = {
    	'generate_id': true,
    	'type': 'button',
    	'class': 'btn btn-success'
    };
    var add_svf_btn = new tag('button', add_svf_btn_args, 'Add');

    var svf_form = [
    	'<div class="form">',
    	'<div class="form-group">',
	svf_prop_text.to_string(),
    	'</div>',
    	'<div class="form-group">',
	svf_class_text.to_string(),
    	'</div>',
    	add_svf_btn.to_string(),
    	'</div>'
    ];

    // Create delete button.
    var del_btn_args = {
    	'generate_id': true,
    	'type': 'button',
    	'class': 'btn btn-danger'
    };
    var del_btn = new tag('button', del_btn_args, 'Delete');

    //
    var tcache = [
	'<h4>Types</h4>',
	'<p>',
	'<ul class="list-group">',
	type_list.join('') || '<li class="list-group-item">none</li>',
	'</ul>',
	'<hr />',
	'</p>',
	'<h4>Add type</h4>',
	'<p>',
	svf_form.join(''),
	'</p>',
	'<hr />',
	'<h4>Other operations</h4>',
	// '<p>',
	del_btn.to_string(),
	'&nbsp;this individual'//,
	// '</p>'
    ];

    // Setup base modal.
    var mdl = new bbopx.noctua.widgets.contained_modal('dialog',
						       'Edit Instance: ' + tid);
    mdl.add_to_body(tcache.join(''));

    // Attach deletes to all of the listed types.
    each(elt2type, function(elt_id, type){
	jQuery('#' + elt_id).click(function(evt){
	    evt.stopPropagation();
	    var target_id = evt.target.id;
	    var target_type = elt2type[target_id];
	    var cid = target_type.class_id();
	    
	    manager.remove_class_expression(ecore.get_id(), tid, target_type);
	    // // Trigger the delete.
	    // if( target_type.type() == 'class' ){
	    // 	manager.remove_class_expression(ecore.get_id(), tid, cid);
	    // }else{
	    // 	var pid = target_type.property_id();
	    // 	manager.remove_class_expression(ecore.get_id(), tid,
	    // 					cid, target_type);
	    // }
	    // Wipe out modal.
	    mdl.destroy();
	});
    });

    // Generate the dropdown for the relations.
    var rellist = bbopx.noctua.widgets.sorted_relation_list(relations, aid);
    // Make the property autocomplete dance.
    var prop_sel_ac_list = [];
    each(rellist, function(rel){
	prop_sel_ac_list.push(
	    {
		'value': rel[0],
		//'desc': '???',
		'label': rel[1] + ' ('+ rel[0] +')'
	    });
    });
    jQuery('#' + svf_prop_text.get_id()).autocomplete({
	'minLength': 0,
	'source': prop_sel_ac_list,
	'focus': function(event, ui){
	    jQuery('#' + svf_prop_text.get_id()).val(ui.item.value);
	    return false;
	},
	select: function( event, ui ) {
	    jQuery('#' + svf_prop_text.get_id()).val(ui.item.value);
	    return false;
	}
    });// .autocomplete('#' + svf_prop_text.get_id()).val(ui.item.label)._renderItem = function(ul, item){
    // 	return jQuery('<li>')
    // 	    .append('<a>' + item.label + '<br />' + item.desc + '</a>')
    // 	    .appendTo(ul);
    // };

    // Add add expression action.
    jQuery('#' + add_svf_btn.get_id()).click(function(evt){
	evt.stopPropagation();
	
	var cls = jQuery('#' + svf_class_text.get_id()).val();
	//var prp = jQuery('#' + svf_prop_select.get_id()).val();
	var prp = jQuery('#' +  svf_prop_text.get_id()).val();
	if( cls && prp ){
	    // Trigger the delete--hopefully inconsistent.
	    manager.add_class_expression(
		ecore.get_id(), tid,
		bbopx.minerva.class_expression.svf(cls, prp));
	    
	    // Wipe out modal.
	    mdl.destroy();	    
	}else if( cls ){
	    // Trigger the delete--hopefully inconsistent.
	    manager.add_class_expression(ecore.get_id(), tid, cls);
	    
	    // Wipe out modal.
	    mdl.destroy();	    
	}else{
	    // Allow modal to remain for retry.
	    alert('At least class must be defined');
	}
    });
    
    // Add delete action.
    jQuery('#' + del_btn.get_id()).click(function(evt){
	evt.stopPropagation();
	
	// Trigger the delete--hopefully inconsistent.
	manager.remove_individual(ecore.get_id(), tid);
	
	// Wipe out modal.
	mdl.destroy();	    
    });
    
    // Add autocomplete box for ECO to evidence box.
    var eco_auto_args = {
    	'label_template':'{{annotation_class_label}} ({{annotation_class}})',
    	'value_template': '{{annotation_class}}',
    	'list_select_callback': function(doc){}
    };
    
    // Add general autocomplete to the input.
    var gen_auto_args = {
    	'label_template':'{{entity_label}} ({{entity}}/{{category}})',
    	'value_template': '{{entity}}',
    	'list_select_callback': function(doc){}
    };
    var gen_auto =
	new bbop.widget.search_box(gserv, gconf, svf_class_text.get_id(),
				   gen_auto_args);
    gen_auto.lite(true);
    gen_auto.add_query_filter('document_category', 'general');
    //gen_auto.add_query_filter('source', 'eco', ['+']);
    gen_auto.set_personality('general');

    // Return our final product.
    return mdl;
};

/*
 * Constructor: edit_annotation_modal
 * 
 * Contained shield for generically editing the annotations of an
 * identifier entity.
 * 
 * Function that returns object.
 * 
 * TODO: make subclass?
 */
bbopx.noctua.widgets.edit_annotations_modal = function(annotation_config,
						       ecore, manager, entity_id,
						       gserv, gconf){
    var each = bbop.core.each;
    var tag = bbop.html.tag;

    ///
    /// This first section describes a semi-generic way of generating
    /// callbacks to delete and add annotations to various enities.
    ///

    // Try and determine what type of entity we are dealing with:
    // model, node, edge.
    var entity = null;
    var entity_type = null;
    var entity_title = null;
    if( ecore.get_id() == entity_id ){
	entity = ecore;
	entity_type = 'model';
	entity_title = entity_id;
    }else if( ecore.get_node(entity_id) ){
	entity = ecore.get_node(entity_id);
	entity_type = 'individual';
	entity_title = entity_id;
    }else if( ecore.get_edge(entity_id) ){
	entity = ecore.get_edge(entity_id);
	entity_type = 'fact';
	entity_title = entity.source() + ' / ' +
	    entity.relation() + ' / ' +
	    entity.target();
    }else{
	// Apparently a bum ID.
    }

    // Create a "generic" enity-based dispatch to control all the
    // possible combinations of our "generic" interface in this case.
    // Usage of model brought in through closure.
    function _ann_dispatch(entity, entity_type, entity_op, model_id,
			   ann_key, ann_val){

	// Prepare args for ye olde dispatch.
	var args = {};
	if( entity_type == 'individual' ){
	    args['id'] = entity_id;
	}else if( entity_type == 'fact' ){
	    args['source'] = entity.source();
	    args['target'] = entity.target();
	    args['relation'] = entity.relation();
	}else{
	    // Model.
	    // TODO: would like a debug msg here.
	}

	// First, select function.
	var delegate_function = null;
	if( entity_type == 'individual' ){
	    delegate_function = manager.add_individual_annotation;
	    if( entity_op == 'remove' ){
		delegate_function = manager.remove_individual_annotation;
	    }
	    // All add/remove operations run with the same arguments:
	    // now run operation.
	    delegate_function(model_id, args['id'], ann_key, ann_val);
	}else if( entity_type == 'fact' ){
	    delegate_function = manager.add_fact_annotation;
	    if( entity_op == 'remove' ){
		delegate_function = manager.remove_fact_annotation;
	    }
	    delegate_function(model_id,
			      args['source'], args['target'], args['relation'],
			      ann_key, ann_val);
	}else{
	    // Model a wee bit different, and more simple.
	    delegate_function = manager.add_model_annotation;
	    if( entity_op == 'remove' ){
		delegate_function = manager.remove_model_annotation;
	    }
	    delegate_function(model_id, ann_key, ann_val);
	}
    }	

    ///
    /// This next section is concerned with generating the UI
    /// necessary and connecting it to the correct callbacks.
    ///
    
    // Constructor: 
    // A simple object to have a more object-like sub-widget for
    // handling the addition calls.
    //
    // widget_type - "text_area" or "text"
    function _abstract_annotation_widget(widget_type, placeholder){

	var anchor = this;

	// Create add button.
	var add_btn_args = {
    	    'generate_id': true,
    	    'type': 'button',
    	    'class': 'btn btn-success'
	};
	anchor.add_button = new tag('button', add_btn_args, 'Add');

	// The form control for the input area.
	var text_args = {
    	    'generate_id': true,
    	    //'type': 'text',
    	    'class': 'form-control',
    	    'placeholder': placeholder
	};
	if( widget_type == 'textarea' ){
	    text_args['type'] = 'text';
	    text_args['rows'] = '2';
	    anchor.text_input = new tag('textarea', text_args);
	}else{ // 'text'
	    text_args['type'] = 'text';
	    anchor.text_input = new tag('input', text_args);
	}

	// Both placed into the larger form string.
	var form = [];
	if( widget_type == 'textarea' ){
	    form = [
		'<div>',
		'<div class="form-group">',
		anchor.text_input.to_string(),
		'</div>',
    		anchor.add_button.to_string(),
		'</div>'
	    ];
	}else{ // 'text'
	    form = [
    		'<div class="form-inline">',
    		'<div class="form-group">',
		anchor.text_input.to_string(),
    		'</div>',
    		anchor.add_button.to_string(),
    		'</div>'
	    ];
	}
	anchor.form_string = form.join('');
    }

    //
    var mdl = null;
    if( ! entity ){
	alert('unknown id:' + entity_id);
    }else{
	
	// Go through our input list and create a mutable data
	// structure that we can then use to fill out the editor
	// slots.

	var ann_classes = {};
	each(annotation_config, function(ann_class){
	    var aid = ann_class['id'];

	    // Clone.
	    ann_classes[aid] = bbop.core.clone(ann_class);
	    
	    // Add our additions.
	    ann_classes[aid]['elt2ann'] = {};
	    ann_classes[aid]['list'] = [];
	    ann_classes[aid]['string'] = '???';
	    ann_classes[aid]['widget'] = null;
	});

	// Going through each of the annotation types, try and collect
	// them from the model.
	each(bbop.core.get_keys(ann_classes), function(key){
	    each(entity.get_annotations_by_filter(function(ann){
		var ret = false;
		if( ann.property(key) ){ ret = true; }
		return ret;
	    }), function(ann){

		// For every one found, assemble the actual display
		// string while storing the ids for later use.
		var kval = ann.property(key);
		var kid = bbop.core.uuid();

		// Only add to action set if mutable.
		if( ann_classes[key]['policy'] == 'mutable' ){
		    ann_classes[key]['elt2ann'][kid] = ann.id();
		}

		var acache = [];
		acache.push('<li class="list-group-item">');
		acache.push(kval);

		// Only add the delete UI bits if the policy says
		// mutable.
		if( ann_classes[key]['policy'] == 'mutable' ){
		    acache.push('<span id="'+ kid +
				'" class="badge app-delete-mark">X</span>');
		}

		acache.push('</li>');
		ann_classes[key]['list'].push(acache.join(''));
	    });

	    // Join whtaver is in the list together to get the display
	    // string.
	    // If we didn't collect anything, it's empty.
	    var str = '';
	    if( ann_classes[key]['list'].length > 0 ){
		str = ann_classes[key]['list'].join('');
		str = '<ul class="list-group">' + str + '</ul>';
	    }
	    ann_classes[key]['string'] = str;
	});

	// TODO: Generate the final code from the created structure.
	// Use the original ordering of the argument list.
	var out_cache = [];
	each(annotation_config, function(list_entry){	
    
	    //
	    var eid = list_entry['id'];
	    var entry_info = ann_classes[eid];
	    
	    //
	    var elbl =  entry_info['label'];
	    var ewid =  entry_info['widget_type'];
	    var epol =  entry_info['policy'];
	    var ecrd =  entry_info['cardinality'];
	    var eplc =  entry_info['placeholder'];
	    // Has?
	    var ehas = entry_info['list'].length || 0;
	    // UI output string.
	    var eout = entry_info['string'];

	    // Add whatever annotations we have.
	    out_cache.push('<div class="panel panel-default">');
	    //out_cache.push('<h4>' + elbl + '</h4>');
	    out_cache.push('<div class="panel-heading">' + elbl + '</div>');
	    out_cache.push('<div class="panel-body">');
	    //out_cache.push('<p>');
	    out_cache.push('<ul class="list-group">' + eout + '</ul>');
	    //out_cache.push('</p>');
	    
	    // And add an input widget if mutable...
	    //console.log('epol: ' + epol);
	    if( epol && epol == 'mutable' ){
		// ...and cardinality not one or has no items in list.
		//console.log(' ecrd: ' + ecrd);
		//console.log(' ehas: ' + ehas);
		if( ecrd != 'one' || ehas == 0 ){
		    console.log(' widget for: ' + eid);
		    var form_widget =
			    new _abstract_annotation_widget(ewid, eplc);

		    // Add to the literal output.
		    out_cache.push(form_widget.form_string);

		    // Add back to the collection for use after
		    // connecting to the DOM.
		    ann_classes[eid]['widget'] = form_widget;
		}
	    }

	    // Close out BS3 panel.
	    out_cache.push('</div>');
	    out_cache.push('</div>');
	});

	// Setup base modal.
	mdl = new bbopx.noctua.widgets.contained_modal('dialog',
						       'Annotations for: ' +
						       entity_title);
	mdl.add_to_body(out_cache.join(''));
	
	// Now that they're all in the DOM, add any delete annotation
	// actions. These are completely generic--all annotations can
	// be deleted in the same fashion.
	each(bbop.core.get_keys(ann_classes), function(ann_key){
	    each(ann_classes[ann_key]['elt2ann'], function(elt_id, ann_id){
		jQuery('#' + elt_id).click( function(evt){
		    evt.stopPropagation();
		    
		    //var annid = elt2ann[elt_id];
		    //alert('blow away: ' + annid);
		    var ann = entity.get_annotation_by_id(ann_id);
		    var ann_val = ann.property(ann_key);
		    _ann_dispatch(entity, entity_type, 'remove',
				  ecore.get_id(),ann_key, ann_val);
		    
		    // Wipe out modal on action.
		    mdl.destroy();
		});
	    });
	});
	
	// Walk through again, this time activating and annotation
	// "add" buttons that we added.
	each(bbop.core.get_keys(ann_classes), function(ann_key){
	    var form = ann_classes[ann_key]['widget'];
	    console.log('ann_key: ' + ann_key, form);
	    if( form ){ // only act if we added/defined it earlier
		
		jQuery('#' + form.add_button.get_id()).click(function(evt){
		    evt.stopPropagation();
	    
		    var val = jQuery('#' + form.text_input.get_id()).val();
		    if( val && val != '' ){
			_ann_dispatch(entity, entity_type, 'add',
				      ecore.get_id(), ann_key, val);
		    }else{
			alert('no ' + ann_key + ' added for ' + entity_id);
		    }
	    
		    // Wipe out modal.
		    mdl.destroy();	    
		});	
	    }
	});

	///
	/// Special section for special additions (autocomplete, etc.).
	/// TODO: Eventually, this should also be in the config.
	///
	
	// Add autocomplete box for ECO to evidence box.
	if( ann_classes['evidence'] && ann_classes['evidence']['widget'] ){
	    var ev_form = ann_classes['evidence']['widget'];
	    var eco_auto_args = {
    		'label_template':
		'{{annotation_class_label}} ({{annotation_class}})',
    		'value_template': '{{annotation_class}}',
    		'list_select_callback': function(doc){}
	    };
	    var eco_auto =
		    new bbop.widget.search_box(gserv, gconf,
					       ev_form.text_input.get_id(),
					       eco_auto_args);
	    eco_auto.lite(true);
	    eco_auto.add_query_filter('document_category', 'ontology_class');
	    eco_auto.add_query_filter('source', 'eco', ['+']);
	    eco_auto.set_personality('ontology');
	}
    }

    // Return our final product.
    return mdl;
};

/*
 * Constructor: reporter
 * 
 * Object.
 * 
 * Output formatted commentary to element.
 */
bbopx.noctua.widgets.reporter = function(output_id){

    var output_elt = '#' + output_id;
    var list_elt = null;

    // ...
    function _date_str(n){

	function _zero_fill(n){
	    var ret = n;
	    if( ret < 10 ){
		ret = '0' + ret;
	    }
	    return ret;
	}
	
	var now = new Date();
	var dts = now.getFullYear() + '/' +
	    _zero_fill(now.getMonth() +1) + '/' +
	    _zero_fill(now.getDate()) + ' ' +
	    _zero_fill(now.getHours()) + ':' +
	    _zero_fill(now.getMinutes()) + ':' +
	    _zero_fill(now.getSeconds());
	return dts;
    }	
    
    this.reset = function(){
	jQuery(output_elt).empty();
	var new_list_id = bbop.core.uuid();
	list_elt = '#' + new_list_id;
	jQuery(output_elt).append('<ul id="' + new_list_id + '"></ul>');
    };

    this.comment = function(message){
	
	// Try and set some defaults.
	var uid = null;
	var color = null;
	if( message ){
	    uid = message['user_name']
		|| message['user_email']
		|| message['socket_id'];
	    color = message['user_color'];
	}

	// Start.
	var out = '<li>';

	// Add color if defined.
	out += _date_str() + ': ';
	if( uid && color ){
	    out += '<span class="bbop-mme-message-uid" style="color:' +
		color + ';">'+ uid + '</span>: ';
	}else if( uid ){
	    out += '<span class="bbop-mme-message-uid">'+ uid + '</span>: ';
	}

	// Complicated datagram.
	var intent = message['intention'] || '???';
	var sig = message['signal'] || '???';
	var mess = message['message'] || '???';
	var mess_type = message['message_type'] || '???';

	// make a sensible message.
	if( mess_type == 'error' ){
	    out += mess_type + ': there was a problem: ' + mess; 
	}else{
	    if( sig == 'merge' || sig == 'rebuild' ){
		if( intent == 'query' ){
		    out += mess_type + ': they likely refreshed';		
		}else{		    
		    out += 'performed  <span class="bbop-mme-message-op">' +
			intent + '</span> (' + mess + '), ' +
			'<span class="">' +
			'you may with to refresh' + '</span>';
		}
	    }else{
		out += mess_type + ': ' + mess;		
	    }
	}

	// End.
	out += '</li>';

	// Actually do it.
	jQuery(list_elt).prepend(out);
    };

    // Initialize.
    this.reset();
};

/*
 * Function: user_check
 *
 * Given a token, either report a bad token ot
 *
 * Parameters: 
 *  barista_loc - barista location
 *  given_token - token
 *  
 * Returns: n/a
 */
bbopx.noctua.widgets.user_check = function(barista_loc, given_token, div_id){

    var user_info_loc = barista_loc + "/user_info_by_token/" + given_token;
    jQuery.ajax({
	'type': "GET",
	'url': user_info_loc,
	'dataType': "json",
	'error': function(){alert('had an error getting user info--oops!');},
	'success': function(data){
	    if( data && data['nickname'] ){
		jQuery('#' + div_id).replaceWith(data['nickname']);
	    }else{
		alert('You seem to have a bad token; will try to clean...');
		var to_remove = 'barista_token=' + given_token;
		var new_url = window.location.toString().replace(to_remove, '');
		//var new_url = window.location;
		window.location.replace(new_url);
	    }
	}
    });
};

// If it looks like we're in an environment that supports CommonJS
// Modules 1.0, take the bbop namespace whole and iteratively export
// it. Otherwise (browser environment, etc.), take no action and
// depend on the global namespace.
if( typeof(exports) != 'undefined' ){
    //exports.bbopx = bbopx;
    bbop.core.each(bbopx, function(k, v){
	exports[k] = v;
    });
}

},{"bbop":"bbop"}]},{},[]);
